
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model AcademicDiscipline
 * 
 */
export type AcademicDiscipline = $Result.DefaultSelection<Prisma.$AcademicDisciplinePayload>
/**
 * Model OnetOccupation
 * 
 */
export type OnetOccupation = $Result.DefaultSelection<Prisma.$OnetOccupationPayload>
/**
 * Model ResearchProject
 * 
 */
export type ResearchProject = $Result.DefaultSelection<Prisma.$ResearchProjectPayload>
/**
 * Model ProjectDiscipline
 * 
 */
export type ProjectDiscipline = $Result.DefaultSelection<Prisma.$ProjectDisciplinePayload>
/**
 * Model ProjectOccupation
 * 
 */
export type ProjectOccupation = $Result.DefaultSelection<Prisma.$ProjectOccupationPayload>
/**
 * Model MethodologyStep
 * 
 */
export type MethodologyStep = $Result.DefaultSelection<Prisma.$MethodologyStepPayload>
/**
 * Model ProjectMethodologyStep
 * 
 */
export type ProjectMethodologyStep = $Result.DefaultSelection<Prisma.$ProjectMethodologyStepPayload>
/**
 * Model UploadedImage
 * 
 */
export type UploadedImage = $Result.DefaultSelection<Prisma.$UploadedImagePayload>
/**
 * Model ResearchAnalysis
 * 
 */
export type ResearchAnalysis = $Result.DefaultSelection<Prisma.$ResearchAnalysisPayload>
/**
 * Model KnowledgeIntegration
 * 
 */
export type KnowledgeIntegration = $Result.DefaultSelection<Prisma.$KnowledgeIntegrationPayload>
/**
 * Model ProjectCollaborator
 * 
 */
export type ProjectCollaborator = $Result.DefaultSelection<Prisma.$ProjectCollaboratorPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  admin: 'admin',
  researcher: 'researcher',
  analyst: 'analyst',
  student: 'student'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ProjectStatus: {
  planning: 'planning',
  active: 'active',
  completed: 'completed',
  on_hold: 'on_hold',
  cancelled: 'cancelled'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const MethodologyType: {
  multidisciplinary_engineering: 'multidisciplinary_engineering',
  human_centered_design: 'human_centered_design',
  design_thinking: 'design_thinking',
  agile_research: 'agile_research',
  scientific_method: 'scientific_method',
  case_study: 'case_study',
  action_research: 'action_research'
};

export type MethodologyType = (typeof MethodologyType)[keyof typeof MethodologyType]


export const AnalysisStatus: {
  pending: 'pending',
  processing: 'processing',
  completed: 'completed',
  failed: 'failed',
  review_required: 'review_required'
};

export type AnalysisStatus = (typeof AnalysisStatus)[keyof typeof AnalysisStatus]


export const KnowledgeIntegrationType: {
  cross_reference: 'cross_reference',
  synthesis: 'synthesis',
  comparison: 'comparison',
  validation: 'validation',
  innovation: 'innovation'
};

export type KnowledgeIntegrationType = (typeof KnowledgeIntegrationType)[keyof typeof KnowledgeIntegrationType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type MethodologyType = $Enums.MethodologyType

export const MethodologyType: typeof $Enums.MethodologyType

export type AnalysisStatus = $Enums.AnalysisStatus

export const AnalysisStatus: typeof $Enums.AnalysisStatus

export type KnowledgeIntegrationType = $Enums.KnowledgeIntegrationType

export const KnowledgeIntegrationType: typeof $Enums.KnowledgeIntegrationType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.academicDiscipline`: Exposes CRUD operations for the **AcademicDiscipline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicDisciplines
    * const academicDisciplines = await prisma.academicDiscipline.findMany()
    * ```
    */
  get academicDiscipline(): Prisma.AcademicDisciplineDelegate<ExtArgs>;

  /**
   * `prisma.onetOccupation`: Exposes CRUD operations for the **OnetOccupation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OnetOccupations
    * const onetOccupations = await prisma.onetOccupation.findMany()
    * ```
    */
  get onetOccupation(): Prisma.OnetOccupationDelegate<ExtArgs>;

  /**
   * `prisma.researchProject`: Exposes CRUD operations for the **ResearchProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResearchProjects
    * const researchProjects = await prisma.researchProject.findMany()
    * ```
    */
  get researchProject(): Prisma.ResearchProjectDelegate<ExtArgs>;

  /**
   * `prisma.projectDiscipline`: Exposes CRUD operations for the **ProjectDiscipline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectDisciplines
    * const projectDisciplines = await prisma.projectDiscipline.findMany()
    * ```
    */
  get projectDiscipline(): Prisma.ProjectDisciplineDelegate<ExtArgs>;

  /**
   * `prisma.projectOccupation`: Exposes CRUD operations for the **ProjectOccupation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectOccupations
    * const projectOccupations = await prisma.projectOccupation.findMany()
    * ```
    */
  get projectOccupation(): Prisma.ProjectOccupationDelegate<ExtArgs>;

  /**
   * `prisma.methodologyStep`: Exposes CRUD operations for the **MethodologyStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MethodologySteps
    * const methodologySteps = await prisma.methodologyStep.findMany()
    * ```
    */
  get methodologyStep(): Prisma.MethodologyStepDelegate<ExtArgs>;

  /**
   * `prisma.projectMethodologyStep`: Exposes CRUD operations for the **ProjectMethodologyStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMethodologySteps
    * const projectMethodologySteps = await prisma.projectMethodologyStep.findMany()
    * ```
    */
  get projectMethodologyStep(): Prisma.ProjectMethodologyStepDelegate<ExtArgs>;

  /**
   * `prisma.uploadedImage`: Exposes CRUD operations for the **UploadedImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UploadedImages
    * const uploadedImages = await prisma.uploadedImage.findMany()
    * ```
    */
  get uploadedImage(): Prisma.UploadedImageDelegate<ExtArgs>;

  /**
   * `prisma.researchAnalysis`: Exposes CRUD operations for the **ResearchAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResearchAnalyses
    * const researchAnalyses = await prisma.researchAnalysis.findMany()
    * ```
    */
  get researchAnalysis(): Prisma.ResearchAnalysisDelegate<ExtArgs>;

  /**
   * `prisma.knowledgeIntegration`: Exposes CRUD operations for the **KnowledgeIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeIntegrations
    * const knowledgeIntegrations = await prisma.knowledgeIntegration.findMany()
    * ```
    */
  get knowledgeIntegration(): Prisma.KnowledgeIntegrationDelegate<ExtArgs>;

  /**
   * `prisma.projectCollaborator`: Exposes CRUD operations for the **ProjectCollaborator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectCollaborators
    * const projectCollaborators = await prisma.projectCollaborator.findMany()
    * ```
    */
  get projectCollaborator(): Prisma.ProjectCollaboratorDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    AcademicDiscipline: 'AcademicDiscipline',
    OnetOccupation: 'OnetOccupation',
    ResearchProject: 'ResearchProject',
    ProjectDiscipline: 'ProjectDiscipline',
    ProjectOccupation: 'ProjectOccupation',
    MethodologyStep: 'MethodologyStep',
    ProjectMethodologyStep: 'ProjectMethodologyStep',
    UploadedImage: 'UploadedImage',
    ResearchAnalysis: 'ResearchAnalysis',
    KnowledgeIntegration: 'KnowledgeIntegration',
    ProjectCollaborator: 'ProjectCollaborator'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "academicDiscipline" | "onetOccupation" | "researchProject" | "projectDiscipline" | "projectOccupation" | "methodologyStep" | "projectMethodologyStep" | "uploadedImage" | "researchAnalysis" | "knowledgeIntegration" | "projectCollaborator"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      AcademicDiscipline: {
        payload: Prisma.$AcademicDisciplinePayload<ExtArgs>
        fields: Prisma.AcademicDisciplineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicDisciplineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDisciplinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicDisciplineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDisciplinePayload>
          }
          findFirst: {
            args: Prisma.AcademicDisciplineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDisciplinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicDisciplineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDisciplinePayload>
          }
          findMany: {
            args: Prisma.AcademicDisciplineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDisciplinePayload>[]
          }
          create: {
            args: Prisma.AcademicDisciplineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDisciplinePayload>
          }
          createMany: {
            args: Prisma.AcademicDisciplineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicDisciplineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDisciplinePayload>[]
          }
          delete: {
            args: Prisma.AcademicDisciplineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDisciplinePayload>
          }
          update: {
            args: Prisma.AcademicDisciplineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDisciplinePayload>
          }
          deleteMany: {
            args: Prisma.AcademicDisciplineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicDisciplineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcademicDisciplineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDisciplinePayload>
          }
          aggregate: {
            args: Prisma.AcademicDisciplineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicDiscipline>
          }
          groupBy: {
            args: Prisma.AcademicDisciplineGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicDisciplineGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicDisciplineCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicDisciplineCountAggregateOutputType> | number
          }
        }
      }
      OnetOccupation: {
        payload: Prisma.$OnetOccupationPayload<ExtArgs>
        fields: Prisma.OnetOccupationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OnetOccupationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnetOccupationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OnetOccupationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnetOccupationPayload>
          }
          findFirst: {
            args: Prisma.OnetOccupationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnetOccupationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OnetOccupationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnetOccupationPayload>
          }
          findMany: {
            args: Prisma.OnetOccupationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnetOccupationPayload>[]
          }
          create: {
            args: Prisma.OnetOccupationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnetOccupationPayload>
          }
          createMany: {
            args: Prisma.OnetOccupationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OnetOccupationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnetOccupationPayload>[]
          }
          delete: {
            args: Prisma.OnetOccupationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnetOccupationPayload>
          }
          update: {
            args: Prisma.OnetOccupationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnetOccupationPayload>
          }
          deleteMany: {
            args: Prisma.OnetOccupationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OnetOccupationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OnetOccupationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnetOccupationPayload>
          }
          aggregate: {
            args: Prisma.OnetOccupationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOnetOccupation>
          }
          groupBy: {
            args: Prisma.OnetOccupationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OnetOccupationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OnetOccupationCountArgs<ExtArgs>
            result: $Utils.Optional<OnetOccupationCountAggregateOutputType> | number
          }
        }
      }
      ResearchProject: {
        payload: Prisma.$ResearchProjectPayload<ExtArgs>
        fields: Prisma.ResearchProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResearchProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResearchProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectPayload>
          }
          findFirst: {
            args: Prisma.ResearchProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResearchProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectPayload>
          }
          findMany: {
            args: Prisma.ResearchProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectPayload>[]
          }
          create: {
            args: Prisma.ResearchProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectPayload>
          }
          createMany: {
            args: Prisma.ResearchProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResearchProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectPayload>[]
          }
          delete: {
            args: Prisma.ResearchProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectPayload>
          }
          update: {
            args: Prisma.ResearchProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectPayload>
          }
          deleteMany: {
            args: Prisma.ResearchProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResearchProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResearchProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProjectPayload>
          }
          aggregate: {
            args: Prisma.ResearchProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResearchProject>
          }
          groupBy: {
            args: Prisma.ResearchProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResearchProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResearchProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ResearchProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectDiscipline: {
        payload: Prisma.$ProjectDisciplinePayload<ExtArgs>
        fields: Prisma.ProjectDisciplineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectDisciplineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDisciplinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectDisciplineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDisciplinePayload>
          }
          findFirst: {
            args: Prisma.ProjectDisciplineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDisciplinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectDisciplineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDisciplinePayload>
          }
          findMany: {
            args: Prisma.ProjectDisciplineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDisciplinePayload>[]
          }
          create: {
            args: Prisma.ProjectDisciplineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDisciplinePayload>
          }
          createMany: {
            args: Prisma.ProjectDisciplineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectDisciplineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDisciplinePayload>[]
          }
          delete: {
            args: Prisma.ProjectDisciplineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDisciplinePayload>
          }
          update: {
            args: Prisma.ProjectDisciplineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDisciplinePayload>
          }
          deleteMany: {
            args: Prisma.ProjectDisciplineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectDisciplineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectDisciplineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDisciplinePayload>
          }
          aggregate: {
            args: Prisma.ProjectDisciplineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectDiscipline>
          }
          groupBy: {
            args: Prisma.ProjectDisciplineGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectDisciplineGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectDisciplineCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectDisciplineCountAggregateOutputType> | number
          }
        }
      }
      ProjectOccupation: {
        payload: Prisma.$ProjectOccupationPayload<ExtArgs>
        fields: Prisma.ProjectOccupationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectOccupationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOccupationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectOccupationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOccupationPayload>
          }
          findFirst: {
            args: Prisma.ProjectOccupationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOccupationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectOccupationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOccupationPayload>
          }
          findMany: {
            args: Prisma.ProjectOccupationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOccupationPayload>[]
          }
          create: {
            args: Prisma.ProjectOccupationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOccupationPayload>
          }
          createMany: {
            args: Prisma.ProjectOccupationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectOccupationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOccupationPayload>[]
          }
          delete: {
            args: Prisma.ProjectOccupationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOccupationPayload>
          }
          update: {
            args: Prisma.ProjectOccupationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOccupationPayload>
          }
          deleteMany: {
            args: Prisma.ProjectOccupationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectOccupationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectOccupationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOccupationPayload>
          }
          aggregate: {
            args: Prisma.ProjectOccupationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectOccupation>
          }
          groupBy: {
            args: Prisma.ProjectOccupationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectOccupationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectOccupationCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectOccupationCountAggregateOutputType> | number
          }
        }
      }
      MethodologyStep: {
        payload: Prisma.$MethodologyStepPayload<ExtArgs>
        fields: Prisma.MethodologyStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MethodologyStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MethodologyStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyStepPayload>
          }
          findFirst: {
            args: Prisma.MethodologyStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MethodologyStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyStepPayload>
          }
          findMany: {
            args: Prisma.MethodologyStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyStepPayload>[]
          }
          create: {
            args: Prisma.MethodologyStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyStepPayload>
          }
          createMany: {
            args: Prisma.MethodologyStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MethodologyStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyStepPayload>[]
          }
          delete: {
            args: Prisma.MethodologyStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyStepPayload>
          }
          update: {
            args: Prisma.MethodologyStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyStepPayload>
          }
          deleteMany: {
            args: Prisma.MethodologyStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MethodologyStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MethodologyStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyStepPayload>
          }
          aggregate: {
            args: Prisma.MethodologyStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMethodologyStep>
          }
          groupBy: {
            args: Prisma.MethodologyStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<MethodologyStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.MethodologyStepCountArgs<ExtArgs>
            result: $Utils.Optional<MethodologyStepCountAggregateOutputType> | number
          }
        }
      }
      ProjectMethodologyStep: {
        payload: Prisma.$ProjectMethodologyStepPayload<ExtArgs>
        fields: Prisma.ProjectMethodologyStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMethodologyStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMethodologyStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMethodologyStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMethodologyStepPayload>
          }
          findFirst: {
            args: Prisma.ProjectMethodologyStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMethodologyStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMethodologyStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMethodologyStepPayload>
          }
          findMany: {
            args: Prisma.ProjectMethodologyStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMethodologyStepPayload>[]
          }
          create: {
            args: Prisma.ProjectMethodologyStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMethodologyStepPayload>
          }
          createMany: {
            args: Prisma.ProjectMethodologyStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMethodologyStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMethodologyStepPayload>[]
          }
          delete: {
            args: Prisma.ProjectMethodologyStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMethodologyStepPayload>
          }
          update: {
            args: Prisma.ProjectMethodologyStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMethodologyStepPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMethodologyStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMethodologyStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectMethodologyStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMethodologyStepPayload>
          }
          aggregate: {
            args: Prisma.ProjectMethodologyStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMethodologyStep>
          }
          groupBy: {
            args: Prisma.ProjectMethodologyStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMethodologyStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMethodologyStepCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMethodologyStepCountAggregateOutputType> | number
          }
        }
      }
      UploadedImage: {
        payload: Prisma.$UploadedImagePayload<ExtArgs>
        fields: Prisma.UploadedImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UploadedImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UploadedImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedImagePayload>
          }
          findFirst: {
            args: Prisma.UploadedImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UploadedImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedImagePayload>
          }
          findMany: {
            args: Prisma.UploadedImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedImagePayload>[]
          }
          create: {
            args: Prisma.UploadedImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedImagePayload>
          }
          createMany: {
            args: Prisma.UploadedImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UploadedImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedImagePayload>[]
          }
          delete: {
            args: Prisma.UploadedImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedImagePayload>
          }
          update: {
            args: Prisma.UploadedImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedImagePayload>
          }
          deleteMany: {
            args: Prisma.UploadedImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UploadedImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UploadedImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedImagePayload>
          }
          aggregate: {
            args: Prisma.UploadedImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUploadedImage>
          }
          groupBy: {
            args: Prisma.UploadedImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<UploadedImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.UploadedImageCountArgs<ExtArgs>
            result: $Utils.Optional<UploadedImageCountAggregateOutputType> | number
          }
        }
      }
      ResearchAnalysis: {
        payload: Prisma.$ResearchAnalysisPayload<ExtArgs>
        fields: Prisma.ResearchAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResearchAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResearchAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchAnalysisPayload>
          }
          findFirst: {
            args: Prisma.ResearchAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResearchAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchAnalysisPayload>
          }
          findMany: {
            args: Prisma.ResearchAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchAnalysisPayload>[]
          }
          create: {
            args: Prisma.ResearchAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchAnalysisPayload>
          }
          createMany: {
            args: Prisma.ResearchAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResearchAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchAnalysisPayload>[]
          }
          delete: {
            args: Prisma.ResearchAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchAnalysisPayload>
          }
          update: {
            args: Prisma.ResearchAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.ResearchAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResearchAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResearchAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchAnalysisPayload>
          }
          aggregate: {
            args: Prisma.ResearchAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResearchAnalysis>
          }
          groupBy: {
            args: Prisma.ResearchAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResearchAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResearchAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<ResearchAnalysisCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeIntegration: {
        payload: Prisma.$KnowledgeIntegrationPayload<ExtArgs>
        fields: Prisma.KnowledgeIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeIntegrationPayload>
          }
          findFirst: {
            args: Prisma.KnowledgeIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeIntegrationPayload>
          }
          findMany: {
            args: Prisma.KnowledgeIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeIntegrationPayload>[]
          }
          create: {
            args: Prisma.KnowledgeIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeIntegrationPayload>
          }
          createMany: {
            args: Prisma.KnowledgeIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeIntegrationPayload>[]
          }
          delete: {
            args: Prisma.KnowledgeIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeIntegrationPayload>
          }
          update: {
            args: Prisma.KnowledgeIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KnowledgeIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeIntegrationPayload>
          }
          aggregate: {
            args: Prisma.KnowledgeIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeIntegration>
          }
          groupBy: {
            args: Prisma.KnowledgeIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeIntegrationCountAggregateOutputType> | number
          }
        }
      }
      ProjectCollaborator: {
        payload: Prisma.$ProjectCollaboratorPayload<ExtArgs>
        fields: Prisma.ProjectCollaboratorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectCollaboratorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectCollaboratorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          findFirst: {
            args: Prisma.ProjectCollaboratorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectCollaboratorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          findMany: {
            args: Prisma.ProjectCollaboratorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>[]
          }
          create: {
            args: Prisma.ProjectCollaboratorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          createMany: {
            args: Prisma.ProjectCollaboratorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCollaboratorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>[]
          }
          delete: {
            args: Prisma.ProjectCollaboratorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          update: {
            args: Prisma.ProjectCollaboratorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          deleteMany: {
            args: Prisma.ProjectCollaboratorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectCollaboratorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectCollaboratorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCollaboratorPayload>
          }
          aggregate: {
            args: Prisma.ProjectCollaboratorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectCollaborator>
          }
          groupBy: {
            args: Prisma.ProjectCollaboratorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectCollaboratorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCollaboratorCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCollaboratorCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    knowledgeIntegrations: number
    projectCollaborations: number
    assignedMethodologySteps: number
    analyses: number
    approvedAnalyses: number
    reviewedAnalyses: number
    projects: number
    uploadedImages: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledgeIntegrations?: boolean | UserCountOutputTypeCountKnowledgeIntegrationsArgs
    projectCollaborations?: boolean | UserCountOutputTypeCountProjectCollaborationsArgs
    assignedMethodologySteps?: boolean | UserCountOutputTypeCountAssignedMethodologyStepsArgs
    analyses?: boolean | UserCountOutputTypeCountAnalysesArgs
    approvedAnalyses?: boolean | UserCountOutputTypeCountApprovedAnalysesArgs
    reviewedAnalyses?: boolean | UserCountOutputTypeCountReviewedAnalysesArgs
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    uploadedImages?: boolean | UserCountOutputTypeCountUploadedImagesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountKnowledgeIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeIntegrationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectCollaborationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectCollaboratorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedMethodologyStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMethodologyStepWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchAnalysisWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchAnalysisWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewedAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchAnalysisWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadedImageWhereInput
  }


  /**
   * Count Type AcademicDisciplineCountOutputType
   */

  export type AcademicDisciplineCountOutputType = {
    childDisciplines: number
    knowledgeIntegrationsSource: number
    knowledgeIntegrationsTarget: number
    projectDisciplines: number
  }

  export type AcademicDisciplineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childDisciplines?: boolean | AcademicDisciplineCountOutputTypeCountChildDisciplinesArgs
    knowledgeIntegrationsSource?: boolean | AcademicDisciplineCountOutputTypeCountKnowledgeIntegrationsSourceArgs
    knowledgeIntegrationsTarget?: boolean | AcademicDisciplineCountOutputTypeCountKnowledgeIntegrationsTargetArgs
    projectDisciplines?: boolean | AcademicDisciplineCountOutputTypeCountProjectDisciplinesArgs
  }

  // Custom InputTypes
  /**
   * AcademicDisciplineCountOutputType without action
   */
  export type AcademicDisciplineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDisciplineCountOutputType
     */
    select?: AcademicDisciplineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicDisciplineCountOutputType without action
   */
  export type AcademicDisciplineCountOutputTypeCountChildDisciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicDisciplineWhereInput
  }

  /**
   * AcademicDisciplineCountOutputType without action
   */
  export type AcademicDisciplineCountOutputTypeCountKnowledgeIntegrationsSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeIntegrationWhereInput
  }

  /**
   * AcademicDisciplineCountOutputType without action
   */
  export type AcademicDisciplineCountOutputTypeCountKnowledgeIntegrationsTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeIntegrationWhereInput
  }

  /**
   * AcademicDisciplineCountOutputType without action
   */
  export type AcademicDisciplineCountOutputTypeCountProjectDisciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectDisciplineWhereInput
  }


  /**
   * Count Type OnetOccupationCountOutputType
   */

  export type OnetOccupationCountOutputType = {
    projectOccupations: number
  }

  export type OnetOccupationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectOccupations?: boolean | OnetOccupationCountOutputTypeCountProjectOccupationsArgs
  }

  // Custom InputTypes
  /**
   * OnetOccupationCountOutputType without action
   */
  export type OnetOccupationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnetOccupationCountOutputType
     */
    select?: OnetOccupationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OnetOccupationCountOutputType without action
   */
  export type OnetOccupationCountOutputTypeCountProjectOccupationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectOccupationWhereInput
  }


  /**
   * Count Type ResearchProjectCountOutputType
   */

  export type ResearchProjectCountOutputType = {
    knowledgeIntegrations: number
    collaborators: number
    disciplines: number
    methodologySteps: number
    occupations: number
    analyses: number
    images: number
  }

  export type ResearchProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledgeIntegrations?: boolean | ResearchProjectCountOutputTypeCountKnowledgeIntegrationsArgs
    collaborators?: boolean | ResearchProjectCountOutputTypeCountCollaboratorsArgs
    disciplines?: boolean | ResearchProjectCountOutputTypeCountDisciplinesArgs
    methodologySteps?: boolean | ResearchProjectCountOutputTypeCountMethodologyStepsArgs
    occupations?: boolean | ResearchProjectCountOutputTypeCountOccupationsArgs
    analyses?: boolean | ResearchProjectCountOutputTypeCountAnalysesArgs
    images?: boolean | ResearchProjectCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * ResearchProjectCountOutputType without action
   */
  export type ResearchProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProjectCountOutputType
     */
    select?: ResearchProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResearchProjectCountOutputType without action
   */
  export type ResearchProjectCountOutputTypeCountKnowledgeIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeIntegrationWhereInput
  }

  /**
   * ResearchProjectCountOutputType without action
   */
  export type ResearchProjectCountOutputTypeCountCollaboratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectCollaboratorWhereInput
  }

  /**
   * ResearchProjectCountOutputType without action
   */
  export type ResearchProjectCountOutputTypeCountDisciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectDisciplineWhereInput
  }

  /**
   * ResearchProjectCountOutputType without action
   */
  export type ResearchProjectCountOutputTypeCountMethodologyStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMethodologyStepWhereInput
  }

  /**
   * ResearchProjectCountOutputType without action
   */
  export type ResearchProjectCountOutputTypeCountOccupationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectOccupationWhereInput
  }

  /**
   * ResearchProjectCountOutputType without action
   */
  export type ResearchProjectCountOutputTypeCountAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchAnalysisWhereInput
  }

  /**
   * ResearchProjectCountOutputType without action
   */
  export type ResearchProjectCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadedImageWhereInput
  }


  /**
   * Count Type MethodologyStepCountOutputType
   */

  export type MethodologyStepCountOutputType = {
    projectSteps: number
  }

  export type MethodologyStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectSteps?: boolean | MethodologyStepCountOutputTypeCountProjectStepsArgs
  }

  // Custom InputTypes
  /**
   * MethodologyStepCountOutputType without action
   */
  export type MethodologyStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodologyStepCountOutputType
     */
    select?: MethodologyStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MethodologyStepCountOutputType without action
   */
  export type MethodologyStepCountOutputTypeCountProjectStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMethodologyStepWhereInput
  }


  /**
   * Count Type UploadedImageCountOutputType
   */

  export type UploadedImageCountOutputType = {
    analyses: number
  }

  export type UploadedImageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analyses?: boolean | UploadedImageCountOutputTypeCountAnalysesArgs
  }

  // Custom InputTypes
  /**
   * UploadedImageCountOutputType without action
   */
  export type UploadedImageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedImageCountOutputType
     */
    select?: UploadedImageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UploadedImageCountOutputType without action
   */
  export type UploadedImageCountOutputTypeCountAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchAnalysisWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    tokensTotal: number | null
    tokensUsedToday: number | null
  }

  export type UserSumAggregateOutputType = {
    tokensTotal: number | null
    tokensUsedToday: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    avatar: string | null
    role: $Enums.UserRole | null
    institution: string | null
    department: string | null
    orcidId: string | null
    googleScholarId: string | null
    linkedinUrl: string | null
    isVerified: boolean | null
    memberSince: Date | null
    lastActive: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    tokensTotal: number | null
    tokensUsedToday: number | null
    tokenLastResetDate: Date | null
    isPro: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    avatar: string | null
    role: $Enums.UserRole | null
    institution: string | null
    department: string | null
    orcidId: string | null
    googleScholarId: string | null
    linkedinUrl: string | null
    isVerified: boolean | null
    memberSince: Date | null
    lastActive: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    tokensTotal: number | null
    tokensUsedToday: number | null
    tokenLastResetDate: Date | null
    isPro: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    avatar: number
    role: number
    institution: number
    department: number
    specialization: number
    orcidId: number
    googleScholarId: number
    linkedinUrl: number
    isVerified: number
    preferences: number
    memberSince: number
    lastActive: number
    createdAt: number
    updatedAt: number
    tokensTotal: number
    tokensUsedToday: number
    tokenLastResetDate: number
    isPro: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    tokensTotal?: true
    tokensUsedToday?: true
  }

  export type UserSumAggregateInputType = {
    tokensTotal?: true
    tokensUsedToday?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    role?: true
    institution?: true
    department?: true
    orcidId?: true
    googleScholarId?: true
    linkedinUrl?: true
    isVerified?: true
    memberSince?: true
    lastActive?: true
    createdAt?: true
    updatedAt?: true
    tokensTotal?: true
    tokensUsedToday?: true
    tokenLastResetDate?: true
    isPro?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    role?: true
    institution?: true
    department?: true
    orcidId?: true
    googleScholarId?: true
    linkedinUrl?: true
    isVerified?: true
    memberSince?: true
    lastActive?: true
    createdAt?: true
    updatedAt?: true
    tokensTotal?: true
    tokensUsedToday?: true
    tokenLastResetDate?: true
    isPro?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    role?: true
    institution?: true
    department?: true
    specialization?: true
    orcidId?: true
    googleScholarId?: true
    linkedinUrl?: true
    isVerified?: true
    preferences?: true
    memberSince?: true
    lastActive?: true
    createdAt?: true
    updatedAt?: true
    tokensTotal?: true
    tokensUsedToday?: true
    tokenLastResetDate?: true
    isPro?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    avatar: string | null
    role: $Enums.UserRole
    institution: string | null
    department: string | null
    specialization: string[]
    orcidId: string | null
    googleScholarId: string | null
    linkedinUrl: string | null
    isVerified: boolean
    preferences: JsonValue
    memberSince: Date
    lastActive: Date
    createdAt: Date
    updatedAt: Date
    tokensTotal: number
    tokensUsedToday: number
    tokenLastResetDate: Date
    isPro: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    role?: boolean
    institution?: boolean
    department?: boolean
    specialization?: boolean
    orcidId?: boolean
    googleScholarId?: boolean
    linkedinUrl?: boolean
    isVerified?: boolean
    preferences?: boolean
    memberSince?: boolean
    lastActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tokensTotal?: boolean
    tokensUsedToday?: boolean
    tokenLastResetDate?: boolean
    isPro?: boolean
    knowledgeIntegrations?: boolean | User$knowledgeIntegrationsArgs<ExtArgs>
    projectCollaborations?: boolean | User$projectCollaborationsArgs<ExtArgs>
    assignedMethodologySteps?: boolean | User$assignedMethodologyStepsArgs<ExtArgs>
    analyses?: boolean | User$analysesArgs<ExtArgs>
    approvedAnalyses?: boolean | User$approvedAnalysesArgs<ExtArgs>
    reviewedAnalyses?: boolean | User$reviewedAnalysesArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    uploadedImages?: boolean | User$uploadedImagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    role?: boolean
    institution?: boolean
    department?: boolean
    specialization?: boolean
    orcidId?: boolean
    googleScholarId?: boolean
    linkedinUrl?: boolean
    isVerified?: boolean
    preferences?: boolean
    memberSince?: boolean
    lastActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tokensTotal?: boolean
    tokensUsedToday?: boolean
    tokenLastResetDate?: boolean
    isPro?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    role?: boolean
    institution?: boolean
    department?: boolean
    specialization?: boolean
    orcidId?: boolean
    googleScholarId?: boolean
    linkedinUrl?: boolean
    isVerified?: boolean
    preferences?: boolean
    memberSince?: boolean
    lastActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tokensTotal?: boolean
    tokensUsedToday?: boolean
    tokenLastResetDate?: boolean
    isPro?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledgeIntegrations?: boolean | User$knowledgeIntegrationsArgs<ExtArgs>
    projectCollaborations?: boolean | User$projectCollaborationsArgs<ExtArgs>
    assignedMethodologySteps?: boolean | User$assignedMethodologyStepsArgs<ExtArgs>
    analyses?: boolean | User$analysesArgs<ExtArgs>
    approvedAnalyses?: boolean | User$approvedAnalysesArgs<ExtArgs>
    reviewedAnalyses?: boolean | User$reviewedAnalysesArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    uploadedImages?: boolean | User$uploadedImagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      knowledgeIntegrations: Prisma.$KnowledgeIntegrationPayload<ExtArgs>[]
      projectCollaborations: Prisma.$ProjectCollaboratorPayload<ExtArgs>[]
      assignedMethodologySteps: Prisma.$ProjectMethodologyStepPayload<ExtArgs>[]
      analyses: Prisma.$ResearchAnalysisPayload<ExtArgs>[]
      approvedAnalyses: Prisma.$ResearchAnalysisPayload<ExtArgs>[]
      reviewedAnalyses: Prisma.$ResearchAnalysisPayload<ExtArgs>[]
      projects: Prisma.$ResearchProjectPayload<ExtArgs>[]
      uploadedImages: Prisma.$UploadedImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      avatar: string | null
      role: $Enums.UserRole
      institution: string | null
      department: string | null
      specialization: string[]
      orcidId: string | null
      googleScholarId: string | null
      linkedinUrl: string | null
      isVerified: boolean
      preferences: Prisma.JsonValue
      memberSince: Date
      lastActive: Date
      createdAt: Date
      updatedAt: Date
      tokensTotal: number
      tokensUsedToday: number
      tokenLastResetDate: Date
      isPro: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    knowledgeIntegrations<T extends User$knowledgeIntegrationsArgs<ExtArgs> = {}>(args?: Subset<T, User$knowledgeIntegrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeIntegrationPayload<ExtArgs>, T, "findMany"> | Null>
    projectCollaborations<T extends User$projectCollaborationsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectCollaborationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findMany"> | Null>
    assignedMethodologySteps<T extends User$assignedMethodologyStepsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedMethodologyStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMethodologyStepPayload<ExtArgs>, T, "findMany"> | Null>
    analyses<T extends User$analysesArgs<ExtArgs> = {}>(args?: Subset<T, User$analysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchAnalysisPayload<ExtArgs>, T, "findMany"> | Null>
    approvedAnalyses<T extends User$approvedAnalysesArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedAnalysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchAnalysisPayload<ExtArgs>, T, "findMany"> | Null>
    reviewedAnalyses<T extends User$reviewedAnalysesArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewedAnalysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchAnalysisPayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "findMany"> | Null>
    uploadedImages<T extends User$uploadedImagesArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadedImagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly institution: FieldRef<"User", 'String'>
    readonly department: FieldRef<"User", 'String'>
    readonly specialization: FieldRef<"User", 'String[]'>
    readonly orcidId: FieldRef<"User", 'String'>
    readonly googleScholarId: FieldRef<"User", 'String'>
    readonly linkedinUrl: FieldRef<"User", 'String'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly preferences: FieldRef<"User", 'Json'>
    readonly memberSince: FieldRef<"User", 'DateTime'>
    readonly lastActive: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly tokensTotal: FieldRef<"User", 'Int'>
    readonly tokensUsedToday: FieldRef<"User", 'Int'>
    readonly tokenLastResetDate: FieldRef<"User", 'DateTime'>
    readonly isPro: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.knowledgeIntegrations
   */
  export type User$knowledgeIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeIntegration
     */
    select?: KnowledgeIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeIntegrationInclude<ExtArgs> | null
    where?: KnowledgeIntegrationWhereInput
    orderBy?: KnowledgeIntegrationOrderByWithRelationInput | KnowledgeIntegrationOrderByWithRelationInput[]
    cursor?: KnowledgeIntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeIntegrationScalarFieldEnum | KnowledgeIntegrationScalarFieldEnum[]
  }

  /**
   * User.projectCollaborations
   */
  export type User$projectCollaborationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    where?: ProjectCollaboratorWhereInput
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    cursor?: ProjectCollaboratorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectCollaboratorScalarFieldEnum | ProjectCollaboratorScalarFieldEnum[]
  }

  /**
   * User.assignedMethodologySteps
   */
  export type User$assignedMethodologyStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMethodologyStep
     */
    select?: ProjectMethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMethodologyStepInclude<ExtArgs> | null
    where?: ProjectMethodologyStepWhereInput
    orderBy?: ProjectMethodologyStepOrderByWithRelationInput | ProjectMethodologyStepOrderByWithRelationInput[]
    cursor?: ProjectMethodologyStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMethodologyStepScalarFieldEnum | ProjectMethodologyStepScalarFieldEnum[]
  }

  /**
   * User.analyses
   */
  export type User$analysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchAnalysis
     */
    select?: ResearchAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchAnalysisInclude<ExtArgs> | null
    where?: ResearchAnalysisWhereInput
    orderBy?: ResearchAnalysisOrderByWithRelationInput | ResearchAnalysisOrderByWithRelationInput[]
    cursor?: ResearchAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchAnalysisScalarFieldEnum | ResearchAnalysisScalarFieldEnum[]
  }

  /**
   * User.approvedAnalyses
   */
  export type User$approvedAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchAnalysis
     */
    select?: ResearchAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchAnalysisInclude<ExtArgs> | null
    where?: ResearchAnalysisWhereInput
    orderBy?: ResearchAnalysisOrderByWithRelationInput | ResearchAnalysisOrderByWithRelationInput[]
    cursor?: ResearchAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchAnalysisScalarFieldEnum | ResearchAnalysisScalarFieldEnum[]
  }

  /**
   * User.reviewedAnalyses
   */
  export type User$reviewedAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchAnalysis
     */
    select?: ResearchAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchAnalysisInclude<ExtArgs> | null
    where?: ResearchAnalysisWhereInput
    orderBy?: ResearchAnalysisOrderByWithRelationInput | ResearchAnalysisOrderByWithRelationInput[]
    cursor?: ResearchAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchAnalysisScalarFieldEnum | ResearchAnalysisScalarFieldEnum[]
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProject
     */
    select?: ResearchProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectInclude<ExtArgs> | null
    where?: ResearchProjectWhereInput
    orderBy?: ResearchProjectOrderByWithRelationInput | ResearchProjectOrderByWithRelationInput[]
    cursor?: ResearchProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchProjectScalarFieldEnum | ResearchProjectScalarFieldEnum[]
  }

  /**
   * User.uploadedImages
   */
  export type User$uploadedImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedImage
     */
    select?: UploadedImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedImageInclude<ExtArgs> | null
    where?: UploadedImageWhereInput
    orderBy?: UploadedImageOrderByWithRelationInput | UploadedImageOrderByWithRelationInput[]
    cursor?: UploadedImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UploadedImageScalarFieldEnum | UploadedImageScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model AcademicDiscipline
   */

  export type AggregateAcademicDiscipline = {
    _count: AcademicDisciplineCountAggregateOutputType | null
    _avg: AcademicDisciplineAvgAggregateOutputType | null
    _sum: AcademicDisciplineSumAggregateOutputType | null
    _min: AcademicDisciplineMinAggregateOutputType | null
    _max: AcademicDisciplineMaxAggregateOutputType | null
  }

  export type AcademicDisciplineAvgAggregateOutputType = {
    level: number | null
  }

  export type AcademicDisciplineSumAggregateOutputType = {
    level: number | null
  }

  export type AcademicDisciplineMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    parentDisciplineId: string | null
    level: number | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AcademicDisciplineMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    parentDisciplineId: string | null
    level: number | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AcademicDisciplineCountAggregateOutputType = {
    id: number
    code: number
    name: number
    parentDisciplineId: number
    level: number
    description: number
    keywords: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type AcademicDisciplineAvgAggregateInputType = {
    level?: true
  }

  export type AcademicDisciplineSumAggregateInputType = {
    level?: true
  }

  export type AcademicDisciplineMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    parentDisciplineId?: true
    level?: true
    description?: true
    isActive?: true
    createdAt?: true
  }

  export type AcademicDisciplineMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    parentDisciplineId?: true
    level?: true
    description?: true
    isActive?: true
    createdAt?: true
  }

  export type AcademicDisciplineCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    parentDisciplineId?: true
    level?: true
    description?: true
    keywords?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type AcademicDisciplineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicDiscipline to aggregate.
     */
    where?: AcademicDisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicDisciplines to fetch.
     */
    orderBy?: AcademicDisciplineOrderByWithRelationInput | AcademicDisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicDisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicDisciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicDisciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicDisciplines
    **/
    _count?: true | AcademicDisciplineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AcademicDisciplineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AcademicDisciplineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicDisciplineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicDisciplineMaxAggregateInputType
  }

  export type GetAcademicDisciplineAggregateType<T extends AcademicDisciplineAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicDiscipline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicDiscipline[P]>
      : GetScalarType<T[P], AggregateAcademicDiscipline[P]>
  }




  export type AcademicDisciplineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicDisciplineWhereInput
    orderBy?: AcademicDisciplineOrderByWithAggregationInput | AcademicDisciplineOrderByWithAggregationInput[]
    by: AcademicDisciplineScalarFieldEnum[] | AcademicDisciplineScalarFieldEnum
    having?: AcademicDisciplineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicDisciplineCountAggregateInputType | true
    _avg?: AcademicDisciplineAvgAggregateInputType
    _sum?: AcademicDisciplineSumAggregateInputType
    _min?: AcademicDisciplineMinAggregateInputType
    _max?: AcademicDisciplineMaxAggregateInputType
  }

  export type AcademicDisciplineGroupByOutputType = {
    id: string
    code: string
    name: string
    parentDisciplineId: string | null
    level: number
    description: string | null
    keywords: string[]
    isActive: boolean
    createdAt: Date
    _count: AcademicDisciplineCountAggregateOutputType | null
    _avg: AcademicDisciplineAvgAggregateOutputType | null
    _sum: AcademicDisciplineSumAggregateOutputType | null
    _min: AcademicDisciplineMinAggregateOutputType | null
    _max: AcademicDisciplineMaxAggregateOutputType | null
  }

  type GetAcademicDisciplineGroupByPayload<T extends AcademicDisciplineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicDisciplineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicDisciplineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicDisciplineGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicDisciplineGroupByOutputType[P]>
        }
      >
    >


  export type AcademicDisciplineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    parentDisciplineId?: boolean
    level?: boolean
    description?: boolean
    keywords?: boolean
    isActive?: boolean
    createdAt?: boolean
    parentDiscipline?: boolean | AcademicDiscipline$parentDisciplineArgs<ExtArgs>
    childDisciplines?: boolean | AcademicDiscipline$childDisciplinesArgs<ExtArgs>
    knowledgeIntegrationsSource?: boolean | AcademicDiscipline$knowledgeIntegrationsSourceArgs<ExtArgs>
    knowledgeIntegrationsTarget?: boolean | AcademicDiscipline$knowledgeIntegrationsTargetArgs<ExtArgs>
    projectDisciplines?: boolean | AcademicDiscipline$projectDisciplinesArgs<ExtArgs>
    _count?: boolean | AcademicDisciplineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicDiscipline"]>

  export type AcademicDisciplineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    parentDisciplineId?: boolean
    level?: boolean
    description?: boolean
    keywords?: boolean
    isActive?: boolean
    createdAt?: boolean
    parentDiscipline?: boolean | AcademicDiscipline$parentDisciplineArgs<ExtArgs>
  }, ExtArgs["result"]["academicDiscipline"]>

  export type AcademicDisciplineSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    parentDisciplineId?: boolean
    level?: boolean
    description?: boolean
    keywords?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type AcademicDisciplineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentDiscipline?: boolean | AcademicDiscipline$parentDisciplineArgs<ExtArgs>
    childDisciplines?: boolean | AcademicDiscipline$childDisciplinesArgs<ExtArgs>
    knowledgeIntegrationsSource?: boolean | AcademicDiscipline$knowledgeIntegrationsSourceArgs<ExtArgs>
    knowledgeIntegrationsTarget?: boolean | AcademicDiscipline$knowledgeIntegrationsTargetArgs<ExtArgs>
    projectDisciplines?: boolean | AcademicDiscipline$projectDisciplinesArgs<ExtArgs>
    _count?: boolean | AcademicDisciplineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AcademicDisciplineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentDiscipline?: boolean | AcademicDiscipline$parentDisciplineArgs<ExtArgs>
  }

  export type $AcademicDisciplinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicDiscipline"
    objects: {
      parentDiscipline: Prisma.$AcademicDisciplinePayload<ExtArgs> | null
      childDisciplines: Prisma.$AcademicDisciplinePayload<ExtArgs>[]
      knowledgeIntegrationsSource: Prisma.$KnowledgeIntegrationPayload<ExtArgs>[]
      knowledgeIntegrationsTarget: Prisma.$KnowledgeIntegrationPayload<ExtArgs>[]
      projectDisciplines: Prisma.$ProjectDisciplinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      parentDisciplineId: string | null
      level: number
      description: string | null
      keywords: string[]
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["academicDiscipline"]>
    composites: {}
  }

  type AcademicDisciplineGetPayload<S extends boolean | null | undefined | AcademicDisciplineDefaultArgs> = $Result.GetResult<Prisma.$AcademicDisciplinePayload, S>

  type AcademicDisciplineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AcademicDisciplineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AcademicDisciplineCountAggregateInputType | true
    }

  export interface AcademicDisciplineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicDiscipline'], meta: { name: 'AcademicDiscipline' } }
    /**
     * Find zero or one AcademicDiscipline that matches the filter.
     * @param {AcademicDisciplineFindUniqueArgs} args - Arguments to find a AcademicDiscipline
     * @example
     * // Get one AcademicDiscipline
     * const academicDiscipline = await prisma.academicDiscipline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicDisciplineFindUniqueArgs>(args: SelectSubset<T, AcademicDisciplineFindUniqueArgs<ExtArgs>>): Prisma__AcademicDisciplineClient<$Result.GetResult<Prisma.$AcademicDisciplinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AcademicDiscipline that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AcademicDisciplineFindUniqueOrThrowArgs} args - Arguments to find a AcademicDiscipline
     * @example
     * // Get one AcademicDiscipline
     * const academicDiscipline = await prisma.academicDiscipline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicDisciplineFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicDisciplineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicDisciplineClient<$Result.GetResult<Prisma.$AcademicDisciplinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AcademicDiscipline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDisciplineFindFirstArgs} args - Arguments to find a AcademicDiscipline
     * @example
     * // Get one AcademicDiscipline
     * const academicDiscipline = await prisma.academicDiscipline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicDisciplineFindFirstArgs>(args?: SelectSubset<T, AcademicDisciplineFindFirstArgs<ExtArgs>>): Prisma__AcademicDisciplineClient<$Result.GetResult<Prisma.$AcademicDisciplinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AcademicDiscipline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDisciplineFindFirstOrThrowArgs} args - Arguments to find a AcademicDiscipline
     * @example
     * // Get one AcademicDiscipline
     * const academicDiscipline = await prisma.academicDiscipline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicDisciplineFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicDisciplineFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicDisciplineClient<$Result.GetResult<Prisma.$AcademicDisciplinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AcademicDisciplines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDisciplineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicDisciplines
     * const academicDisciplines = await prisma.academicDiscipline.findMany()
     * 
     * // Get first 10 AcademicDisciplines
     * const academicDisciplines = await prisma.academicDiscipline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicDisciplineWithIdOnly = await prisma.academicDiscipline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicDisciplineFindManyArgs>(args?: SelectSubset<T, AcademicDisciplineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicDisciplinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AcademicDiscipline.
     * @param {AcademicDisciplineCreateArgs} args - Arguments to create a AcademicDiscipline.
     * @example
     * // Create one AcademicDiscipline
     * const AcademicDiscipline = await prisma.academicDiscipline.create({
     *   data: {
     *     // ... data to create a AcademicDiscipline
     *   }
     * })
     * 
     */
    create<T extends AcademicDisciplineCreateArgs>(args: SelectSubset<T, AcademicDisciplineCreateArgs<ExtArgs>>): Prisma__AcademicDisciplineClient<$Result.GetResult<Prisma.$AcademicDisciplinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AcademicDisciplines.
     * @param {AcademicDisciplineCreateManyArgs} args - Arguments to create many AcademicDisciplines.
     * @example
     * // Create many AcademicDisciplines
     * const academicDiscipline = await prisma.academicDiscipline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicDisciplineCreateManyArgs>(args?: SelectSubset<T, AcademicDisciplineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicDisciplines and returns the data saved in the database.
     * @param {AcademicDisciplineCreateManyAndReturnArgs} args - Arguments to create many AcademicDisciplines.
     * @example
     * // Create many AcademicDisciplines
     * const academicDiscipline = await prisma.academicDiscipline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicDisciplines and only return the `id`
     * const academicDisciplineWithIdOnly = await prisma.academicDiscipline.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicDisciplineCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicDisciplineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicDisciplinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AcademicDiscipline.
     * @param {AcademicDisciplineDeleteArgs} args - Arguments to delete one AcademicDiscipline.
     * @example
     * // Delete one AcademicDiscipline
     * const AcademicDiscipline = await prisma.academicDiscipline.delete({
     *   where: {
     *     // ... filter to delete one AcademicDiscipline
     *   }
     * })
     * 
     */
    delete<T extends AcademicDisciplineDeleteArgs>(args: SelectSubset<T, AcademicDisciplineDeleteArgs<ExtArgs>>): Prisma__AcademicDisciplineClient<$Result.GetResult<Prisma.$AcademicDisciplinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AcademicDiscipline.
     * @param {AcademicDisciplineUpdateArgs} args - Arguments to update one AcademicDiscipline.
     * @example
     * // Update one AcademicDiscipline
     * const academicDiscipline = await prisma.academicDiscipline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicDisciplineUpdateArgs>(args: SelectSubset<T, AcademicDisciplineUpdateArgs<ExtArgs>>): Prisma__AcademicDisciplineClient<$Result.GetResult<Prisma.$AcademicDisciplinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AcademicDisciplines.
     * @param {AcademicDisciplineDeleteManyArgs} args - Arguments to filter AcademicDisciplines to delete.
     * @example
     * // Delete a few AcademicDisciplines
     * const { count } = await prisma.academicDiscipline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicDisciplineDeleteManyArgs>(args?: SelectSubset<T, AcademicDisciplineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicDisciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDisciplineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicDisciplines
     * const academicDiscipline = await prisma.academicDiscipline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicDisciplineUpdateManyArgs>(args: SelectSubset<T, AcademicDisciplineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicDiscipline.
     * @param {AcademicDisciplineUpsertArgs} args - Arguments to update or create a AcademicDiscipline.
     * @example
     * // Update or create a AcademicDiscipline
     * const academicDiscipline = await prisma.academicDiscipline.upsert({
     *   create: {
     *     // ... data to create a AcademicDiscipline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicDiscipline we want to update
     *   }
     * })
     */
    upsert<T extends AcademicDisciplineUpsertArgs>(args: SelectSubset<T, AcademicDisciplineUpsertArgs<ExtArgs>>): Prisma__AcademicDisciplineClient<$Result.GetResult<Prisma.$AcademicDisciplinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AcademicDisciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDisciplineCountArgs} args - Arguments to filter AcademicDisciplines to count.
     * @example
     * // Count the number of AcademicDisciplines
     * const count = await prisma.academicDiscipline.count({
     *   where: {
     *     // ... the filter for the AcademicDisciplines we want to count
     *   }
     * })
    **/
    count<T extends AcademicDisciplineCountArgs>(
      args?: Subset<T, AcademicDisciplineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicDisciplineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicDiscipline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDisciplineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicDisciplineAggregateArgs>(args: Subset<T, AcademicDisciplineAggregateArgs>): Prisma.PrismaPromise<GetAcademicDisciplineAggregateType<T>>

    /**
     * Group by AcademicDiscipline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDisciplineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicDisciplineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicDisciplineGroupByArgs['orderBy'] }
        : { orderBy?: AcademicDisciplineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicDisciplineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicDisciplineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicDiscipline model
   */
  readonly fields: AcademicDisciplineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicDiscipline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicDisciplineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parentDiscipline<T extends AcademicDiscipline$parentDisciplineArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDiscipline$parentDisciplineArgs<ExtArgs>>): Prisma__AcademicDisciplineClient<$Result.GetResult<Prisma.$AcademicDisciplinePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    childDisciplines<T extends AcademicDiscipline$childDisciplinesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDiscipline$childDisciplinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicDisciplinePayload<ExtArgs>, T, "findMany"> | Null>
    knowledgeIntegrationsSource<T extends AcademicDiscipline$knowledgeIntegrationsSourceArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDiscipline$knowledgeIntegrationsSourceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeIntegrationPayload<ExtArgs>, T, "findMany"> | Null>
    knowledgeIntegrationsTarget<T extends AcademicDiscipline$knowledgeIntegrationsTargetArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDiscipline$knowledgeIntegrationsTargetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeIntegrationPayload<ExtArgs>, T, "findMany"> | Null>
    projectDisciplines<T extends AcademicDiscipline$projectDisciplinesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDiscipline$projectDisciplinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDisciplinePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicDiscipline model
   */ 
  interface AcademicDisciplineFieldRefs {
    readonly id: FieldRef<"AcademicDiscipline", 'String'>
    readonly code: FieldRef<"AcademicDiscipline", 'String'>
    readonly name: FieldRef<"AcademicDiscipline", 'String'>
    readonly parentDisciplineId: FieldRef<"AcademicDiscipline", 'String'>
    readonly level: FieldRef<"AcademicDiscipline", 'Int'>
    readonly description: FieldRef<"AcademicDiscipline", 'String'>
    readonly keywords: FieldRef<"AcademicDiscipline", 'String[]'>
    readonly isActive: FieldRef<"AcademicDiscipline", 'Boolean'>
    readonly createdAt: FieldRef<"AcademicDiscipline", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicDiscipline findUnique
   */
  export type AcademicDisciplineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDiscipline
     */
    select?: AcademicDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDiscipline to fetch.
     */
    where: AcademicDisciplineWhereUniqueInput
  }

  /**
   * AcademicDiscipline findUniqueOrThrow
   */
  export type AcademicDisciplineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDiscipline
     */
    select?: AcademicDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDiscipline to fetch.
     */
    where: AcademicDisciplineWhereUniqueInput
  }

  /**
   * AcademicDiscipline findFirst
   */
  export type AcademicDisciplineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDiscipline
     */
    select?: AcademicDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDiscipline to fetch.
     */
    where?: AcademicDisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicDisciplines to fetch.
     */
    orderBy?: AcademicDisciplineOrderByWithRelationInput | AcademicDisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicDisciplines.
     */
    cursor?: AcademicDisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicDisciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicDisciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicDisciplines.
     */
    distinct?: AcademicDisciplineScalarFieldEnum | AcademicDisciplineScalarFieldEnum[]
  }

  /**
   * AcademicDiscipline findFirstOrThrow
   */
  export type AcademicDisciplineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDiscipline
     */
    select?: AcademicDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDiscipline to fetch.
     */
    where?: AcademicDisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicDisciplines to fetch.
     */
    orderBy?: AcademicDisciplineOrderByWithRelationInput | AcademicDisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicDisciplines.
     */
    cursor?: AcademicDisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicDisciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicDisciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicDisciplines.
     */
    distinct?: AcademicDisciplineScalarFieldEnum | AcademicDisciplineScalarFieldEnum[]
  }

  /**
   * AcademicDiscipline findMany
   */
  export type AcademicDisciplineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDiscipline
     */
    select?: AcademicDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDisciplines to fetch.
     */
    where?: AcademicDisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicDisciplines to fetch.
     */
    orderBy?: AcademicDisciplineOrderByWithRelationInput | AcademicDisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicDisciplines.
     */
    cursor?: AcademicDisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicDisciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicDisciplines.
     */
    skip?: number
    distinct?: AcademicDisciplineScalarFieldEnum | AcademicDisciplineScalarFieldEnum[]
  }

  /**
   * AcademicDiscipline create
   */
  export type AcademicDisciplineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDiscipline
     */
    select?: AcademicDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDisciplineInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicDiscipline.
     */
    data: XOR<AcademicDisciplineCreateInput, AcademicDisciplineUncheckedCreateInput>
  }

  /**
   * AcademicDiscipline createMany
   */
  export type AcademicDisciplineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicDisciplines.
     */
    data: AcademicDisciplineCreateManyInput | AcademicDisciplineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicDiscipline createManyAndReturn
   */
  export type AcademicDisciplineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDiscipline
     */
    select?: AcademicDisciplineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AcademicDisciplines.
     */
    data: AcademicDisciplineCreateManyInput | AcademicDisciplineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDisciplineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicDiscipline update
   */
  export type AcademicDisciplineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDiscipline
     */
    select?: AcademicDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDisciplineInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicDiscipline.
     */
    data: XOR<AcademicDisciplineUpdateInput, AcademicDisciplineUncheckedUpdateInput>
    /**
     * Choose, which AcademicDiscipline to update.
     */
    where: AcademicDisciplineWhereUniqueInput
  }

  /**
   * AcademicDiscipline updateMany
   */
  export type AcademicDisciplineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicDisciplines.
     */
    data: XOR<AcademicDisciplineUpdateManyMutationInput, AcademicDisciplineUncheckedUpdateManyInput>
    /**
     * Filter which AcademicDisciplines to update
     */
    where?: AcademicDisciplineWhereInput
  }

  /**
   * AcademicDiscipline upsert
   */
  export type AcademicDisciplineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDiscipline
     */
    select?: AcademicDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDisciplineInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicDiscipline to update in case it exists.
     */
    where: AcademicDisciplineWhereUniqueInput
    /**
     * In case the AcademicDiscipline found by the `where` argument doesn't exist, create a new AcademicDiscipline with this data.
     */
    create: XOR<AcademicDisciplineCreateInput, AcademicDisciplineUncheckedCreateInput>
    /**
     * In case the AcademicDiscipline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicDisciplineUpdateInput, AcademicDisciplineUncheckedUpdateInput>
  }

  /**
   * AcademicDiscipline delete
   */
  export type AcademicDisciplineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDiscipline
     */
    select?: AcademicDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDisciplineInclude<ExtArgs> | null
    /**
     * Filter which AcademicDiscipline to delete.
     */
    where: AcademicDisciplineWhereUniqueInput
  }

  /**
   * AcademicDiscipline deleteMany
   */
  export type AcademicDisciplineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicDisciplines to delete
     */
    where?: AcademicDisciplineWhereInput
  }

  /**
   * AcademicDiscipline.parentDiscipline
   */
  export type AcademicDiscipline$parentDisciplineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDiscipline
     */
    select?: AcademicDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDisciplineInclude<ExtArgs> | null
    where?: AcademicDisciplineWhereInput
  }

  /**
   * AcademicDiscipline.childDisciplines
   */
  export type AcademicDiscipline$childDisciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDiscipline
     */
    select?: AcademicDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDisciplineInclude<ExtArgs> | null
    where?: AcademicDisciplineWhereInput
    orderBy?: AcademicDisciplineOrderByWithRelationInput | AcademicDisciplineOrderByWithRelationInput[]
    cursor?: AcademicDisciplineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicDisciplineScalarFieldEnum | AcademicDisciplineScalarFieldEnum[]
  }

  /**
   * AcademicDiscipline.knowledgeIntegrationsSource
   */
  export type AcademicDiscipline$knowledgeIntegrationsSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeIntegration
     */
    select?: KnowledgeIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeIntegrationInclude<ExtArgs> | null
    where?: KnowledgeIntegrationWhereInput
    orderBy?: KnowledgeIntegrationOrderByWithRelationInput | KnowledgeIntegrationOrderByWithRelationInput[]
    cursor?: KnowledgeIntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeIntegrationScalarFieldEnum | KnowledgeIntegrationScalarFieldEnum[]
  }

  /**
   * AcademicDiscipline.knowledgeIntegrationsTarget
   */
  export type AcademicDiscipline$knowledgeIntegrationsTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeIntegration
     */
    select?: KnowledgeIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeIntegrationInclude<ExtArgs> | null
    where?: KnowledgeIntegrationWhereInput
    orderBy?: KnowledgeIntegrationOrderByWithRelationInput | KnowledgeIntegrationOrderByWithRelationInput[]
    cursor?: KnowledgeIntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeIntegrationScalarFieldEnum | KnowledgeIntegrationScalarFieldEnum[]
  }

  /**
   * AcademicDiscipline.projectDisciplines
   */
  export type AcademicDiscipline$projectDisciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDiscipline
     */
    select?: ProjectDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDisciplineInclude<ExtArgs> | null
    where?: ProjectDisciplineWhereInput
    orderBy?: ProjectDisciplineOrderByWithRelationInput | ProjectDisciplineOrderByWithRelationInput[]
    cursor?: ProjectDisciplineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectDisciplineScalarFieldEnum | ProjectDisciplineScalarFieldEnum[]
  }

  /**
   * AcademicDiscipline without action
   */
  export type AcademicDisciplineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDiscipline
     */
    select?: AcademicDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDisciplineInclude<ExtArgs> | null
  }


  /**
   * Model OnetOccupation
   */

  export type AggregateOnetOccupation = {
    _count: OnetOccupationCountAggregateOutputType | null
    _min: OnetOccupationMinAggregateOutputType | null
    _max: OnetOccupationMaxAggregateOutputType | null
  }

  export type OnetOccupationMinAggregateOutputType = {
    id: string | null
    onetCode: string | null
    title: string | null
    description: string | null
    category: string | null
    subdomain: string | null
    educationLevel: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type OnetOccupationMaxAggregateOutputType = {
    id: string | null
    onetCode: string | null
    title: string | null
    description: string | null
    category: string | null
    subdomain: string | null
    educationLevel: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type OnetOccupationCountAggregateOutputType = {
    id: number
    onetCode: number
    title: number
    description: number
    category: number
    subdomain: number
    tasks: number
    skills: number
    knowledgeAreas: number
    abilities: number
    educationLevel: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type OnetOccupationMinAggregateInputType = {
    id?: true
    onetCode?: true
    title?: true
    description?: true
    category?: true
    subdomain?: true
    educationLevel?: true
    isActive?: true
    createdAt?: true
  }

  export type OnetOccupationMaxAggregateInputType = {
    id?: true
    onetCode?: true
    title?: true
    description?: true
    category?: true
    subdomain?: true
    educationLevel?: true
    isActive?: true
    createdAt?: true
  }

  export type OnetOccupationCountAggregateInputType = {
    id?: true
    onetCode?: true
    title?: true
    description?: true
    category?: true
    subdomain?: true
    tasks?: true
    skills?: true
    knowledgeAreas?: true
    abilities?: true
    educationLevel?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type OnetOccupationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnetOccupation to aggregate.
     */
    where?: OnetOccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnetOccupations to fetch.
     */
    orderBy?: OnetOccupationOrderByWithRelationInput | OnetOccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OnetOccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnetOccupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnetOccupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OnetOccupations
    **/
    _count?: true | OnetOccupationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OnetOccupationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OnetOccupationMaxAggregateInputType
  }

  export type GetOnetOccupationAggregateType<T extends OnetOccupationAggregateArgs> = {
        [P in keyof T & keyof AggregateOnetOccupation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOnetOccupation[P]>
      : GetScalarType<T[P], AggregateOnetOccupation[P]>
  }




  export type OnetOccupationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnetOccupationWhereInput
    orderBy?: OnetOccupationOrderByWithAggregationInput | OnetOccupationOrderByWithAggregationInput[]
    by: OnetOccupationScalarFieldEnum[] | OnetOccupationScalarFieldEnum
    having?: OnetOccupationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OnetOccupationCountAggregateInputType | true
    _min?: OnetOccupationMinAggregateInputType
    _max?: OnetOccupationMaxAggregateInputType
  }

  export type OnetOccupationGroupByOutputType = {
    id: string
    onetCode: string
    title: string
    description: string | null
    category: string | null
    subdomain: string | null
    tasks: string[]
    skills: string[]
    knowledgeAreas: string[]
    abilities: string[]
    educationLevel: string | null
    isActive: boolean
    createdAt: Date
    _count: OnetOccupationCountAggregateOutputType | null
    _min: OnetOccupationMinAggregateOutputType | null
    _max: OnetOccupationMaxAggregateOutputType | null
  }

  type GetOnetOccupationGroupByPayload<T extends OnetOccupationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OnetOccupationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OnetOccupationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OnetOccupationGroupByOutputType[P]>
            : GetScalarType<T[P], OnetOccupationGroupByOutputType[P]>
        }
      >
    >


  export type OnetOccupationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    onetCode?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    subdomain?: boolean
    tasks?: boolean
    skills?: boolean
    knowledgeAreas?: boolean
    abilities?: boolean
    educationLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
    projectOccupations?: boolean | OnetOccupation$projectOccupationsArgs<ExtArgs>
    _count?: boolean | OnetOccupationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onetOccupation"]>

  export type OnetOccupationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    onetCode?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    subdomain?: boolean
    tasks?: boolean
    skills?: boolean
    knowledgeAreas?: boolean
    abilities?: boolean
    educationLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["onetOccupation"]>

  export type OnetOccupationSelectScalar = {
    id?: boolean
    onetCode?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    subdomain?: boolean
    tasks?: boolean
    skills?: boolean
    knowledgeAreas?: boolean
    abilities?: boolean
    educationLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type OnetOccupationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectOccupations?: boolean | OnetOccupation$projectOccupationsArgs<ExtArgs>
    _count?: boolean | OnetOccupationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OnetOccupationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OnetOccupationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OnetOccupation"
    objects: {
      projectOccupations: Prisma.$ProjectOccupationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      onetCode: string
      title: string
      description: string | null
      category: string | null
      subdomain: string | null
      tasks: string[]
      skills: string[]
      knowledgeAreas: string[]
      abilities: string[]
      educationLevel: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["onetOccupation"]>
    composites: {}
  }

  type OnetOccupationGetPayload<S extends boolean | null | undefined | OnetOccupationDefaultArgs> = $Result.GetResult<Prisma.$OnetOccupationPayload, S>

  type OnetOccupationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OnetOccupationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OnetOccupationCountAggregateInputType | true
    }

  export interface OnetOccupationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OnetOccupation'], meta: { name: 'OnetOccupation' } }
    /**
     * Find zero or one OnetOccupation that matches the filter.
     * @param {OnetOccupationFindUniqueArgs} args - Arguments to find a OnetOccupation
     * @example
     * // Get one OnetOccupation
     * const onetOccupation = await prisma.onetOccupation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OnetOccupationFindUniqueArgs>(args: SelectSubset<T, OnetOccupationFindUniqueArgs<ExtArgs>>): Prisma__OnetOccupationClient<$Result.GetResult<Prisma.$OnetOccupationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OnetOccupation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OnetOccupationFindUniqueOrThrowArgs} args - Arguments to find a OnetOccupation
     * @example
     * // Get one OnetOccupation
     * const onetOccupation = await prisma.onetOccupation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OnetOccupationFindUniqueOrThrowArgs>(args: SelectSubset<T, OnetOccupationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OnetOccupationClient<$Result.GetResult<Prisma.$OnetOccupationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OnetOccupation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnetOccupationFindFirstArgs} args - Arguments to find a OnetOccupation
     * @example
     * // Get one OnetOccupation
     * const onetOccupation = await prisma.onetOccupation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OnetOccupationFindFirstArgs>(args?: SelectSubset<T, OnetOccupationFindFirstArgs<ExtArgs>>): Prisma__OnetOccupationClient<$Result.GetResult<Prisma.$OnetOccupationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OnetOccupation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnetOccupationFindFirstOrThrowArgs} args - Arguments to find a OnetOccupation
     * @example
     * // Get one OnetOccupation
     * const onetOccupation = await prisma.onetOccupation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OnetOccupationFindFirstOrThrowArgs>(args?: SelectSubset<T, OnetOccupationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OnetOccupationClient<$Result.GetResult<Prisma.$OnetOccupationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OnetOccupations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnetOccupationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OnetOccupations
     * const onetOccupations = await prisma.onetOccupation.findMany()
     * 
     * // Get first 10 OnetOccupations
     * const onetOccupations = await prisma.onetOccupation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const onetOccupationWithIdOnly = await prisma.onetOccupation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OnetOccupationFindManyArgs>(args?: SelectSubset<T, OnetOccupationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnetOccupationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OnetOccupation.
     * @param {OnetOccupationCreateArgs} args - Arguments to create a OnetOccupation.
     * @example
     * // Create one OnetOccupation
     * const OnetOccupation = await prisma.onetOccupation.create({
     *   data: {
     *     // ... data to create a OnetOccupation
     *   }
     * })
     * 
     */
    create<T extends OnetOccupationCreateArgs>(args: SelectSubset<T, OnetOccupationCreateArgs<ExtArgs>>): Prisma__OnetOccupationClient<$Result.GetResult<Prisma.$OnetOccupationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OnetOccupations.
     * @param {OnetOccupationCreateManyArgs} args - Arguments to create many OnetOccupations.
     * @example
     * // Create many OnetOccupations
     * const onetOccupation = await prisma.onetOccupation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OnetOccupationCreateManyArgs>(args?: SelectSubset<T, OnetOccupationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OnetOccupations and returns the data saved in the database.
     * @param {OnetOccupationCreateManyAndReturnArgs} args - Arguments to create many OnetOccupations.
     * @example
     * // Create many OnetOccupations
     * const onetOccupation = await prisma.onetOccupation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OnetOccupations and only return the `id`
     * const onetOccupationWithIdOnly = await prisma.onetOccupation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OnetOccupationCreateManyAndReturnArgs>(args?: SelectSubset<T, OnetOccupationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnetOccupationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OnetOccupation.
     * @param {OnetOccupationDeleteArgs} args - Arguments to delete one OnetOccupation.
     * @example
     * // Delete one OnetOccupation
     * const OnetOccupation = await prisma.onetOccupation.delete({
     *   where: {
     *     // ... filter to delete one OnetOccupation
     *   }
     * })
     * 
     */
    delete<T extends OnetOccupationDeleteArgs>(args: SelectSubset<T, OnetOccupationDeleteArgs<ExtArgs>>): Prisma__OnetOccupationClient<$Result.GetResult<Prisma.$OnetOccupationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OnetOccupation.
     * @param {OnetOccupationUpdateArgs} args - Arguments to update one OnetOccupation.
     * @example
     * // Update one OnetOccupation
     * const onetOccupation = await prisma.onetOccupation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OnetOccupationUpdateArgs>(args: SelectSubset<T, OnetOccupationUpdateArgs<ExtArgs>>): Prisma__OnetOccupationClient<$Result.GetResult<Prisma.$OnetOccupationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OnetOccupations.
     * @param {OnetOccupationDeleteManyArgs} args - Arguments to filter OnetOccupations to delete.
     * @example
     * // Delete a few OnetOccupations
     * const { count } = await prisma.onetOccupation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OnetOccupationDeleteManyArgs>(args?: SelectSubset<T, OnetOccupationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnetOccupations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnetOccupationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OnetOccupations
     * const onetOccupation = await prisma.onetOccupation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OnetOccupationUpdateManyArgs>(args: SelectSubset<T, OnetOccupationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OnetOccupation.
     * @param {OnetOccupationUpsertArgs} args - Arguments to update or create a OnetOccupation.
     * @example
     * // Update or create a OnetOccupation
     * const onetOccupation = await prisma.onetOccupation.upsert({
     *   create: {
     *     // ... data to create a OnetOccupation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OnetOccupation we want to update
     *   }
     * })
     */
    upsert<T extends OnetOccupationUpsertArgs>(args: SelectSubset<T, OnetOccupationUpsertArgs<ExtArgs>>): Prisma__OnetOccupationClient<$Result.GetResult<Prisma.$OnetOccupationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OnetOccupations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnetOccupationCountArgs} args - Arguments to filter OnetOccupations to count.
     * @example
     * // Count the number of OnetOccupations
     * const count = await prisma.onetOccupation.count({
     *   where: {
     *     // ... the filter for the OnetOccupations we want to count
     *   }
     * })
    **/
    count<T extends OnetOccupationCountArgs>(
      args?: Subset<T, OnetOccupationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OnetOccupationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OnetOccupation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnetOccupationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OnetOccupationAggregateArgs>(args: Subset<T, OnetOccupationAggregateArgs>): Prisma.PrismaPromise<GetOnetOccupationAggregateType<T>>

    /**
     * Group by OnetOccupation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnetOccupationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OnetOccupationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OnetOccupationGroupByArgs['orderBy'] }
        : { orderBy?: OnetOccupationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OnetOccupationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOnetOccupationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OnetOccupation model
   */
  readonly fields: OnetOccupationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OnetOccupation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OnetOccupationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projectOccupations<T extends OnetOccupation$projectOccupationsArgs<ExtArgs> = {}>(args?: Subset<T, OnetOccupation$projectOccupationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectOccupationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OnetOccupation model
   */ 
  interface OnetOccupationFieldRefs {
    readonly id: FieldRef<"OnetOccupation", 'String'>
    readonly onetCode: FieldRef<"OnetOccupation", 'String'>
    readonly title: FieldRef<"OnetOccupation", 'String'>
    readonly description: FieldRef<"OnetOccupation", 'String'>
    readonly category: FieldRef<"OnetOccupation", 'String'>
    readonly subdomain: FieldRef<"OnetOccupation", 'String'>
    readonly tasks: FieldRef<"OnetOccupation", 'String[]'>
    readonly skills: FieldRef<"OnetOccupation", 'String[]'>
    readonly knowledgeAreas: FieldRef<"OnetOccupation", 'String[]'>
    readonly abilities: FieldRef<"OnetOccupation", 'String[]'>
    readonly educationLevel: FieldRef<"OnetOccupation", 'String'>
    readonly isActive: FieldRef<"OnetOccupation", 'Boolean'>
    readonly createdAt: FieldRef<"OnetOccupation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OnetOccupation findUnique
   */
  export type OnetOccupationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnetOccupation
     */
    select?: OnetOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnetOccupationInclude<ExtArgs> | null
    /**
     * Filter, which OnetOccupation to fetch.
     */
    where: OnetOccupationWhereUniqueInput
  }

  /**
   * OnetOccupation findUniqueOrThrow
   */
  export type OnetOccupationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnetOccupation
     */
    select?: OnetOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnetOccupationInclude<ExtArgs> | null
    /**
     * Filter, which OnetOccupation to fetch.
     */
    where: OnetOccupationWhereUniqueInput
  }

  /**
   * OnetOccupation findFirst
   */
  export type OnetOccupationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnetOccupation
     */
    select?: OnetOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnetOccupationInclude<ExtArgs> | null
    /**
     * Filter, which OnetOccupation to fetch.
     */
    where?: OnetOccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnetOccupations to fetch.
     */
    orderBy?: OnetOccupationOrderByWithRelationInput | OnetOccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnetOccupations.
     */
    cursor?: OnetOccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnetOccupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnetOccupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnetOccupations.
     */
    distinct?: OnetOccupationScalarFieldEnum | OnetOccupationScalarFieldEnum[]
  }

  /**
   * OnetOccupation findFirstOrThrow
   */
  export type OnetOccupationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnetOccupation
     */
    select?: OnetOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnetOccupationInclude<ExtArgs> | null
    /**
     * Filter, which OnetOccupation to fetch.
     */
    where?: OnetOccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnetOccupations to fetch.
     */
    orderBy?: OnetOccupationOrderByWithRelationInput | OnetOccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnetOccupations.
     */
    cursor?: OnetOccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnetOccupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnetOccupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnetOccupations.
     */
    distinct?: OnetOccupationScalarFieldEnum | OnetOccupationScalarFieldEnum[]
  }

  /**
   * OnetOccupation findMany
   */
  export type OnetOccupationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnetOccupation
     */
    select?: OnetOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnetOccupationInclude<ExtArgs> | null
    /**
     * Filter, which OnetOccupations to fetch.
     */
    where?: OnetOccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnetOccupations to fetch.
     */
    orderBy?: OnetOccupationOrderByWithRelationInput | OnetOccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OnetOccupations.
     */
    cursor?: OnetOccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnetOccupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnetOccupations.
     */
    skip?: number
    distinct?: OnetOccupationScalarFieldEnum | OnetOccupationScalarFieldEnum[]
  }

  /**
   * OnetOccupation create
   */
  export type OnetOccupationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnetOccupation
     */
    select?: OnetOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnetOccupationInclude<ExtArgs> | null
    /**
     * The data needed to create a OnetOccupation.
     */
    data: XOR<OnetOccupationCreateInput, OnetOccupationUncheckedCreateInput>
  }

  /**
   * OnetOccupation createMany
   */
  export type OnetOccupationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OnetOccupations.
     */
    data: OnetOccupationCreateManyInput | OnetOccupationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OnetOccupation createManyAndReturn
   */
  export type OnetOccupationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnetOccupation
     */
    select?: OnetOccupationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OnetOccupations.
     */
    data: OnetOccupationCreateManyInput | OnetOccupationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OnetOccupation update
   */
  export type OnetOccupationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnetOccupation
     */
    select?: OnetOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnetOccupationInclude<ExtArgs> | null
    /**
     * The data needed to update a OnetOccupation.
     */
    data: XOR<OnetOccupationUpdateInput, OnetOccupationUncheckedUpdateInput>
    /**
     * Choose, which OnetOccupation to update.
     */
    where: OnetOccupationWhereUniqueInput
  }

  /**
   * OnetOccupation updateMany
   */
  export type OnetOccupationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OnetOccupations.
     */
    data: XOR<OnetOccupationUpdateManyMutationInput, OnetOccupationUncheckedUpdateManyInput>
    /**
     * Filter which OnetOccupations to update
     */
    where?: OnetOccupationWhereInput
  }

  /**
   * OnetOccupation upsert
   */
  export type OnetOccupationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnetOccupation
     */
    select?: OnetOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnetOccupationInclude<ExtArgs> | null
    /**
     * The filter to search for the OnetOccupation to update in case it exists.
     */
    where: OnetOccupationWhereUniqueInput
    /**
     * In case the OnetOccupation found by the `where` argument doesn't exist, create a new OnetOccupation with this data.
     */
    create: XOR<OnetOccupationCreateInput, OnetOccupationUncheckedCreateInput>
    /**
     * In case the OnetOccupation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OnetOccupationUpdateInput, OnetOccupationUncheckedUpdateInput>
  }

  /**
   * OnetOccupation delete
   */
  export type OnetOccupationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnetOccupation
     */
    select?: OnetOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnetOccupationInclude<ExtArgs> | null
    /**
     * Filter which OnetOccupation to delete.
     */
    where: OnetOccupationWhereUniqueInput
  }

  /**
   * OnetOccupation deleteMany
   */
  export type OnetOccupationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnetOccupations to delete
     */
    where?: OnetOccupationWhereInput
  }

  /**
   * OnetOccupation.projectOccupations
   */
  export type OnetOccupation$projectOccupationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOccupation
     */
    select?: ProjectOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOccupationInclude<ExtArgs> | null
    where?: ProjectOccupationWhereInput
    orderBy?: ProjectOccupationOrderByWithRelationInput | ProjectOccupationOrderByWithRelationInput[]
    cursor?: ProjectOccupationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectOccupationScalarFieldEnum | ProjectOccupationScalarFieldEnum[]
  }

  /**
   * OnetOccupation without action
   */
  export type OnetOccupationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnetOccupation
     */
    select?: OnetOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnetOccupationInclude<ExtArgs> | null
  }


  /**
   * Model ResearchProject
   */

  export type AggregateResearchProject = {
    _count: ResearchProjectCountAggregateOutputType | null
    _avg: ResearchProjectAvgAggregateOutputType | null
    _sum: ResearchProjectSumAggregateOutputType | null
    _min: ResearchProjectMinAggregateOutputType | null
    _max: ResearchProjectMaxAggregateOutputType | null
  }

  export type ResearchProjectAvgAggregateOutputType = {
    fundingAmount: Decimal | null
  }

  export type ResearchProjectSumAggregateOutputType = {
    fundingAmount: Decimal | null
  }

  export type ResearchProjectMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.ProjectStatus | null
    principalInvestigatorId: string | null
    startDate: Date | null
    endDate: Date | null
    fundingSource: string | null
    fundingAmount: Decimal | null
    methodologyType: $Enums.MethodologyType | null
    ethicalApprovalRequired: boolean | null
    ethicalApprovalStatus: string | null
    dataClassification: string | null
    collaborationLevel: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResearchProjectMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.ProjectStatus | null
    principalInvestigatorId: string | null
    startDate: Date | null
    endDate: Date | null
    fundingSource: string | null
    fundingAmount: Decimal | null
    methodologyType: $Enums.MethodologyType | null
    ethicalApprovalRequired: boolean | null
    ethicalApprovalStatus: string | null
    dataClassification: string | null
    collaborationLevel: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResearchProjectCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    principalInvestigatorId: number
    startDate: number
    endDate: number
    fundingSource: number
    fundingAmount: number
    institutions: number
    methodologyType: number
    researchQuestions: number
    objectives: number
    hypotheses: number
    ethicalApprovalRequired: number
    ethicalApprovalStatus: number
    dataClassification: number
    collaborationLevel: number
    isPublic: number
    tags: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResearchProjectAvgAggregateInputType = {
    fundingAmount?: true
  }

  export type ResearchProjectSumAggregateInputType = {
    fundingAmount?: true
  }

  export type ResearchProjectMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    principalInvestigatorId?: true
    startDate?: true
    endDate?: true
    fundingSource?: true
    fundingAmount?: true
    methodologyType?: true
    ethicalApprovalRequired?: true
    ethicalApprovalStatus?: true
    dataClassification?: true
    collaborationLevel?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResearchProjectMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    principalInvestigatorId?: true
    startDate?: true
    endDate?: true
    fundingSource?: true
    fundingAmount?: true
    methodologyType?: true
    ethicalApprovalRequired?: true
    ethicalApprovalStatus?: true
    dataClassification?: true
    collaborationLevel?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResearchProjectCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    principalInvestigatorId?: true
    startDate?: true
    endDate?: true
    fundingSource?: true
    fundingAmount?: true
    institutions?: true
    methodologyType?: true
    researchQuestions?: true
    objectives?: true
    hypotheses?: true
    ethicalApprovalRequired?: true
    ethicalApprovalStatus?: true
    dataClassification?: true
    collaborationLevel?: true
    isPublic?: true
    tags?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResearchProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchProject to aggregate.
     */
    where?: ResearchProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchProjects to fetch.
     */
    orderBy?: ResearchProjectOrderByWithRelationInput | ResearchProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResearchProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResearchProjects
    **/
    _count?: true | ResearchProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResearchProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResearchProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResearchProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResearchProjectMaxAggregateInputType
  }

  export type GetResearchProjectAggregateType<T extends ResearchProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateResearchProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResearchProject[P]>
      : GetScalarType<T[P], AggregateResearchProject[P]>
  }




  export type ResearchProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchProjectWhereInput
    orderBy?: ResearchProjectOrderByWithAggregationInput | ResearchProjectOrderByWithAggregationInput[]
    by: ResearchProjectScalarFieldEnum[] | ResearchProjectScalarFieldEnum
    having?: ResearchProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResearchProjectCountAggregateInputType | true
    _avg?: ResearchProjectAvgAggregateInputType
    _sum?: ResearchProjectSumAggregateInputType
    _min?: ResearchProjectMinAggregateInputType
    _max?: ResearchProjectMaxAggregateInputType
  }

  export type ResearchProjectGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.ProjectStatus
    principalInvestigatorId: string
    startDate: Date | null
    endDate: Date | null
    fundingSource: string | null
    fundingAmount: Decimal | null
    institutions: string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions: string[]
    objectives: string[]
    hypotheses: string[]
    ethicalApprovalRequired: boolean
    ethicalApprovalStatus: string | null
    dataClassification: string
    collaborationLevel: string
    isPublic: boolean
    tags: string[]
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ResearchProjectCountAggregateOutputType | null
    _avg: ResearchProjectAvgAggregateOutputType | null
    _sum: ResearchProjectSumAggregateOutputType | null
    _min: ResearchProjectMinAggregateOutputType | null
    _max: ResearchProjectMaxAggregateOutputType | null
  }

  type GetResearchProjectGroupByPayload<T extends ResearchProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResearchProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResearchProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResearchProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ResearchProjectGroupByOutputType[P]>
        }
      >
    >


  export type ResearchProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    principalInvestigatorId?: boolean
    startDate?: boolean
    endDate?: boolean
    fundingSource?: boolean
    fundingAmount?: boolean
    institutions?: boolean
    methodologyType?: boolean
    researchQuestions?: boolean
    objectives?: boolean
    hypotheses?: boolean
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: boolean
    dataClassification?: boolean
    collaborationLevel?: boolean
    isPublic?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    knowledgeIntegrations?: boolean | ResearchProject$knowledgeIntegrationsArgs<ExtArgs>
    collaborators?: boolean | ResearchProject$collaboratorsArgs<ExtArgs>
    disciplines?: boolean | ResearchProject$disciplinesArgs<ExtArgs>
    methodologySteps?: boolean | ResearchProject$methodologyStepsArgs<ExtArgs>
    occupations?: boolean | ResearchProject$occupationsArgs<ExtArgs>
    analyses?: boolean | ResearchProject$analysesArgs<ExtArgs>
    principalInvestigator?: boolean | UserDefaultArgs<ExtArgs>
    images?: boolean | ResearchProject$imagesArgs<ExtArgs>
    _count?: boolean | ResearchProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchProject"]>

  export type ResearchProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    principalInvestigatorId?: boolean
    startDate?: boolean
    endDate?: boolean
    fundingSource?: boolean
    fundingAmount?: boolean
    institutions?: boolean
    methodologyType?: boolean
    researchQuestions?: boolean
    objectives?: boolean
    hypotheses?: boolean
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: boolean
    dataClassification?: boolean
    collaborationLevel?: boolean
    isPublic?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    principalInvestigator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchProject"]>

  export type ResearchProjectSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    principalInvestigatorId?: boolean
    startDate?: boolean
    endDate?: boolean
    fundingSource?: boolean
    fundingAmount?: boolean
    institutions?: boolean
    methodologyType?: boolean
    researchQuestions?: boolean
    objectives?: boolean
    hypotheses?: boolean
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: boolean
    dataClassification?: boolean
    collaborationLevel?: boolean
    isPublic?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResearchProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledgeIntegrations?: boolean | ResearchProject$knowledgeIntegrationsArgs<ExtArgs>
    collaborators?: boolean | ResearchProject$collaboratorsArgs<ExtArgs>
    disciplines?: boolean | ResearchProject$disciplinesArgs<ExtArgs>
    methodologySteps?: boolean | ResearchProject$methodologyStepsArgs<ExtArgs>
    occupations?: boolean | ResearchProject$occupationsArgs<ExtArgs>
    analyses?: boolean | ResearchProject$analysesArgs<ExtArgs>
    principalInvestigator?: boolean | UserDefaultArgs<ExtArgs>
    images?: boolean | ResearchProject$imagesArgs<ExtArgs>
    _count?: boolean | ResearchProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResearchProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    principalInvestigator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ResearchProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResearchProject"
    objects: {
      knowledgeIntegrations: Prisma.$KnowledgeIntegrationPayload<ExtArgs>[]
      collaborators: Prisma.$ProjectCollaboratorPayload<ExtArgs>[]
      disciplines: Prisma.$ProjectDisciplinePayload<ExtArgs>[]
      methodologySteps: Prisma.$ProjectMethodologyStepPayload<ExtArgs>[]
      occupations: Prisma.$ProjectOccupationPayload<ExtArgs>[]
      analyses: Prisma.$ResearchAnalysisPayload<ExtArgs>[]
      principalInvestigator: Prisma.$UserPayload<ExtArgs>
      images: Prisma.$UploadedImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.ProjectStatus
      principalInvestigatorId: string
      startDate: Date | null
      endDate: Date | null
      fundingSource: string | null
      fundingAmount: Prisma.Decimal | null
      institutions: string[]
      methodologyType: $Enums.MethodologyType
      researchQuestions: string[]
      objectives: string[]
      hypotheses: string[]
      ethicalApprovalRequired: boolean
      ethicalApprovalStatus: string | null
      dataClassification: string
      collaborationLevel: string
      isPublic: boolean
      tags: string[]
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["researchProject"]>
    composites: {}
  }

  type ResearchProjectGetPayload<S extends boolean | null | undefined | ResearchProjectDefaultArgs> = $Result.GetResult<Prisma.$ResearchProjectPayload, S>

  type ResearchProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResearchProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResearchProjectCountAggregateInputType | true
    }

  export interface ResearchProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResearchProject'], meta: { name: 'ResearchProject' } }
    /**
     * Find zero or one ResearchProject that matches the filter.
     * @param {ResearchProjectFindUniqueArgs} args - Arguments to find a ResearchProject
     * @example
     * // Get one ResearchProject
     * const researchProject = await prisma.researchProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResearchProjectFindUniqueArgs>(args: SelectSubset<T, ResearchProjectFindUniqueArgs<ExtArgs>>): Prisma__ResearchProjectClient<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ResearchProject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResearchProjectFindUniqueOrThrowArgs} args - Arguments to find a ResearchProject
     * @example
     * // Get one ResearchProject
     * const researchProject = await prisma.researchProject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResearchProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ResearchProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResearchProjectClient<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ResearchProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProjectFindFirstArgs} args - Arguments to find a ResearchProject
     * @example
     * // Get one ResearchProject
     * const researchProject = await prisma.researchProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResearchProjectFindFirstArgs>(args?: SelectSubset<T, ResearchProjectFindFirstArgs<ExtArgs>>): Prisma__ResearchProjectClient<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ResearchProject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProjectFindFirstOrThrowArgs} args - Arguments to find a ResearchProject
     * @example
     * // Get one ResearchProject
     * const researchProject = await prisma.researchProject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResearchProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ResearchProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResearchProjectClient<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ResearchProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResearchProjects
     * const researchProjects = await prisma.researchProject.findMany()
     * 
     * // Get first 10 ResearchProjects
     * const researchProjects = await prisma.researchProject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const researchProjectWithIdOnly = await prisma.researchProject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResearchProjectFindManyArgs>(args?: SelectSubset<T, ResearchProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ResearchProject.
     * @param {ResearchProjectCreateArgs} args - Arguments to create a ResearchProject.
     * @example
     * // Create one ResearchProject
     * const ResearchProject = await prisma.researchProject.create({
     *   data: {
     *     // ... data to create a ResearchProject
     *   }
     * })
     * 
     */
    create<T extends ResearchProjectCreateArgs>(args: SelectSubset<T, ResearchProjectCreateArgs<ExtArgs>>): Prisma__ResearchProjectClient<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ResearchProjects.
     * @param {ResearchProjectCreateManyArgs} args - Arguments to create many ResearchProjects.
     * @example
     * // Create many ResearchProjects
     * const researchProject = await prisma.researchProject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResearchProjectCreateManyArgs>(args?: SelectSubset<T, ResearchProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResearchProjects and returns the data saved in the database.
     * @param {ResearchProjectCreateManyAndReturnArgs} args - Arguments to create many ResearchProjects.
     * @example
     * // Create many ResearchProjects
     * const researchProject = await prisma.researchProject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResearchProjects and only return the `id`
     * const researchProjectWithIdOnly = await prisma.researchProject.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResearchProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ResearchProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ResearchProject.
     * @param {ResearchProjectDeleteArgs} args - Arguments to delete one ResearchProject.
     * @example
     * // Delete one ResearchProject
     * const ResearchProject = await prisma.researchProject.delete({
     *   where: {
     *     // ... filter to delete one ResearchProject
     *   }
     * })
     * 
     */
    delete<T extends ResearchProjectDeleteArgs>(args: SelectSubset<T, ResearchProjectDeleteArgs<ExtArgs>>): Prisma__ResearchProjectClient<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ResearchProject.
     * @param {ResearchProjectUpdateArgs} args - Arguments to update one ResearchProject.
     * @example
     * // Update one ResearchProject
     * const researchProject = await prisma.researchProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResearchProjectUpdateArgs>(args: SelectSubset<T, ResearchProjectUpdateArgs<ExtArgs>>): Prisma__ResearchProjectClient<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ResearchProjects.
     * @param {ResearchProjectDeleteManyArgs} args - Arguments to filter ResearchProjects to delete.
     * @example
     * // Delete a few ResearchProjects
     * const { count } = await prisma.researchProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResearchProjectDeleteManyArgs>(args?: SelectSubset<T, ResearchProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResearchProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResearchProjects
     * const researchProject = await prisma.researchProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResearchProjectUpdateManyArgs>(args: SelectSubset<T, ResearchProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResearchProject.
     * @param {ResearchProjectUpsertArgs} args - Arguments to update or create a ResearchProject.
     * @example
     * // Update or create a ResearchProject
     * const researchProject = await prisma.researchProject.upsert({
     *   create: {
     *     // ... data to create a ResearchProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResearchProject we want to update
     *   }
     * })
     */
    upsert<T extends ResearchProjectUpsertArgs>(args: SelectSubset<T, ResearchProjectUpsertArgs<ExtArgs>>): Prisma__ResearchProjectClient<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ResearchProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProjectCountArgs} args - Arguments to filter ResearchProjects to count.
     * @example
     * // Count the number of ResearchProjects
     * const count = await prisma.researchProject.count({
     *   where: {
     *     // ... the filter for the ResearchProjects we want to count
     *   }
     * })
    **/
    count<T extends ResearchProjectCountArgs>(
      args?: Subset<T, ResearchProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResearchProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResearchProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResearchProjectAggregateArgs>(args: Subset<T, ResearchProjectAggregateArgs>): Prisma.PrismaPromise<GetResearchProjectAggregateType<T>>

    /**
     * Group by ResearchProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResearchProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResearchProjectGroupByArgs['orderBy'] }
        : { orderBy?: ResearchProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResearchProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResearchProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResearchProject model
   */
  readonly fields: ResearchProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResearchProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResearchProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    knowledgeIntegrations<T extends ResearchProject$knowledgeIntegrationsArgs<ExtArgs> = {}>(args?: Subset<T, ResearchProject$knowledgeIntegrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeIntegrationPayload<ExtArgs>, T, "findMany"> | Null>
    collaborators<T extends ResearchProject$collaboratorsArgs<ExtArgs> = {}>(args?: Subset<T, ResearchProject$collaboratorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findMany"> | Null>
    disciplines<T extends ResearchProject$disciplinesArgs<ExtArgs> = {}>(args?: Subset<T, ResearchProject$disciplinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDisciplinePayload<ExtArgs>, T, "findMany"> | Null>
    methodologySteps<T extends ResearchProject$methodologyStepsArgs<ExtArgs> = {}>(args?: Subset<T, ResearchProject$methodologyStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMethodologyStepPayload<ExtArgs>, T, "findMany"> | Null>
    occupations<T extends ResearchProject$occupationsArgs<ExtArgs> = {}>(args?: Subset<T, ResearchProject$occupationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectOccupationPayload<ExtArgs>, T, "findMany"> | Null>
    analyses<T extends ResearchProject$analysesArgs<ExtArgs> = {}>(args?: Subset<T, ResearchProject$analysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchAnalysisPayload<ExtArgs>, T, "findMany"> | Null>
    principalInvestigator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    images<T extends ResearchProject$imagesArgs<ExtArgs> = {}>(args?: Subset<T, ResearchProject$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadedImagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResearchProject model
   */ 
  interface ResearchProjectFieldRefs {
    readonly id: FieldRef<"ResearchProject", 'String'>
    readonly title: FieldRef<"ResearchProject", 'String'>
    readonly description: FieldRef<"ResearchProject", 'String'>
    readonly status: FieldRef<"ResearchProject", 'ProjectStatus'>
    readonly principalInvestigatorId: FieldRef<"ResearchProject", 'String'>
    readonly startDate: FieldRef<"ResearchProject", 'DateTime'>
    readonly endDate: FieldRef<"ResearchProject", 'DateTime'>
    readonly fundingSource: FieldRef<"ResearchProject", 'String'>
    readonly fundingAmount: FieldRef<"ResearchProject", 'Decimal'>
    readonly institutions: FieldRef<"ResearchProject", 'String[]'>
    readonly methodologyType: FieldRef<"ResearchProject", 'MethodologyType'>
    readonly researchQuestions: FieldRef<"ResearchProject", 'String[]'>
    readonly objectives: FieldRef<"ResearchProject", 'String[]'>
    readonly hypotheses: FieldRef<"ResearchProject", 'String[]'>
    readonly ethicalApprovalRequired: FieldRef<"ResearchProject", 'Boolean'>
    readonly ethicalApprovalStatus: FieldRef<"ResearchProject", 'String'>
    readonly dataClassification: FieldRef<"ResearchProject", 'String'>
    readonly collaborationLevel: FieldRef<"ResearchProject", 'String'>
    readonly isPublic: FieldRef<"ResearchProject", 'Boolean'>
    readonly tags: FieldRef<"ResearchProject", 'String[]'>
    readonly metadata: FieldRef<"ResearchProject", 'Json'>
    readonly createdAt: FieldRef<"ResearchProject", 'DateTime'>
    readonly updatedAt: FieldRef<"ResearchProject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResearchProject findUnique
   */
  export type ResearchProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProject
     */
    select?: ResearchProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectInclude<ExtArgs> | null
    /**
     * Filter, which ResearchProject to fetch.
     */
    where: ResearchProjectWhereUniqueInput
  }

  /**
   * ResearchProject findUniqueOrThrow
   */
  export type ResearchProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProject
     */
    select?: ResearchProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectInclude<ExtArgs> | null
    /**
     * Filter, which ResearchProject to fetch.
     */
    where: ResearchProjectWhereUniqueInput
  }

  /**
   * ResearchProject findFirst
   */
  export type ResearchProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProject
     */
    select?: ResearchProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectInclude<ExtArgs> | null
    /**
     * Filter, which ResearchProject to fetch.
     */
    where?: ResearchProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchProjects to fetch.
     */
    orderBy?: ResearchProjectOrderByWithRelationInput | ResearchProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchProjects.
     */
    cursor?: ResearchProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchProjects.
     */
    distinct?: ResearchProjectScalarFieldEnum | ResearchProjectScalarFieldEnum[]
  }

  /**
   * ResearchProject findFirstOrThrow
   */
  export type ResearchProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProject
     */
    select?: ResearchProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectInclude<ExtArgs> | null
    /**
     * Filter, which ResearchProject to fetch.
     */
    where?: ResearchProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchProjects to fetch.
     */
    orderBy?: ResearchProjectOrderByWithRelationInput | ResearchProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchProjects.
     */
    cursor?: ResearchProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchProjects.
     */
    distinct?: ResearchProjectScalarFieldEnum | ResearchProjectScalarFieldEnum[]
  }

  /**
   * ResearchProject findMany
   */
  export type ResearchProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProject
     */
    select?: ResearchProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectInclude<ExtArgs> | null
    /**
     * Filter, which ResearchProjects to fetch.
     */
    where?: ResearchProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchProjects to fetch.
     */
    orderBy?: ResearchProjectOrderByWithRelationInput | ResearchProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResearchProjects.
     */
    cursor?: ResearchProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchProjects.
     */
    skip?: number
    distinct?: ResearchProjectScalarFieldEnum | ResearchProjectScalarFieldEnum[]
  }

  /**
   * ResearchProject create
   */
  export type ResearchProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProject
     */
    select?: ResearchProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a ResearchProject.
     */
    data: XOR<ResearchProjectCreateInput, ResearchProjectUncheckedCreateInput>
  }

  /**
   * ResearchProject createMany
   */
  export type ResearchProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResearchProjects.
     */
    data: ResearchProjectCreateManyInput | ResearchProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResearchProject createManyAndReturn
   */
  export type ResearchProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProject
     */
    select?: ResearchProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ResearchProjects.
     */
    data: ResearchProjectCreateManyInput | ResearchProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResearchProject update
   */
  export type ResearchProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProject
     */
    select?: ResearchProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a ResearchProject.
     */
    data: XOR<ResearchProjectUpdateInput, ResearchProjectUncheckedUpdateInput>
    /**
     * Choose, which ResearchProject to update.
     */
    where: ResearchProjectWhereUniqueInput
  }

  /**
   * ResearchProject updateMany
   */
  export type ResearchProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResearchProjects.
     */
    data: XOR<ResearchProjectUpdateManyMutationInput, ResearchProjectUncheckedUpdateManyInput>
    /**
     * Filter which ResearchProjects to update
     */
    where?: ResearchProjectWhereInput
  }

  /**
   * ResearchProject upsert
   */
  export type ResearchProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProject
     */
    select?: ResearchProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the ResearchProject to update in case it exists.
     */
    where: ResearchProjectWhereUniqueInput
    /**
     * In case the ResearchProject found by the `where` argument doesn't exist, create a new ResearchProject with this data.
     */
    create: XOR<ResearchProjectCreateInput, ResearchProjectUncheckedCreateInput>
    /**
     * In case the ResearchProject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResearchProjectUpdateInput, ResearchProjectUncheckedUpdateInput>
  }

  /**
   * ResearchProject delete
   */
  export type ResearchProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProject
     */
    select?: ResearchProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectInclude<ExtArgs> | null
    /**
     * Filter which ResearchProject to delete.
     */
    where: ResearchProjectWhereUniqueInput
  }

  /**
   * ResearchProject deleteMany
   */
  export type ResearchProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchProjects to delete
     */
    where?: ResearchProjectWhereInput
  }

  /**
   * ResearchProject.knowledgeIntegrations
   */
  export type ResearchProject$knowledgeIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeIntegration
     */
    select?: KnowledgeIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeIntegrationInclude<ExtArgs> | null
    where?: KnowledgeIntegrationWhereInput
    orderBy?: KnowledgeIntegrationOrderByWithRelationInput | KnowledgeIntegrationOrderByWithRelationInput[]
    cursor?: KnowledgeIntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeIntegrationScalarFieldEnum | KnowledgeIntegrationScalarFieldEnum[]
  }

  /**
   * ResearchProject.collaborators
   */
  export type ResearchProject$collaboratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    where?: ProjectCollaboratorWhereInput
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    cursor?: ProjectCollaboratorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectCollaboratorScalarFieldEnum | ProjectCollaboratorScalarFieldEnum[]
  }

  /**
   * ResearchProject.disciplines
   */
  export type ResearchProject$disciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDiscipline
     */
    select?: ProjectDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDisciplineInclude<ExtArgs> | null
    where?: ProjectDisciplineWhereInput
    orderBy?: ProjectDisciplineOrderByWithRelationInput | ProjectDisciplineOrderByWithRelationInput[]
    cursor?: ProjectDisciplineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectDisciplineScalarFieldEnum | ProjectDisciplineScalarFieldEnum[]
  }

  /**
   * ResearchProject.methodologySteps
   */
  export type ResearchProject$methodologyStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMethodologyStep
     */
    select?: ProjectMethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMethodologyStepInclude<ExtArgs> | null
    where?: ProjectMethodologyStepWhereInput
    orderBy?: ProjectMethodologyStepOrderByWithRelationInput | ProjectMethodologyStepOrderByWithRelationInput[]
    cursor?: ProjectMethodologyStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMethodologyStepScalarFieldEnum | ProjectMethodologyStepScalarFieldEnum[]
  }

  /**
   * ResearchProject.occupations
   */
  export type ResearchProject$occupationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOccupation
     */
    select?: ProjectOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOccupationInclude<ExtArgs> | null
    where?: ProjectOccupationWhereInput
    orderBy?: ProjectOccupationOrderByWithRelationInput | ProjectOccupationOrderByWithRelationInput[]
    cursor?: ProjectOccupationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectOccupationScalarFieldEnum | ProjectOccupationScalarFieldEnum[]
  }

  /**
   * ResearchProject.analyses
   */
  export type ResearchProject$analysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchAnalysis
     */
    select?: ResearchAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchAnalysisInclude<ExtArgs> | null
    where?: ResearchAnalysisWhereInput
    orderBy?: ResearchAnalysisOrderByWithRelationInput | ResearchAnalysisOrderByWithRelationInput[]
    cursor?: ResearchAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchAnalysisScalarFieldEnum | ResearchAnalysisScalarFieldEnum[]
  }

  /**
   * ResearchProject.images
   */
  export type ResearchProject$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedImage
     */
    select?: UploadedImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedImageInclude<ExtArgs> | null
    where?: UploadedImageWhereInput
    orderBy?: UploadedImageOrderByWithRelationInput | UploadedImageOrderByWithRelationInput[]
    cursor?: UploadedImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UploadedImageScalarFieldEnum | UploadedImageScalarFieldEnum[]
  }

  /**
   * ResearchProject without action
   */
  export type ResearchProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProject
     */
    select?: ResearchProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectDiscipline
   */

  export type AggregateProjectDiscipline = {
    _count: ProjectDisciplineCountAggregateOutputType | null
    _min: ProjectDisciplineMinAggregateOutputType | null
    _max: ProjectDisciplineMaxAggregateOutputType | null
  }

  export type ProjectDisciplineMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    disciplineId: string | null
    primaryDiscipline: boolean | null
    contributionLevel: string | null
    createdAt: Date | null
  }

  export type ProjectDisciplineMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    disciplineId: string | null
    primaryDiscipline: boolean | null
    contributionLevel: string | null
    createdAt: Date | null
  }

  export type ProjectDisciplineCountAggregateOutputType = {
    id: number
    projectId: number
    disciplineId: number
    primaryDiscipline: number
    contributionLevel: number
    createdAt: number
    _all: number
  }


  export type ProjectDisciplineMinAggregateInputType = {
    id?: true
    projectId?: true
    disciplineId?: true
    primaryDiscipline?: true
    contributionLevel?: true
    createdAt?: true
  }

  export type ProjectDisciplineMaxAggregateInputType = {
    id?: true
    projectId?: true
    disciplineId?: true
    primaryDiscipline?: true
    contributionLevel?: true
    createdAt?: true
  }

  export type ProjectDisciplineCountAggregateInputType = {
    id?: true
    projectId?: true
    disciplineId?: true
    primaryDiscipline?: true
    contributionLevel?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectDisciplineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectDiscipline to aggregate.
     */
    where?: ProjectDisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDisciplines to fetch.
     */
    orderBy?: ProjectDisciplineOrderByWithRelationInput | ProjectDisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectDisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDisciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDisciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectDisciplines
    **/
    _count?: true | ProjectDisciplineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectDisciplineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectDisciplineMaxAggregateInputType
  }

  export type GetProjectDisciplineAggregateType<T extends ProjectDisciplineAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectDiscipline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectDiscipline[P]>
      : GetScalarType<T[P], AggregateProjectDiscipline[P]>
  }




  export type ProjectDisciplineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectDisciplineWhereInput
    orderBy?: ProjectDisciplineOrderByWithAggregationInput | ProjectDisciplineOrderByWithAggregationInput[]
    by: ProjectDisciplineScalarFieldEnum[] | ProjectDisciplineScalarFieldEnum
    having?: ProjectDisciplineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectDisciplineCountAggregateInputType | true
    _min?: ProjectDisciplineMinAggregateInputType
    _max?: ProjectDisciplineMaxAggregateInputType
  }

  export type ProjectDisciplineGroupByOutputType = {
    id: string
    projectId: string
    disciplineId: string
    primaryDiscipline: boolean
    contributionLevel: string
    createdAt: Date
    _count: ProjectDisciplineCountAggregateOutputType | null
    _min: ProjectDisciplineMinAggregateOutputType | null
    _max: ProjectDisciplineMaxAggregateOutputType | null
  }

  type GetProjectDisciplineGroupByPayload<T extends ProjectDisciplineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectDisciplineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectDisciplineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectDisciplineGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectDisciplineGroupByOutputType[P]>
        }
      >
    >


  export type ProjectDisciplineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    disciplineId?: boolean
    primaryDiscipline?: boolean
    contributionLevel?: boolean
    createdAt?: boolean
    discipline?: boolean | AcademicDisciplineDefaultArgs<ExtArgs>
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectDiscipline"]>

  export type ProjectDisciplineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    disciplineId?: boolean
    primaryDiscipline?: boolean
    contributionLevel?: boolean
    createdAt?: boolean
    discipline?: boolean | AcademicDisciplineDefaultArgs<ExtArgs>
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectDiscipline"]>

  export type ProjectDisciplineSelectScalar = {
    id?: boolean
    projectId?: boolean
    disciplineId?: boolean
    primaryDiscipline?: boolean
    contributionLevel?: boolean
    createdAt?: boolean
  }

  export type ProjectDisciplineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discipline?: boolean | AcademicDisciplineDefaultArgs<ExtArgs>
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
  }
  export type ProjectDisciplineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discipline?: boolean | AcademicDisciplineDefaultArgs<ExtArgs>
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectDisciplinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectDiscipline"
    objects: {
      discipline: Prisma.$AcademicDisciplinePayload<ExtArgs>
      project: Prisma.$ResearchProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      disciplineId: string
      primaryDiscipline: boolean
      contributionLevel: string
      createdAt: Date
    }, ExtArgs["result"]["projectDiscipline"]>
    composites: {}
  }

  type ProjectDisciplineGetPayload<S extends boolean | null | undefined | ProjectDisciplineDefaultArgs> = $Result.GetResult<Prisma.$ProjectDisciplinePayload, S>

  type ProjectDisciplineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectDisciplineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectDisciplineCountAggregateInputType | true
    }

  export interface ProjectDisciplineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectDiscipline'], meta: { name: 'ProjectDiscipline' } }
    /**
     * Find zero or one ProjectDiscipline that matches the filter.
     * @param {ProjectDisciplineFindUniqueArgs} args - Arguments to find a ProjectDiscipline
     * @example
     * // Get one ProjectDiscipline
     * const projectDiscipline = await prisma.projectDiscipline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectDisciplineFindUniqueArgs>(args: SelectSubset<T, ProjectDisciplineFindUniqueArgs<ExtArgs>>): Prisma__ProjectDisciplineClient<$Result.GetResult<Prisma.$ProjectDisciplinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectDiscipline that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectDisciplineFindUniqueOrThrowArgs} args - Arguments to find a ProjectDiscipline
     * @example
     * // Get one ProjectDiscipline
     * const projectDiscipline = await prisma.projectDiscipline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectDisciplineFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectDisciplineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectDisciplineClient<$Result.GetResult<Prisma.$ProjectDisciplinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectDiscipline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDisciplineFindFirstArgs} args - Arguments to find a ProjectDiscipline
     * @example
     * // Get one ProjectDiscipline
     * const projectDiscipline = await prisma.projectDiscipline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectDisciplineFindFirstArgs>(args?: SelectSubset<T, ProjectDisciplineFindFirstArgs<ExtArgs>>): Prisma__ProjectDisciplineClient<$Result.GetResult<Prisma.$ProjectDisciplinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectDiscipline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDisciplineFindFirstOrThrowArgs} args - Arguments to find a ProjectDiscipline
     * @example
     * // Get one ProjectDiscipline
     * const projectDiscipline = await prisma.projectDiscipline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectDisciplineFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectDisciplineFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectDisciplineClient<$Result.GetResult<Prisma.$ProjectDisciplinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectDisciplines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDisciplineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectDisciplines
     * const projectDisciplines = await prisma.projectDiscipline.findMany()
     * 
     * // Get first 10 ProjectDisciplines
     * const projectDisciplines = await prisma.projectDiscipline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectDisciplineWithIdOnly = await prisma.projectDiscipline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectDisciplineFindManyArgs>(args?: SelectSubset<T, ProjectDisciplineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDisciplinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectDiscipline.
     * @param {ProjectDisciplineCreateArgs} args - Arguments to create a ProjectDiscipline.
     * @example
     * // Create one ProjectDiscipline
     * const ProjectDiscipline = await prisma.projectDiscipline.create({
     *   data: {
     *     // ... data to create a ProjectDiscipline
     *   }
     * })
     * 
     */
    create<T extends ProjectDisciplineCreateArgs>(args: SelectSubset<T, ProjectDisciplineCreateArgs<ExtArgs>>): Prisma__ProjectDisciplineClient<$Result.GetResult<Prisma.$ProjectDisciplinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectDisciplines.
     * @param {ProjectDisciplineCreateManyArgs} args - Arguments to create many ProjectDisciplines.
     * @example
     * // Create many ProjectDisciplines
     * const projectDiscipline = await prisma.projectDiscipline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectDisciplineCreateManyArgs>(args?: SelectSubset<T, ProjectDisciplineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectDisciplines and returns the data saved in the database.
     * @param {ProjectDisciplineCreateManyAndReturnArgs} args - Arguments to create many ProjectDisciplines.
     * @example
     * // Create many ProjectDisciplines
     * const projectDiscipline = await prisma.projectDiscipline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectDisciplines and only return the `id`
     * const projectDisciplineWithIdOnly = await prisma.projectDiscipline.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectDisciplineCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectDisciplineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDisciplinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectDiscipline.
     * @param {ProjectDisciplineDeleteArgs} args - Arguments to delete one ProjectDiscipline.
     * @example
     * // Delete one ProjectDiscipline
     * const ProjectDiscipline = await prisma.projectDiscipline.delete({
     *   where: {
     *     // ... filter to delete one ProjectDiscipline
     *   }
     * })
     * 
     */
    delete<T extends ProjectDisciplineDeleteArgs>(args: SelectSubset<T, ProjectDisciplineDeleteArgs<ExtArgs>>): Prisma__ProjectDisciplineClient<$Result.GetResult<Prisma.$ProjectDisciplinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectDiscipline.
     * @param {ProjectDisciplineUpdateArgs} args - Arguments to update one ProjectDiscipline.
     * @example
     * // Update one ProjectDiscipline
     * const projectDiscipline = await prisma.projectDiscipline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectDisciplineUpdateArgs>(args: SelectSubset<T, ProjectDisciplineUpdateArgs<ExtArgs>>): Prisma__ProjectDisciplineClient<$Result.GetResult<Prisma.$ProjectDisciplinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectDisciplines.
     * @param {ProjectDisciplineDeleteManyArgs} args - Arguments to filter ProjectDisciplines to delete.
     * @example
     * // Delete a few ProjectDisciplines
     * const { count } = await prisma.projectDiscipline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDisciplineDeleteManyArgs>(args?: SelectSubset<T, ProjectDisciplineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectDisciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDisciplineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectDisciplines
     * const projectDiscipline = await prisma.projectDiscipline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectDisciplineUpdateManyArgs>(args: SelectSubset<T, ProjectDisciplineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectDiscipline.
     * @param {ProjectDisciplineUpsertArgs} args - Arguments to update or create a ProjectDiscipline.
     * @example
     * // Update or create a ProjectDiscipline
     * const projectDiscipline = await prisma.projectDiscipline.upsert({
     *   create: {
     *     // ... data to create a ProjectDiscipline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectDiscipline we want to update
     *   }
     * })
     */
    upsert<T extends ProjectDisciplineUpsertArgs>(args: SelectSubset<T, ProjectDisciplineUpsertArgs<ExtArgs>>): Prisma__ProjectDisciplineClient<$Result.GetResult<Prisma.$ProjectDisciplinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectDisciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDisciplineCountArgs} args - Arguments to filter ProjectDisciplines to count.
     * @example
     * // Count the number of ProjectDisciplines
     * const count = await prisma.projectDiscipline.count({
     *   where: {
     *     // ... the filter for the ProjectDisciplines we want to count
     *   }
     * })
    **/
    count<T extends ProjectDisciplineCountArgs>(
      args?: Subset<T, ProjectDisciplineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectDisciplineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectDiscipline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDisciplineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectDisciplineAggregateArgs>(args: Subset<T, ProjectDisciplineAggregateArgs>): Prisma.PrismaPromise<GetProjectDisciplineAggregateType<T>>

    /**
     * Group by ProjectDiscipline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDisciplineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectDisciplineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectDisciplineGroupByArgs['orderBy'] }
        : { orderBy?: ProjectDisciplineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectDisciplineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectDisciplineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectDiscipline model
   */
  readonly fields: ProjectDisciplineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectDiscipline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectDisciplineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    discipline<T extends AcademicDisciplineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDisciplineDefaultArgs<ExtArgs>>): Prisma__AcademicDisciplineClient<$Result.GetResult<Prisma.$AcademicDisciplinePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends ResearchProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResearchProjectDefaultArgs<ExtArgs>>): Prisma__ResearchProjectClient<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectDiscipline model
   */ 
  interface ProjectDisciplineFieldRefs {
    readonly id: FieldRef<"ProjectDiscipline", 'String'>
    readonly projectId: FieldRef<"ProjectDiscipline", 'String'>
    readonly disciplineId: FieldRef<"ProjectDiscipline", 'String'>
    readonly primaryDiscipline: FieldRef<"ProjectDiscipline", 'Boolean'>
    readonly contributionLevel: FieldRef<"ProjectDiscipline", 'String'>
    readonly createdAt: FieldRef<"ProjectDiscipline", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectDiscipline findUnique
   */
  export type ProjectDisciplineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDiscipline
     */
    select?: ProjectDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDiscipline to fetch.
     */
    where: ProjectDisciplineWhereUniqueInput
  }

  /**
   * ProjectDiscipline findUniqueOrThrow
   */
  export type ProjectDisciplineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDiscipline
     */
    select?: ProjectDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDiscipline to fetch.
     */
    where: ProjectDisciplineWhereUniqueInput
  }

  /**
   * ProjectDiscipline findFirst
   */
  export type ProjectDisciplineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDiscipline
     */
    select?: ProjectDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDiscipline to fetch.
     */
    where?: ProjectDisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDisciplines to fetch.
     */
    orderBy?: ProjectDisciplineOrderByWithRelationInput | ProjectDisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectDisciplines.
     */
    cursor?: ProjectDisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDisciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDisciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectDisciplines.
     */
    distinct?: ProjectDisciplineScalarFieldEnum | ProjectDisciplineScalarFieldEnum[]
  }

  /**
   * ProjectDiscipline findFirstOrThrow
   */
  export type ProjectDisciplineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDiscipline
     */
    select?: ProjectDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDiscipline to fetch.
     */
    where?: ProjectDisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDisciplines to fetch.
     */
    orderBy?: ProjectDisciplineOrderByWithRelationInput | ProjectDisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectDisciplines.
     */
    cursor?: ProjectDisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDisciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDisciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectDisciplines.
     */
    distinct?: ProjectDisciplineScalarFieldEnum | ProjectDisciplineScalarFieldEnum[]
  }

  /**
   * ProjectDiscipline findMany
   */
  export type ProjectDisciplineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDiscipline
     */
    select?: ProjectDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDisciplines to fetch.
     */
    where?: ProjectDisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDisciplines to fetch.
     */
    orderBy?: ProjectDisciplineOrderByWithRelationInput | ProjectDisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectDisciplines.
     */
    cursor?: ProjectDisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDisciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDisciplines.
     */
    skip?: number
    distinct?: ProjectDisciplineScalarFieldEnum | ProjectDisciplineScalarFieldEnum[]
  }

  /**
   * ProjectDiscipline create
   */
  export type ProjectDisciplineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDiscipline
     */
    select?: ProjectDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDisciplineInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectDiscipline.
     */
    data: XOR<ProjectDisciplineCreateInput, ProjectDisciplineUncheckedCreateInput>
  }

  /**
   * ProjectDiscipline createMany
   */
  export type ProjectDisciplineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectDisciplines.
     */
    data: ProjectDisciplineCreateManyInput | ProjectDisciplineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectDiscipline createManyAndReturn
   */
  export type ProjectDisciplineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDiscipline
     */
    select?: ProjectDisciplineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectDisciplines.
     */
    data: ProjectDisciplineCreateManyInput | ProjectDisciplineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDisciplineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectDiscipline update
   */
  export type ProjectDisciplineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDiscipline
     */
    select?: ProjectDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDisciplineInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectDiscipline.
     */
    data: XOR<ProjectDisciplineUpdateInput, ProjectDisciplineUncheckedUpdateInput>
    /**
     * Choose, which ProjectDiscipline to update.
     */
    where: ProjectDisciplineWhereUniqueInput
  }

  /**
   * ProjectDiscipline updateMany
   */
  export type ProjectDisciplineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectDisciplines.
     */
    data: XOR<ProjectDisciplineUpdateManyMutationInput, ProjectDisciplineUncheckedUpdateManyInput>
    /**
     * Filter which ProjectDisciplines to update
     */
    where?: ProjectDisciplineWhereInput
  }

  /**
   * ProjectDiscipline upsert
   */
  export type ProjectDisciplineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDiscipline
     */
    select?: ProjectDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDisciplineInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectDiscipline to update in case it exists.
     */
    where: ProjectDisciplineWhereUniqueInput
    /**
     * In case the ProjectDiscipline found by the `where` argument doesn't exist, create a new ProjectDiscipline with this data.
     */
    create: XOR<ProjectDisciplineCreateInput, ProjectDisciplineUncheckedCreateInput>
    /**
     * In case the ProjectDiscipline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectDisciplineUpdateInput, ProjectDisciplineUncheckedUpdateInput>
  }

  /**
   * ProjectDiscipline delete
   */
  export type ProjectDisciplineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDiscipline
     */
    select?: ProjectDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDisciplineInclude<ExtArgs> | null
    /**
     * Filter which ProjectDiscipline to delete.
     */
    where: ProjectDisciplineWhereUniqueInput
  }

  /**
   * ProjectDiscipline deleteMany
   */
  export type ProjectDisciplineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectDisciplines to delete
     */
    where?: ProjectDisciplineWhereInput
  }

  /**
   * ProjectDiscipline without action
   */
  export type ProjectDisciplineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDiscipline
     */
    select?: ProjectDisciplineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDisciplineInclude<ExtArgs> | null
  }


  /**
   * Model ProjectOccupation
   */

  export type AggregateProjectOccupation = {
    _count: ProjectOccupationCountAggregateOutputType | null
    _min: ProjectOccupationMinAggregateOutputType | null
    _max: ProjectOccupationMaxAggregateOutputType | null
  }

  export type ProjectOccupationMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    occupationId: string | null
    relevanceLevel: string | null
    roleDescription: string | null
    createdAt: Date | null
  }

  export type ProjectOccupationMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    occupationId: string | null
    relevanceLevel: string | null
    roleDescription: string | null
    createdAt: Date | null
  }

  export type ProjectOccupationCountAggregateOutputType = {
    id: number
    projectId: number
    occupationId: number
    relevanceLevel: number
    roleDescription: number
    createdAt: number
    _all: number
  }


  export type ProjectOccupationMinAggregateInputType = {
    id?: true
    projectId?: true
    occupationId?: true
    relevanceLevel?: true
    roleDescription?: true
    createdAt?: true
  }

  export type ProjectOccupationMaxAggregateInputType = {
    id?: true
    projectId?: true
    occupationId?: true
    relevanceLevel?: true
    roleDescription?: true
    createdAt?: true
  }

  export type ProjectOccupationCountAggregateInputType = {
    id?: true
    projectId?: true
    occupationId?: true
    relevanceLevel?: true
    roleDescription?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectOccupationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectOccupation to aggregate.
     */
    where?: ProjectOccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectOccupations to fetch.
     */
    orderBy?: ProjectOccupationOrderByWithRelationInput | ProjectOccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectOccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectOccupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectOccupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectOccupations
    **/
    _count?: true | ProjectOccupationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectOccupationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectOccupationMaxAggregateInputType
  }

  export type GetProjectOccupationAggregateType<T extends ProjectOccupationAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectOccupation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectOccupation[P]>
      : GetScalarType<T[P], AggregateProjectOccupation[P]>
  }




  export type ProjectOccupationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectOccupationWhereInput
    orderBy?: ProjectOccupationOrderByWithAggregationInput | ProjectOccupationOrderByWithAggregationInput[]
    by: ProjectOccupationScalarFieldEnum[] | ProjectOccupationScalarFieldEnum
    having?: ProjectOccupationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectOccupationCountAggregateInputType | true
    _min?: ProjectOccupationMinAggregateInputType
    _max?: ProjectOccupationMaxAggregateInputType
  }

  export type ProjectOccupationGroupByOutputType = {
    id: string
    projectId: string
    occupationId: string
    relevanceLevel: string
    roleDescription: string | null
    createdAt: Date
    _count: ProjectOccupationCountAggregateOutputType | null
    _min: ProjectOccupationMinAggregateOutputType | null
    _max: ProjectOccupationMaxAggregateOutputType | null
  }

  type GetProjectOccupationGroupByPayload<T extends ProjectOccupationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectOccupationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectOccupationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectOccupationGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectOccupationGroupByOutputType[P]>
        }
      >
    >


  export type ProjectOccupationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    occupationId?: boolean
    relevanceLevel?: boolean
    roleDescription?: boolean
    createdAt?: boolean
    occupation?: boolean | OnetOccupationDefaultArgs<ExtArgs>
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectOccupation"]>

  export type ProjectOccupationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    occupationId?: boolean
    relevanceLevel?: boolean
    roleDescription?: boolean
    createdAt?: boolean
    occupation?: boolean | OnetOccupationDefaultArgs<ExtArgs>
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectOccupation"]>

  export type ProjectOccupationSelectScalar = {
    id?: boolean
    projectId?: boolean
    occupationId?: boolean
    relevanceLevel?: boolean
    roleDescription?: boolean
    createdAt?: boolean
  }

  export type ProjectOccupationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    occupation?: boolean | OnetOccupationDefaultArgs<ExtArgs>
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
  }
  export type ProjectOccupationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    occupation?: boolean | OnetOccupationDefaultArgs<ExtArgs>
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectOccupationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectOccupation"
    objects: {
      occupation: Prisma.$OnetOccupationPayload<ExtArgs>
      project: Prisma.$ResearchProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      occupationId: string
      relevanceLevel: string
      roleDescription: string | null
      createdAt: Date
    }, ExtArgs["result"]["projectOccupation"]>
    composites: {}
  }

  type ProjectOccupationGetPayload<S extends boolean | null | undefined | ProjectOccupationDefaultArgs> = $Result.GetResult<Prisma.$ProjectOccupationPayload, S>

  type ProjectOccupationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectOccupationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectOccupationCountAggregateInputType | true
    }

  export interface ProjectOccupationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectOccupation'], meta: { name: 'ProjectOccupation' } }
    /**
     * Find zero or one ProjectOccupation that matches the filter.
     * @param {ProjectOccupationFindUniqueArgs} args - Arguments to find a ProjectOccupation
     * @example
     * // Get one ProjectOccupation
     * const projectOccupation = await prisma.projectOccupation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectOccupationFindUniqueArgs>(args: SelectSubset<T, ProjectOccupationFindUniqueArgs<ExtArgs>>): Prisma__ProjectOccupationClient<$Result.GetResult<Prisma.$ProjectOccupationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectOccupation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectOccupationFindUniqueOrThrowArgs} args - Arguments to find a ProjectOccupation
     * @example
     * // Get one ProjectOccupation
     * const projectOccupation = await prisma.projectOccupation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectOccupationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectOccupationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectOccupationClient<$Result.GetResult<Prisma.$ProjectOccupationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectOccupation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectOccupationFindFirstArgs} args - Arguments to find a ProjectOccupation
     * @example
     * // Get one ProjectOccupation
     * const projectOccupation = await prisma.projectOccupation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectOccupationFindFirstArgs>(args?: SelectSubset<T, ProjectOccupationFindFirstArgs<ExtArgs>>): Prisma__ProjectOccupationClient<$Result.GetResult<Prisma.$ProjectOccupationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectOccupation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectOccupationFindFirstOrThrowArgs} args - Arguments to find a ProjectOccupation
     * @example
     * // Get one ProjectOccupation
     * const projectOccupation = await prisma.projectOccupation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectOccupationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectOccupationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectOccupationClient<$Result.GetResult<Prisma.$ProjectOccupationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectOccupations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectOccupationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectOccupations
     * const projectOccupations = await prisma.projectOccupation.findMany()
     * 
     * // Get first 10 ProjectOccupations
     * const projectOccupations = await prisma.projectOccupation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectOccupationWithIdOnly = await prisma.projectOccupation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectOccupationFindManyArgs>(args?: SelectSubset<T, ProjectOccupationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectOccupationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectOccupation.
     * @param {ProjectOccupationCreateArgs} args - Arguments to create a ProjectOccupation.
     * @example
     * // Create one ProjectOccupation
     * const ProjectOccupation = await prisma.projectOccupation.create({
     *   data: {
     *     // ... data to create a ProjectOccupation
     *   }
     * })
     * 
     */
    create<T extends ProjectOccupationCreateArgs>(args: SelectSubset<T, ProjectOccupationCreateArgs<ExtArgs>>): Prisma__ProjectOccupationClient<$Result.GetResult<Prisma.$ProjectOccupationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectOccupations.
     * @param {ProjectOccupationCreateManyArgs} args - Arguments to create many ProjectOccupations.
     * @example
     * // Create many ProjectOccupations
     * const projectOccupation = await prisma.projectOccupation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectOccupationCreateManyArgs>(args?: SelectSubset<T, ProjectOccupationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectOccupations and returns the data saved in the database.
     * @param {ProjectOccupationCreateManyAndReturnArgs} args - Arguments to create many ProjectOccupations.
     * @example
     * // Create many ProjectOccupations
     * const projectOccupation = await prisma.projectOccupation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectOccupations and only return the `id`
     * const projectOccupationWithIdOnly = await prisma.projectOccupation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectOccupationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectOccupationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectOccupationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectOccupation.
     * @param {ProjectOccupationDeleteArgs} args - Arguments to delete one ProjectOccupation.
     * @example
     * // Delete one ProjectOccupation
     * const ProjectOccupation = await prisma.projectOccupation.delete({
     *   where: {
     *     // ... filter to delete one ProjectOccupation
     *   }
     * })
     * 
     */
    delete<T extends ProjectOccupationDeleteArgs>(args: SelectSubset<T, ProjectOccupationDeleteArgs<ExtArgs>>): Prisma__ProjectOccupationClient<$Result.GetResult<Prisma.$ProjectOccupationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectOccupation.
     * @param {ProjectOccupationUpdateArgs} args - Arguments to update one ProjectOccupation.
     * @example
     * // Update one ProjectOccupation
     * const projectOccupation = await prisma.projectOccupation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectOccupationUpdateArgs>(args: SelectSubset<T, ProjectOccupationUpdateArgs<ExtArgs>>): Prisma__ProjectOccupationClient<$Result.GetResult<Prisma.$ProjectOccupationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectOccupations.
     * @param {ProjectOccupationDeleteManyArgs} args - Arguments to filter ProjectOccupations to delete.
     * @example
     * // Delete a few ProjectOccupations
     * const { count } = await prisma.projectOccupation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectOccupationDeleteManyArgs>(args?: SelectSubset<T, ProjectOccupationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectOccupations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectOccupationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectOccupations
     * const projectOccupation = await prisma.projectOccupation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectOccupationUpdateManyArgs>(args: SelectSubset<T, ProjectOccupationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectOccupation.
     * @param {ProjectOccupationUpsertArgs} args - Arguments to update or create a ProjectOccupation.
     * @example
     * // Update or create a ProjectOccupation
     * const projectOccupation = await prisma.projectOccupation.upsert({
     *   create: {
     *     // ... data to create a ProjectOccupation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectOccupation we want to update
     *   }
     * })
     */
    upsert<T extends ProjectOccupationUpsertArgs>(args: SelectSubset<T, ProjectOccupationUpsertArgs<ExtArgs>>): Prisma__ProjectOccupationClient<$Result.GetResult<Prisma.$ProjectOccupationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectOccupations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectOccupationCountArgs} args - Arguments to filter ProjectOccupations to count.
     * @example
     * // Count the number of ProjectOccupations
     * const count = await prisma.projectOccupation.count({
     *   where: {
     *     // ... the filter for the ProjectOccupations we want to count
     *   }
     * })
    **/
    count<T extends ProjectOccupationCountArgs>(
      args?: Subset<T, ProjectOccupationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectOccupationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectOccupation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectOccupationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectOccupationAggregateArgs>(args: Subset<T, ProjectOccupationAggregateArgs>): Prisma.PrismaPromise<GetProjectOccupationAggregateType<T>>

    /**
     * Group by ProjectOccupation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectOccupationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectOccupationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectOccupationGroupByArgs['orderBy'] }
        : { orderBy?: ProjectOccupationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectOccupationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectOccupationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectOccupation model
   */
  readonly fields: ProjectOccupationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectOccupation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectOccupationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    occupation<T extends OnetOccupationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OnetOccupationDefaultArgs<ExtArgs>>): Prisma__OnetOccupationClient<$Result.GetResult<Prisma.$OnetOccupationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends ResearchProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResearchProjectDefaultArgs<ExtArgs>>): Prisma__ResearchProjectClient<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectOccupation model
   */ 
  interface ProjectOccupationFieldRefs {
    readonly id: FieldRef<"ProjectOccupation", 'String'>
    readonly projectId: FieldRef<"ProjectOccupation", 'String'>
    readonly occupationId: FieldRef<"ProjectOccupation", 'String'>
    readonly relevanceLevel: FieldRef<"ProjectOccupation", 'String'>
    readonly roleDescription: FieldRef<"ProjectOccupation", 'String'>
    readonly createdAt: FieldRef<"ProjectOccupation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectOccupation findUnique
   */
  export type ProjectOccupationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOccupation
     */
    select?: ProjectOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOccupationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectOccupation to fetch.
     */
    where: ProjectOccupationWhereUniqueInput
  }

  /**
   * ProjectOccupation findUniqueOrThrow
   */
  export type ProjectOccupationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOccupation
     */
    select?: ProjectOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOccupationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectOccupation to fetch.
     */
    where: ProjectOccupationWhereUniqueInput
  }

  /**
   * ProjectOccupation findFirst
   */
  export type ProjectOccupationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOccupation
     */
    select?: ProjectOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOccupationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectOccupation to fetch.
     */
    where?: ProjectOccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectOccupations to fetch.
     */
    orderBy?: ProjectOccupationOrderByWithRelationInput | ProjectOccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectOccupations.
     */
    cursor?: ProjectOccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectOccupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectOccupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectOccupations.
     */
    distinct?: ProjectOccupationScalarFieldEnum | ProjectOccupationScalarFieldEnum[]
  }

  /**
   * ProjectOccupation findFirstOrThrow
   */
  export type ProjectOccupationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOccupation
     */
    select?: ProjectOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOccupationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectOccupation to fetch.
     */
    where?: ProjectOccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectOccupations to fetch.
     */
    orderBy?: ProjectOccupationOrderByWithRelationInput | ProjectOccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectOccupations.
     */
    cursor?: ProjectOccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectOccupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectOccupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectOccupations.
     */
    distinct?: ProjectOccupationScalarFieldEnum | ProjectOccupationScalarFieldEnum[]
  }

  /**
   * ProjectOccupation findMany
   */
  export type ProjectOccupationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOccupation
     */
    select?: ProjectOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOccupationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectOccupations to fetch.
     */
    where?: ProjectOccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectOccupations to fetch.
     */
    orderBy?: ProjectOccupationOrderByWithRelationInput | ProjectOccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectOccupations.
     */
    cursor?: ProjectOccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectOccupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectOccupations.
     */
    skip?: number
    distinct?: ProjectOccupationScalarFieldEnum | ProjectOccupationScalarFieldEnum[]
  }

  /**
   * ProjectOccupation create
   */
  export type ProjectOccupationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOccupation
     */
    select?: ProjectOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOccupationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectOccupation.
     */
    data: XOR<ProjectOccupationCreateInput, ProjectOccupationUncheckedCreateInput>
  }

  /**
   * ProjectOccupation createMany
   */
  export type ProjectOccupationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectOccupations.
     */
    data: ProjectOccupationCreateManyInput | ProjectOccupationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectOccupation createManyAndReturn
   */
  export type ProjectOccupationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOccupation
     */
    select?: ProjectOccupationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectOccupations.
     */
    data: ProjectOccupationCreateManyInput | ProjectOccupationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOccupationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectOccupation update
   */
  export type ProjectOccupationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOccupation
     */
    select?: ProjectOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOccupationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectOccupation.
     */
    data: XOR<ProjectOccupationUpdateInput, ProjectOccupationUncheckedUpdateInput>
    /**
     * Choose, which ProjectOccupation to update.
     */
    where: ProjectOccupationWhereUniqueInput
  }

  /**
   * ProjectOccupation updateMany
   */
  export type ProjectOccupationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectOccupations.
     */
    data: XOR<ProjectOccupationUpdateManyMutationInput, ProjectOccupationUncheckedUpdateManyInput>
    /**
     * Filter which ProjectOccupations to update
     */
    where?: ProjectOccupationWhereInput
  }

  /**
   * ProjectOccupation upsert
   */
  export type ProjectOccupationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOccupation
     */
    select?: ProjectOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOccupationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectOccupation to update in case it exists.
     */
    where: ProjectOccupationWhereUniqueInput
    /**
     * In case the ProjectOccupation found by the `where` argument doesn't exist, create a new ProjectOccupation with this data.
     */
    create: XOR<ProjectOccupationCreateInput, ProjectOccupationUncheckedCreateInput>
    /**
     * In case the ProjectOccupation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectOccupationUpdateInput, ProjectOccupationUncheckedUpdateInput>
  }

  /**
   * ProjectOccupation delete
   */
  export type ProjectOccupationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOccupation
     */
    select?: ProjectOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOccupationInclude<ExtArgs> | null
    /**
     * Filter which ProjectOccupation to delete.
     */
    where: ProjectOccupationWhereUniqueInput
  }

  /**
   * ProjectOccupation deleteMany
   */
  export type ProjectOccupationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectOccupations to delete
     */
    where?: ProjectOccupationWhereInput
  }

  /**
   * ProjectOccupation without action
   */
  export type ProjectOccupationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOccupation
     */
    select?: ProjectOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOccupationInclude<ExtArgs> | null
  }


  /**
   * Model MethodologyStep
   */

  export type AggregateMethodologyStep = {
    _count: MethodologyStepCountAggregateOutputType | null
    _avg: MethodologyStepAvgAggregateOutputType | null
    _sum: MethodologyStepSumAggregateOutputType | null
    _min: MethodologyStepMinAggregateOutputType | null
    _max: MethodologyStepMaxAggregateOutputType | null
  }

  export type MethodologyStepAvgAggregateOutputType = {
    stepOrder: number | null
    estimatedDurationHours: number | null
  }

  export type MethodologyStepSumAggregateOutputType = {
    stepOrder: number | null
    estimatedDurationHours: number | null
  }

  export type MethodologyStepMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    methodologyType: $Enums.MethodologyType | null
    stepOrder: number | null
    estimatedDurationHours: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type MethodologyStepMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    methodologyType: $Enums.MethodologyType | null
    stepOrder: number | null
    estimatedDurationHours: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type MethodologyStepCountAggregateOutputType = {
    id: number
    name: number
    description: number
    methodologyType: number
    stepOrder: number
    estimatedDurationHours: number
    requiredResources: number
    deliverables: number
    successCriteria: number
    dependencies: number
    templateData: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type MethodologyStepAvgAggregateInputType = {
    stepOrder?: true
    estimatedDurationHours?: true
  }

  export type MethodologyStepSumAggregateInputType = {
    stepOrder?: true
    estimatedDurationHours?: true
  }

  export type MethodologyStepMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    methodologyType?: true
    stepOrder?: true
    estimatedDurationHours?: true
    isActive?: true
    createdAt?: true
  }

  export type MethodologyStepMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    methodologyType?: true
    stepOrder?: true
    estimatedDurationHours?: true
    isActive?: true
    createdAt?: true
  }

  export type MethodologyStepCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    methodologyType?: true
    stepOrder?: true
    estimatedDurationHours?: true
    requiredResources?: true
    deliverables?: true
    successCriteria?: true
    dependencies?: true
    templateData?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type MethodologyStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MethodologyStep to aggregate.
     */
    where?: MethodologyStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MethodologySteps to fetch.
     */
    orderBy?: MethodologyStepOrderByWithRelationInput | MethodologyStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MethodologyStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MethodologySteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MethodologySteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MethodologySteps
    **/
    _count?: true | MethodologyStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MethodologyStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MethodologyStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MethodologyStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MethodologyStepMaxAggregateInputType
  }

  export type GetMethodologyStepAggregateType<T extends MethodologyStepAggregateArgs> = {
        [P in keyof T & keyof AggregateMethodologyStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMethodologyStep[P]>
      : GetScalarType<T[P], AggregateMethodologyStep[P]>
  }




  export type MethodologyStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MethodologyStepWhereInput
    orderBy?: MethodologyStepOrderByWithAggregationInput | MethodologyStepOrderByWithAggregationInput[]
    by: MethodologyStepScalarFieldEnum[] | MethodologyStepScalarFieldEnum
    having?: MethodologyStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MethodologyStepCountAggregateInputType | true
    _avg?: MethodologyStepAvgAggregateInputType
    _sum?: MethodologyStepSumAggregateInputType
    _min?: MethodologyStepMinAggregateInputType
    _max?: MethodologyStepMaxAggregateInputType
  }

  export type MethodologyStepGroupByOutputType = {
    id: string
    name: string
    description: string | null
    methodologyType: $Enums.MethodologyType
    stepOrder: number
    estimatedDurationHours: number | null
    requiredResources: string[]
    deliverables: string[]
    successCriteria: string[]
    dependencies: string[]
    templateData: JsonValue
    isActive: boolean
    createdAt: Date
    _count: MethodologyStepCountAggregateOutputType | null
    _avg: MethodologyStepAvgAggregateOutputType | null
    _sum: MethodologyStepSumAggregateOutputType | null
    _min: MethodologyStepMinAggregateOutputType | null
    _max: MethodologyStepMaxAggregateOutputType | null
  }

  type GetMethodologyStepGroupByPayload<T extends MethodologyStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MethodologyStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MethodologyStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MethodologyStepGroupByOutputType[P]>
            : GetScalarType<T[P], MethodologyStepGroupByOutputType[P]>
        }
      >
    >


  export type MethodologyStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    methodologyType?: boolean
    stepOrder?: boolean
    estimatedDurationHours?: boolean
    requiredResources?: boolean
    deliverables?: boolean
    successCriteria?: boolean
    dependencies?: boolean
    templateData?: boolean
    isActive?: boolean
    createdAt?: boolean
    projectSteps?: boolean | MethodologyStep$projectStepsArgs<ExtArgs>
    _count?: boolean | MethodologyStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["methodologyStep"]>

  export type MethodologyStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    methodologyType?: boolean
    stepOrder?: boolean
    estimatedDurationHours?: boolean
    requiredResources?: boolean
    deliverables?: boolean
    successCriteria?: boolean
    dependencies?: boolean
    templateData?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["methodologyStep"]>

  export type MethodologyStepSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    methodologyType?: boolean
    stepOrder?: boolean
    estimatedDurationHours?: boolean
    requiredResources?: boolean
    deliverables?: boolean
    successCriteria?: boolean
    dependencies?: boolean
    templateData?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type MethodologyStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectSteps?: boolean | MethodologyStep$projectStepsArgs<ExtArgs>
    _count?: boolean | MethodologyStepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MethodologyStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MethodologyStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MethodologyStep"
    objects: {
      projectSteps: Prisma.$ProjectMethodologyStepPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      methodologyType: $Enums.MethodologyType
      stepOrder: number
      estimatedDurationHours: number | null
      requiredResources: string[]
      deliverables: string[]
      successCriteria: string[]
      dependencies: string[]
      templateData: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["methodologyStep"]>
    composites: {}
  }

  type MethodologyStepGetPayload<S extends boolean | null | undefined | MethodologyStepDefaultArgs> = $Result.GetResult<Prisma.$MethodologyStepPayload, S>

  type MethodologyStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MethodologyStepFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MethodologyStepCountAggregateInputType | true
    }

  export interface MethodologyStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MethodologyStep'], meta: { name: 'MethodologyStep' } }
    /**
     * Find zero or one MethodologyStep that matches the filter.
     * @param {MethodologyStepFindUniqueArgs} args - Arguments to find a MethodologyStep
     * @example
     * // Get one MethodologyStep
     * const methodologyStep = await prisma.methodologyStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MethodologyStepFindUniqueArgs>(args: SelectSubset<T, MethodologyStepFindUniqueArgs<ExtArgs>>): Prisma__MethodologyStepClient<$Result.GetResult<Prisma.$MethodologyStepPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MethodologyStep that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MethodologyStepFindUniqueOrThrowArgs} args - Arguments to find a MethodologyStep
     * @example
     * // Get one MethodologyStep
     * const methodologyStep = await prisma.methodologyStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MethodologyStepFindUniqueOrThrowArgs>(args: SelectSubset<T, MethodologyStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MethodologyStepClient<$Result.GetResult<Prisma.$MethodologyStepPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MethodologyStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyStepFindFirstArgs} args - Arguments to find a MethodologyStep
     * @example
     * // Get one MethodologyStep
     * const methodologyStep = await prisma.methodologyStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MethodologyStepFindFirstArgs>(args?: SelectSubset<T, MethodologyStepFindFirstArgs<ExtArgs>>): Prisma__MethodologyStepClient<$Result.GetResult<Prisma.$MethodologyStepPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MethodologyStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyStepFindFirstOrThrowArgs} args - Arguments to find a MethodologyStep
     * @example
     * // Get one MethodologyStep
     * const methodologyStep = await prisma.methodologyStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MethodologyStepFindFirstOrThrowArgs>(args?: SelectSubset<T, MethodologyStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__MethodologyStepClient<$Result.GetResult<Prisma.$MethodologyStepPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MethodologySteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MethodologySteps
     * const methodologySteps = await prisma.methodologyStep.findMany()
     * 
     * // Get first 10 MethodologySteps
     * const methodologySteps = await prisma.methodologyStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const methodologyStepWithIdOnly = await prisma.methodologyStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MethodologyStepFindManyArgs>(args?: SelectSubset<T, MethodologyStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MethodologyStepPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MethodologyStep.
     * @param {MethodologyStepCreateArgs} args - Arguments to create a MethodologyStep.
     * @example
     * // Create one MethodologyStep
     * const MethodologyStep = await prisma.methodologyStep.create({
     *   data: {
     *     // ... data to create a MethodologyStep
     *   }
     * })
     * 
     */
    create<T extends MethodologyStepCreateArgs>(args: SelectSubset<T, MethodologyStepCreateArgs<ExtArgs>>): Prisma__MethodologyStepClient<$Result.GetResult<Prisma.$MethodologyStepPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MethodologySteps.
     * @param {MethodologyStepCreateManyArgs} args - Arguments to create many MethodologySteps.
     * @example
     * // Create many MethodologySteps
     * const methodologyStep = await prisma.methodologyStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MethodologyStepCreateManyArgs>(args?: SelectSubset<T, MethodologyStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MethodologySteps and returns the data saved in the database.
     * @param {MethodologyStepCreateManyAndReturnArgs} args - Arguments to create many MethodologySteps.
     * @example
     * // Create many MethodologySteps
     * const methodologyStep = await prisma.methodologyStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MethodologySteps and only return the `id`
     * const methodologyStepWithIdOnly = await prisma.methodologyStep.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MethodologyStepCreateManyAndReturnArgs>(args?: SelectSubset<T, MethodologyStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MethodologyStepPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MethodologyStep.
     * @param {MethodologyStepDeleteArgs} args - Arguments to delete one MethodologyStep.
     * @example
     * // Delete one MethodologyStep
     * const MethodologyStep = await prisma.methodologyStep.delete({
     *   where: {
     *     // ... filter to delete one MethodologyStep
     *   }
     * })
     * 
     */
    delete<T extends MethodologyStepDeleteArgs>(args: SelectSubset<T, MethodologyStepDeleteArgs<ExtArgs>>): Prisma__MethodologyStepClient<$Result.GetResult<Prisma.$MethodologyStepPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MethodologyStep.
     * @param {MethodologyStepUpdateArgs} args - Arguments to update one MethodologyStep.
     * @example
     * // Update one MethodologyStep
     * const methodologyStep = await prisma.methodologyStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MethodologyStepUpdateArgs>(args: SelectSubset<T, MethodologyStepUpdateArgs<ExtArgs>>): Prisma__MethodologyStepClient<$Result.GetResult<Prisma.$MethodologyStepPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MethodologySteps.
     * @param {MethodologyStepDeleteManyArgs} args - Arguments to filter MethodologySteps to delete.
     * @example
     * // Delete a few MethodologySteps
     * const { count } = await prisma.methodologyStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MethodologyStepDeleteManyArgs>(args?: SelectSubset<T, MethodologyStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MethodologySteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MethodologySteps
     * const methodologyStep = await prisma.methodologyStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MethodologyStepUpdateManyArgs>(args: SelectSubset<T, MethodologyStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MethodologyStep.
     * @param {MethodologyStepUpsertArgs} args - Arguments to update or create a MethodologyStep.
     * @example
     * // Update or create a MethodologyStep
     * const methodologyStep = await prisma.methodologyStep.upsert({
     *   create: {
     *     // ... data to create a MethodologyStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MethodologyStep we want to update
     *   }
     * })
     */
    upsert<T extends MethodologyStepUpsertArgs>(args: SelectSubset<T, MethodologyStepUpsertArgs<ExtArgs>>): Prisma__MethodologyStepClient<$Result.GetResult<Prisma.$MethodologyStepPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MethodologySteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyStepCountArgs} args - Arguments to filter MethodologySteps to count.
     * @example
     * // Count the number of MethodologySteps
     * const count = await prisma.methodologyStep.count({
     *   where: {
     *     // ... the filter for the MethodologySteps we want to count
     *   }
     * })
    **/
    count<T extends MethodologyStepCountArgs>(
      args?: Subset<T, MethodologyStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MethodologyStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MethodologyStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MethodologyStepAggregateArgs>(args: Subset<T, MethodologyStepAggregateArgs>): Prisma.PrismaPromise<GetMethodologyStepAggregateType<T>>

    /**
     * Group by MethodologyStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MethodologyStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MethodologyStepGroupByArgs['orderBy'] }
        : { orderBy?: MethodologyStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MethodologyStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMethodologyStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MethodologyStep model
   */
  readonly fields: MethodologyStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MethodologyStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MethodologyStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projectSteps<T extends MethodologyStep$projectStepsArgs<ExtArgs> = {}>(args?: Subset<T, MethodologyStep$projectStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMethodologyStepPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MethodologyStep model
   */ 
  interface MethodologyStepFieldRefs {
    readonly id: FieldRef<"MethodologyStep", 'String'>
    readonly name: FieldRef<"MethodologyStep", 'String'>
    readonly description: FieldRef<"MethodologyStep", 'String'>
    readonly methodologyType: FieldRef<"MethodologyStep", 'MethodologyType'>
    readonly stepOrder: FieldRef<"MethodologyStep", 'Int'>
    readonly estimatedDurationHours: FieldRef<"MethodologyStep", 'Int'>
    readonly requiredResources: FieldRef<"MethodologyStep", 'String[]'>
    readonly deliverables: FieldRef<"MethodologyStep", 'String[]'>
    readonly successCriteria: FieldRef<"MethodologyStep", 'String[]'>
    readonly dependencies: FieldRef<"MethodologyStep", 'String[]'>
    readonly templateData: FieldRef<"MethodologyStep", 'Json'>
    readonly isActive: FieldRef<"MethodologyStep", 'Boolean'>
    readonly createdAt: FieldRef<"MethodologyStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MethodologyStep findUnique
   */
  export type MethodologyStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodologyStep
     */
    select?: MethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyStepInclude<ExtArgs> | null
    /**
     * Filter, which MethodologyStep to fetch.
     */
    where: MethodologyStepWhereUniqueInput
  }

  /**
   * MethodologyStep findUniqueOrThrow
   */
  export type MethodologyStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodologyStep
     */
    select?: MethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyStepInclude<ExtArgs> | null
    /**
     * Filter, which MethodologyStep to fetch.
     */
    where: MethodologyStepWhereUniqueInput
  }

  /**
   * MethodologyStep findFirst
   */
  export type MethodologyStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodologyStep
     */
    select?: MethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyStepInclude<ExtArgs> | null
    /**
     * Filter, which MethodologyStep to fetch.
     */
    where?: MethodologyStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MethodologySteps to fetch.
     */
    orderBy?: MethodologyStepOrderByWithRelationInput | MethodologyStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MethodologySteps.
     */
    cursor?: MethodologyStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MethodologySteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MethodologySteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MethodologySteps.
     */
    distinct?: MethodologyStepScalarFieldEnum | MethodologyStepScalarFieldEnum[]
  }

  /**
   * MethodologyStep findFirstOrThrow
   */
  export type MethodologyStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodologyStep
     */
    select?: MethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyStepInclude<ExtArgs> | null
    /**
     * Filter, which MethodologyStep to fetch.
     */
    where?: MethodologyStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MethodologySteps to fetch.
     */
    orderBy?: MethodologyStepOrderByWithRelationInput | MethodologyStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MethodologySteps.
     */
    cursor?: MethodologyStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MethodologySteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MethodologySteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MethodologySteps.
     */
    distinct?: MethodologyStepScalarFieldEnum | MethodologyStepScalarFieldEnum[]
  }

  /**
   * MethodologyStep findMany
   */
  export type MethodologyStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodologyStep
     */
    select?: MethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyStepInclude<ExtArgs> | null
    /**
     * Filter, which MethodologySteps to fetch.
     */
    where?: MethodologyStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MethodologySteps to fetch.
     */
    orderBy?: MethodologyStepOrderByWithRelationInput | MethodologyStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MethodologySteps.
     */
    cursor?: MethodologyStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MethodologySteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MethodologySteps.
     */
    skip?: number
    distinct?: MethodologyStepScalarFieldEnum | MethodologyStepScalarFieldEnum[]
  }

  /**
   * MethodologyStep create
   */
  export type MethodologyStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodologyStep
     */
    select?: MethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyStepInclude<ExtArgs> | null
    /**
     * The data needed to create a MethodologyStep.
     */
    data: XOR<MethodologyStepCreateInput, MethodologyStepUncheckedCreateInput>
  }

  /**
   * MethodologyStep createMany
   */
  export type MethodologyStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MethodologySteps.
     */
    data: MethodologyStepCreateManyInput | MethodologyStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MethodologyStep createManyAndReturn
   */
  export type MethodologyStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodologyStep
     */
    select?: MethodologyStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MethodologySteps.
     */
    data: MethodologyStepCreateManyInput | MethodologyStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MethodologyStep update
   */
  export type MethodologyStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodologyStep
     */
    select?: MethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyStepInclude<ExtArgs> | null
    /**
     * The data needed to update a MethodologyStep.
     */
    data: XOR<MethodologyStepUpdateInput, MethodologyStepUncheckedUpdateInput>
    /**
     * Choose, which MethodologyStep to update.
     */
    where: MethodologyStepWhereUniqueInput
  }

  /**
   * MethodologyStep updateMany
   */
  export type MethodologyStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MethodologySteps.
     */
    data: XOR<MethodologyStepUpdateManyMutationInput, MethodologyStepUncheckedUpdateManyInput>
    /**
     * Filter which MethodologySteps to update
     */
    where?: MethodologyStepWhereInput
  }

  /**
   * MethodologyStep upsert
   */
  export type MethodologyStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodologyStep
     */
    select?: MethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyStepInclude<ExtArgs> | null
    /**
     * The filter to search for the MethodologyStep to update in case it exists.
     */
    where: MethodologyStepWhereUniqueInput
    /**
     * In case the MethodologyStep found by the `where` argument doesn't exist, create a new MethodologyStep with this data.
     */
    create: XOR<MethodologyStepCreateInput, MethodologyStepUncheckedCreateInput>
    /**
     * In case the MethodologyStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MethodologyStepUpdateInput, MethodologyStepUncheckedUpdateInput>
  }

  /**
   * MethodologyStep delete
   */
  export type MethodologyStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodologyStep
     */
    select?: MethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyStepInclude<ExtArgs> | null
    /**
     * Filter which MethodologyStep to delete.
     */
    where: MethodologyStepWhereUniqueInput
  }

  /**
   * MethodologyStep deleteMany
   */
  export type MethodologyStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MethodologySteps to delete
     */
    where?: MethodologyStepWhereInput
  }

  /**
   * MethodologyStep.projectSteps
   */
  export type MethodologyStep$projectStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMethodologyStep
     */
    select?: ProjectMethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMethodologyStepInclude<ExtArgs> | null
    where?: ProjectMethodologyStepWhereInput
    orderBy?: ProjectMethodologyStepOrderByWithRelationInput | ProjectMethodologyStepOrderByWithRelationInput[]
    cursor?: ProjectMethodologyStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMethodologyStepScalarFieldEnum | ProjectMethodologyStepScalarFieldEnum[]
  }

  /**
   * MethodologyStep without action
   */
  export type MethodologyStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodologyStep
     */
    select?: MethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyStepInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMethodologyStep
   */

  export type AggregateProjectMethodologyStep = {
    _count: ProjectMethodologyStepCountAggregateOutputType | null
    _avg: ProjectMethodologyStepAvgAggregateOutputType | null
    _sum: ProjectMethodologyStepSumAggregateOutputType | null
    _min: ProjectMethodologyStepMinAggregateOutputType | null
    _max: ProjectMethodologyStepMaxAggregateOutputType | null
  }

  export type ProjectMethodologyStepAvgAggregateOutputType = {
    completionPercentage: number | null
  }

  export type ProjectMethodologyStepSumAggregateOutputType = {
    completionPercentage: number | null
  }

  export type ProjectMethodologyStepMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    methodologyStepId: string | null
    assignedToId: string | null
    status: string | null
    actualStartDate: Date | null
    actualEndDate: Date | null
    notes: string | null
    completionPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMethodologyStepMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    methodologyStepId: string | null
    assignedToId: string | null
    status: string | null
    actualStartDate: Date | null
    actualEndDate: Date | null
    notes: string | null
    completionPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMethodologyStepCountAggregateOutputType = {
    id: number
    projectId: number
    methodologyStepId: number
    assignedToId: number
    status: number
    actualStartDate: number
    actualEndDate: number
    notes: number
    deliverablesUploaded: number
    completionPercentage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMethodologyStepAvgAggregateInputType = {
    completionPercentage?: true
  }

  export type ProjectMethodologyStepSumAggregateInputType = {
    completionPercentage?: true
  }

  export type ProjectMethodologyStepMinAggregateInputType = {
    id?: true
    projectId?: true
    methodologyStepId?: true
    assignedToId?: true
    status?: true
    actualStartDate?: true
    actualEndDate?: true
    notes?: true
    completionPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMethodologyStepMaxAggregateInputType = {
    id?: true
    projectId?: true
    methodologyStepId?: true
    assignedToId?: true
    status?: true
    actualStartDate?: true
    actualEndDate?: true
    notes?: true
    completionPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMethodologyStepCountAggregateInputType = {
    id?: true
    projectId?: true
    methodologyStepId?: true
    assignedToId?: true
    status?: true
    actualStartDate?: true
    actualEndDate?: true
    notes?: true
    deliverablesUploaded?: true
    completionPercentage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectMethodologyStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMethodologyStep to aggregate.
     */
    where?: ProjectMethodologyStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMethodologySteps to fetch.
     */
    orderBy?: ProjectMethodologyStepOrderByWithRelationInput | ProjectMethodologyStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMethodologyStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMethodologySteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMethodologySteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMethodologySteps
    **/
    _count?: true | ProjectMethodologyStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectMethodologyStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectMethodologyStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMethodologyStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMethodologyStepMaxAggregateInputType
  }

  export type GetProjectMethodologyStepAggregateType<T extends ProjectMethodologyStepAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMethodologyStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMethodologyStep[P]>
      : GetScalarType<T[P], AggregateProjectMethodologyStep[P]>
  }




  export type ProjectMethodologyStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMethodologyStepWhereInput
    orderBy?: ProjectMethodologyStepOrderByWithAggregationInput | ProjectMethodologyStepOrderByWithAggregationInput[]
    by: ProjectMethodologyStepScalarFieldEnum[] | ProjectMethodologyStepScalarFieldEnum
    having?: ProjectMethodologyStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMethodologyStepCountAggregateInputType | true
    _avg?: ProjectMethodologyStepAvgAggregateInputType
    _sum?: ProjectMethodologyStepSumAggregateInputType
    _min?: ProjectMethodologyStepMinAggregateInputType
    _max?: ProjectMethodologyStepMaxAggregateInputType
  }

  export type ProjectMethodologyStepGroupByOutputType = {
    id: string
    projectId: string
    methodologyStepId: string
    assignedToId: string | null
    status: string
    actualStartDate: Date | null
    actualEndDate: Date | null
    notes: string | null
    deliverablesUploaded: string[]
    completionPercentage: number
    createdAt: Date
    updatedAt: Date
    _count: ProjectMethodologyStepCountAggregateOutputType | null
    _avg: ProjectMethodologyStepAvgAggregateOutputType | null
    _sum: ProjectMethodologyStepSumAggregateOutputType | null
    _min: ProjectMethodologyStepMinAggregateOutputType | null
    _max: ProjectMethodologyStepMaxAggregateOutputType | null
  }

  type GetProjectMethodologyStepGroupByPayload<T extends ProjectMethodologyStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMethodologyStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMethodologyStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMethodologyStepGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMethodologyStepGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMethodologyStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    methodologyStepId?: boolean
    assignedToId?: boolean
    status?: boolean
    actualStartDate?: boolean
    actualEndDate?: boolean
    notes?: boolean
    deliverablesUploaded?: boolean
    completionPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTo?: boolean | ProjectMethodologyStep$assignedToArgs<ExtArgs>
    methodologyStep?: boolean | MethodologyStepDefaultArgs<ExtArgs>
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMethodologyStep"]>

  export type ProjectMethodologyStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    methodologyStepId?: boolean
    assignedToId?: boolean
    status?: boolean
    actualStartDate?: boolean
    actualEndDate?: boolean
    notes?: boolean
    deliverablesUploaded?: boolean
    completionPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTo?: boolean | ProjectMethodologyStep$assignedToArgs<ExtArgs>
    methodologyStep?: boolean | MethodologyStepDefaultArgs<ExtArgs>
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMethodologyStep"]>

  export type ProjectMethodologyStepSelectScalar = {
    id?: boolean
    projectId?: boolean
    methodologyStepId?: boolean
    assignedToId?: boolean
    status?: boolean
    actualStartDate?: boolean
    actualEndDate?: boolean
    notes?: boolean
    deliverablesUploaded?: boolean
    completionPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectMethodologyStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | ProjectMethodologyStep$assignedToArgs<ExtArgs>
    methodologyStep?: boolean | MethodologyStepDefaultArgs<ExtArgs>
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
  }
  export type ProjectMethodologyStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | ProjectMethodologyStep$assignedToArgs<ExtArgs>
    methodologyStep?: boolean | MethodologyStepDefaultArgs<ExtArgs>
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectMethodologyStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMethodologyStep"
    objects: {
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      methodologyStep: Prisma.$MethodologyStepPayload<ExtArgs>
      project: Prisma.$ResearchProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      methodologyStepId: string
      assignedToId: string | null
      status: string
      actualStartDate: Date | null
      actualEndDate: Date | null
      notes: string | null
      deliverablesUploaded: string[]
      completionPercentage: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectMethodologyStep"]>
    composites: {}
  }

  type ProjectMethodologyStepGetPayload<S extends boolean | null | undefined | ProjectMethodologyStepDefaultArgs> = $Result.GetResult<Prisma.$ProjectMethodologyStepPayload, S>

  type ProjectMethodologyStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectMethodologyStepFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectMethodologyStepCountAggregateInputType | true
    }

  export interface ProjectMethodologyStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMethodologyStep'], meta: { name: 'ProjectMethodologyStep' } }
    /**
     * Find zero or one ProjectMethodologyStep that matches the filter.
     * @param {ProjectMethodologyStepFindUniqueArgs} args - Arguments to find a ProjectMethodologyStep
     * @example
     * // Get one ProjectMethodologyStep
     * const projectMethodologyStep = await prisma.projectMethodologyStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMethodologyStepFindUniqueArgs>(args: SelectSubset<T, ProjectMethodologyStepFindUniqueArgs<ExtArgs>>): Prisma__ProjectMethodologyStepClient<$Result.GetResult<Prisma.$ProjectMethodologyStepPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectMethodologyStep that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectMethodologyStepFindUniqueOrThrowArgs} args - Arguments to find a ProjectMethodologyStep
     * @example
     * // Get one ProjectMethodologyStep
     * const projectMethodologyStep = await prisma.projectMethodologyStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMethodologyStepFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMethodologyStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMethodologyStepClient<$Result.GetResult<Prisma.$ProjectMethodologyStepPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectMethodologyStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMethodologyStepFindFirstArgs} args - Arguments to find a ProjectMethodologyStep
     * @example
     * // Get one ProjectMethodologyStep
     * const projectMethodologyStep = await prisma.projectMethodologyStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMethodologyStepFindFirstArgs>(args?: SelectSubset<T, ProjectMethodologyStepFindFirstArgs<ExtArgs>>): Prisma__ProjectMethodologyStepClient<$Result.GetResult<Prisma.$ProjectMethodologyStepPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectMethodologyStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMethodologyStepFindFirstOrThrowArgs} args - Arguments to find a ProjectMethodologyStep
     * @example
     * // Get one ProjectMethodologyStep
     * const projectMethodologyStep = await prisma.projectMethodologyStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMethodologyStepFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMethodologyStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMethodologyStepClient<$Result.GetResult<Prisma.$ProjectMethodologyStepPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectMethodologySteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMethodologyStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMethodologySteps
     * const projectMethodologySteps = await prisma.projectMethodologyStep.findMany()
     * 
     * // Get first 10 ProjectMethodologySteps
     * const projectMethodologySteps = await prisma.projectMethodologyStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMethodologyStepWithIdOnly = await prisma.projectMethodologyStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMethodologyStepFindManyArgs>(args?: SelectSubset<T, ProjectMethodologyStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMethodologyStepPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectMethodologyStep.
     * @param {ProjectMethodologyStepCreateArgs} args - Arguments to create a ProjectMethodologyStep.
     * @example
     * // Create one ProjectMethodologyStep
     * const ProjectMethodologyStep = await prisma.projectMethodologyStep.create({
     *   data: {
     *     // ... data to create a ProjectMethodologyStep
     *   }
     * })
     * 
     */
    create<T extends ProjectMethodologyStepCreateArgs>(args: SelectSubset<T, ProjectMethodologyStepCreateArgs<ExtArgs>>): Prisma__ProjectMethodologyStepClient<$Result.GetResult<Prisma.$ProjectMethodologyStepPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectMethodologySteps.
     * @param {ProjectMethodologyStepCreateManyArgs} args - Arguments to create many ProjectMethodologySteps.
     * @example
     * // Create many ProjectMethodologySteps
     * const projectMethodologyStep = await prisma.projectMethodologyStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMethodologyStepCreateManyArgs>(args?: SelectSubset<T, ProjectMethodologyStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMethodologySteps and returns the data saved in the database.
     * @param {ProjectMethodologyStepCreateManyAndReturnArgs} args - Arguments to create many ProjectMethodologySteps.
     * @example
     * // Create many ProjectMethodologySteps
     * const projectMethodologyStep = await prisma.projectMethodologyStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMethodologySteps and only return the `id`
     * const projectMethodologyStepWithIdOnly = await prisma.projectMethodologyStep.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMethodologyStepCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMethodologyStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMethodologyStepPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectMethodologyStep.
     * @param {ProjectMethodologyStepDeleteArgs} args - Arguments to delete one ProjectMethodologyStep.
     * @example
     * // Delete one ProjectMethodologyStep
     * const ProjectMethodologyStep = await prisma.projectMethodologyStep.delete({
     *   where: {
     *     // ... filter to delete one ProjectMethodologyStep
     *   }
     * })
     * 
     */
    delete<T extends ProjectMethodologyStepDeleteArgs>(args: SelectSubset<T, ProjectMethodologyStepDeleteArgs<ExtArgs>>): Prisma__ProjectMethodologyStepClient<$Result.GetResult<Prisma.$ProjectMethodologyStepPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectMethodologyStep.
     * @param {ProjectMethodologyStepUpdateArgs} args - Arguments to update one ProjectMethodologyStep.
     * @example
     * // Update one ProjectMethodologyStep
     * const projectMethodologyStep = await prisma.projectMethodologyStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMethodologyStepUpdateArgs>(args: SelectSubset<T, ProjectMethodologyStepUpdateArgs<ExtArgs>>): Prisma__ProjectMethodologyStepClient<$Result.GetResult<Prisma.$ProjectMethodologyStepPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectMethodologySteps.
     * @param {ProjectMethodologyStepDeleteManyArgs} args - Arguments to filter ProjectMethodologySteps to delete.
     * @example
     * // Delete a few ProjectMethodologySteps
     * const { count } = await prisma.projectMethodologyStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMethodologyStepDeleteManyArgs>(args?: SelectSubset<T, ProjectMethodologyStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMethodologySteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMethodologyStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMethodologySteps
     * const projectMethodologyStep = await prisma.projectMethodologyStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMethodologyStepUpdateManyArgs>(args: SelectSubset<T, ProjectMethodologyStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectMethodologyStep.
     * @param {ProjectMethodologyStepUpsertArgs} args - Arguments to update or create a ProjectMethodologyStep.
     * @example
     * // Update or create a ProjectMethodologyStep
     * const projectMethodologyStep = await prisma.projectMethodologyStep.upsert({
     *   create: {
     *     // ... data to create a ProjectMethodologyStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMethodologyStep we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMethodologyStepUpsertArgs>(args: SelectSubset<T, ProjectMethodologyStepUpsertArgs<ExtArgs>>): Prisma__ProjectMethodologyStepClient<$Result.GetResult<Prisma.$ProjectMethodologyStepPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectMethodologySteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMethodologyStepCountArgs} args - Arguments to filter ProjectMethodologySteps to count.
     * @example
     * // Count the number of ProjectMethodologySteps
     * const count = await prisma.projectMethodologyStep.count({
     *   where: {
     *     // ... the filter for the ProjectMethodologySteps we want to count
     *   }
     * })
    **/
    count<T extends ProjectMethodologyStepCountArgs>(
      args?: Subset<T, ProjectMethodologyStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMethodologyStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMethodologyStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMethodologyStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMethodologyStepAggregateArgs>(args: Subset<T, ProjectMethodologyStepAggregateArgs>): Prisma.PrismaPromise<GetProjectMethodologyStepAggregateType<T>>

    /**
     * Group by ProjectMethodologyStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMethodologyStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMethodologyStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMethodologyStepGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMethodologyStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMethodologyStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMethodologyStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMethodologyStep model
   */
  readonly fields: ProjectMethodologyStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMethodologyStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMethodologyStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTo<T extends ProjectMethodologyStep$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, ProjectMethodologyStep$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    methodologyStep<T extends MethodologyStepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MethodologyStepDefaultArgs<ExtArgs>>): Prisma__MethodologyStepClient<$Result.GetResult<Prisma.$MethodologyStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends ResearchProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResearchProjectDefaultArgs<ExtArgs>>): Prisma__ResearchProjectClient<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMethodologyStep model
   */ 
  interface ProjectMethodologyStepFieldRefs {
    readonly id: FieldRef<"ProjectMethodologyStep", 'String'>
    readonly projectId: FieldRef<"ProjectMethodologyStep", 'String'>
    readonly methodologyStepId: FieldRef<"ProjectMethodologyStep", 'String'>
    readonly assignedToId: FieldRef<"ProjectMethodologyStep", 'String'>
    readonly status: FieldRef<"ProjectMethodologyStep", 'String'>
    readonly actualStartDate: FieldRef<"ProjectMethodologyStep", 'DateTime'>
    readonly actualEndDate: FieldRef<"ProjectMethodologyStep", 'DateTime'>
    readonly notes: FieldRef<"ProjectMethodologyStep", 'String'>
    readonly deliverablesUploaded: FieldRef<"ProjectMethodologyStep", 'String[]'>
    readonly completionPercentage: FieldRef<"ProjectMethodologyStep", 'Int'>
    readonly createdAt: FieldRef<"ProjectMethodologyStep", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectMethodologyStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMethodologyStep findUnique
   */
  export type ProjectMethodologyStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMethodologyStep
     */
    select?: ProjectMethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMethodologyStepInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMethodologyStep to fetch.
     */
    where: ProjectMethodologyStepWhereUniqueInput
  }

  /**
   * ProjectMethodologyStep findUniqueOrThrow
   */
  export type ProjectMethodologyStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMethodologyStep
     */
    select?: ProjectMethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMethodologyStepInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMethodologyStep to fetch.
     */
    where: ProjectMethodologyStepWhereUniqueInput
  }

  /**
   * ProjectMethodologyStep findFirst
   */
  export type ProjectMethodologyStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMethodologyStep
     */
    select?: ProjectMethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMethodologyStepInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMethodologyStep to fetch.
     */
    where?: ProjectMethodologyStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMethodologySteps to fetch.
     */
    orderBy?: ProjectMethodologyStepOrderByWithRelationInput | ProjectMethodologyStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMethodologySteps.
     */
    cursor?: ProjectMethodologyStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMethodologySteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMethodologySteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMethodologySteps.
     */
    distinct?: ProjectMethodologyStepScalarFieldEnum | ProjectMethodologyStepScalarFieldEnum[]
  }

  /**
   * ProjectMethodologyStep findFirstOrThrow
   */
  export type ProjectMethodologyStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMethodologyStep
     */
    select?: ProjectMethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMethodologyStepInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMethodologyStep to fetch.
     */
    where?: ProjectMethodologyStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMethodologySteps to fetch.
     */
    orderBy?: ProjectMethodologyStepOrderByWithRelationInput | ProjectMethodologyStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMethodologySteps.
     */
    cursor?: ProjectMethodologyStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMethodologySteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMethodologySteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMethodologySteps.
     */
    distinct?: ProjectMethodologyStepScalarFieldEnum | ProjectMethodologyStepScalarFieldEnum[]
  }

  /**
   * ProjectMethodologyStep findMany
   */
  export type ProjectMethodologyStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMethodologyStep
     */
    select?: ProjectMethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMethodologyStepInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMethodologySteps to fetch.
     */
    where?: ProjectMethodologyStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMethodologySteps to fetch.
     */
    orderBy?: ProjectMethodologyStepOrderByWithRelationInput | ProjectMethodologyStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMethodologySteps.
     */
    cursor?: ProjectMethodologyStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMethodologySteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMethodologySteps.
     */
    skip?: number
    distinct?: ProjectMethodologyStepScalarFieldEnum | ProjectMethodologyStepScalarFieldEnum[]
  }

  /**
   * ProjectMethodologyStep create
   */
  export type ProjectMethodologyStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMethodologyStep
     */
    select?: ProjectMethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMethodologyStepInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMethodologyStep.
     */
    data: XOR<ProjectMethodologyStepCreateInput, ProjectMethodologyStepUncheckedCreateInput>
  }

  /**
   * ProjectMethodologyStep createMany
   */
  export type ProjectMethodologyStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMethodologySteps.
     */
    data: ProjectMethodologyStepCreateManyInput | ProjectMethodologyStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMethodologyStep createManyAndReturn
   */
  export type ProjectMethodologyStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMethodologyStep
     */
    select?: ProjectMethodologyStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectMethodologySteps.
     */
    data: ProjectMethodologyStepCreateManyInput | ProjectMethodologyStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMethodologyStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMethodologyStep update
   */
  export type ProjectMethodologyStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMethodologyStep
     */
    select?: ProjectMethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMethodologyStepInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMethodologyStep.
     */
    data: XOR<ProjectMethodologyStepUpdateInput, ProjectMethodologyStepUncheckedUpdateInput>
    /**
     * Choose, which ProjectMethodologyStep to update.
     */
    where: ProjectMethodologyStepWhereUniqueInput
  }

  /**
   * ProjectMethodologyStep updateMany
   */
  export type ProjectMethodologyStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMethodologySteps.
     */
    data: XOR<ProjectMethodologyStepUpdateManyMutationInput, ProjectMethodologyStepUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMethodologySteps to update
     */
    where?: ProjectMethodologyStepWhereInput
  }

  /**
   * ProjectMethodologyStep upsert
   */
  export type ProjectMethodologyStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMethodologyStep
     */
    select?: ProjectMethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMethodologyStepInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMethodologyStep to update in case it exists.
     */
    where: ProjectMethodologyStepWhereUniqueInput
    /**
     * In case the ProjectMethodologyStep found by the `where` argument doesn't exist, create a new ProjectMethodologyStep with this data.
     */
    create: XOR<ProjectMethodologyStepCreateInput, ProjectMethodologyStepUncheckedCreateInput>
    /**
     * In case the ProjectMethodologyStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMethodologyStepUpdateInput, ProjectMethodologyStepUncheckedUpdateInput>
  }

  /**
   * ProjectMethodologyStep delete
   */
  export type ProjectMethodologyStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMethodologyStep
     */
    select?: ProjectMethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMethodologyStepInclude<ExtArgs> | null
    /**
     * Filter which ProjectMethodologyStep to delete.
     */
    where: ProjectMethodologyStepWhereUniqueInput
  }

  /**
   * ProjectMethodologyStep deleteMany
   */
  export type ProjectMethodologyStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMethodologySteps to delete
     */
    where?: ProjectMethodologyStepWhereInput
  }

  /**
   * ProjectMethodologyStep.assignedTo
   */
  export type ProjectMethodologyStep$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProjectMethodologyStep without action
   */
  export type ProjectMethodologyStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMethodologyStep
     */
    select?: ProjectMethodologyStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMethodologyStepInclude<ExtArgs> | null
  }


  /**
   * Model UploadedImage
   */

  export type AggregateUploadedImage = {
    _count: UploadedImageCountAggregateOutputType | null
    _avg: UploadedImageAvgAggregateOutputType | null
    _sum: UploadedImageSumAggregateOutputType | null
    _min: UploadedImageMinAggregateOutputType | null
    _max: UploadedImageMaxAggregateOutputType | null
  }

  export type UploadedImageAvgAggregateOutputType = {
    fileSize: number | null
    imageConfidence: Decimal | null
    width: number | null
    height: number | null
    colorDepth: number | null
  }

  export type UploadedImageSumAggregateOutputType = {
    fileSize: bigint | null
    imageConfidence: Decimal | null
    width: number | null
    height: number | null
    colorDepth: number | null
  }

  export type UploadedImageMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    uploadedById: string | null
    fileName: string | null
    originalFileName: string | null
    filePath: string | null
    fileSize: bigint | null
    mimeType: string | null
    imageType: string | null
    imageConfidence: Decimal | null
    width: number | null
    height: number | null
    colorDepth: number | null
    hasMetadata: boolean | null
    analysisStatus: $Enums.AnalysisStatus | null
    description: string | null
    consentObtained: boolean | null
    dataClassification: string | null
    anonymized: boolean | null
    processingStartedAt: Date | null
    processingCompletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UploadedImageMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    uploadedById: string | null
    fileName: string | null
    originalFileName: string | null
    filePath: string | null
    fileSize: bigint | null
    mimeType: string | null
    imageType: string | null
    imageConfidence: Decimal | null
    width: number | null
    height: number | null
    colorDepth: number | null
    hasMetadata: boolean | null
    analysisStatus: $Enums.AnalysisStatus | null
    description: string | null
    consentObtained: boolean | null
    dataClassification: string | null
    anonymized: boolean | null
    processingStartedAt: Date | null
    processingCompletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UploadedImageCountAggregateOutputType = {
    id: number
    projectId: number
    uploadedById: number
    fileName: number
    originalFileName: number
    filePath: number
    fileSize: number
    mimeType: number
    imageType: number
    imageConfidence: number
    width: number
    height: number
    colorDepth: number
    hasMetadata: number
    dicomMetadata: number
    analysisStatus: number
    tags: number
    description: number
    consentObtained: number
    dataClassification: number
    anonymized: number
    processingStartedAt: number
    processingCompletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UploadedImageAvgAggregateInputType = {
    fileSize?: true
    imageConfidence?: true
    width?: true
    height?: true
    colorDepth?: true
  }

  export type UploadedImageSumAggregateInputType = {
    fileSize?: true
    imageConfidence?: true
    width?: true
    height?: true
    colorDepth?: true
  }

  export type UploadedImageMinAggregateInputType = {
    id?: true
    projectId?: true
    uploadedById?: true
    fileName?: true
    originalFileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    imageType?: true
    imageConfidence?: true
    width?: true
    height?: true
    colorDepth?: true
    hasMetadata?: true
    analysisStatus?: true
    description?: true
    consentObtained?: true
    dataClassification?: true
    anonymized?: true
    processingStartedAt?: true
    processingCompletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UploadedImageMaxAggregateInputType = {
    id?: true
    projectId?: true
    uploadedById?: true
    fileName?: true
    originalFileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    imageType?: true
    imageConfidence?: true
    width?: true
    height?: true
    colorDepth?: true
    hasMetadata?: true
    analysisStatus?: true
    description?: true
    consentObtained?: true
    dataClassification?: true
    anonymized?: true
    processingStartedAt?: true
    processingCompletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UploadedImageCountAggregateInputType = {
    id?: true
    projectId?: true
    uploadedById?: true
    fileName?: true
    originalFileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    imageType?: true
    imageConfidence?: true
    width?: true
    height?: true
    colorDepth?: true
    hasMetadata?: true
    dicomMetadata?: true
    analysisStatus?: true
    tags?: true
    description?: true
    consentObtained?: true
    dataClassification?: true
    anonymized?: true
    processingStartedAt?: true
    processingCompletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UploadedImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UploadedImage to aggregate.
     */
    where?: UploadedImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedImages to fetch.
     */
    orderBy?: UploadedImageOrderByWithRelationInput | UploadedImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UploadedImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UploadedImages
    **/
    _count?: true | UploadedImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UploadedImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UploadedImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UploadedImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UploadedImageMaxAggregateInputType
  }

  export type GetUploadedImageAggregateType<T extends UploadedImageAggregateArgs> = {
        [P in keyof T & keyof AggregateUploadedImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUploadedImage[P]>
      : GetScalarType<T[P], AggregateUploadedImage[P]>
  }




  export type UploadedImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadedImageWhereInput
    orderBy?: UploadedImageOrderByWithAggregationInput | UploadedImageOrderByWithAggregationInput[]
    by: UploadedImageScalarFieldEnum[] | UploadedImageScalarFieldEnum
    having?: UploadedImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UploadedImageCountAggregateInputType | true
    _avg?: UploadedImageAvgAggregateInputType
    _sum?: UploadedImageSumAggregateInputType
    _min?: UploadedImageMinAggregateInputType
    _max?: UploadedImageMaxAggregateInputType
  }

  export type UploadedImageGroupByOutputType = {
    id: string
    projectId: string | null
    uploadedById: string
    fileName: string
    originalFileName: string | null
    filePath: string
    fileSize: bigint | null
    mimeType: string | null
    imageType: string | null
    imageConfidence: Decimal | null
    width: number | null
    height: number | null
    colorDepth: number | null
    hasMetadata: boolean
    dicomMetadata: JsonValue | null
    analysisStatus: $Enums.AnalysisStatus
    tags: string[]
    description: string | null
    consentObtained: boolean
    dataClassification: string
    anonymized: boolean
    processingStartedAt: Date | null
    processingCompletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UploadedImageCountAggregateOutputType | null
    _avg: UploadedImageAvgAggregateOutputType | null
    _sum: UploadedImageSumAggregateOutputType | null
    _min: UploadedImageMinAggregateOutputType | null
    _max: UploadedImageMaxAggregateOutputType | null
  }

  type GetUploadedImageGroupByPayload<T extends UploadedImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UploadedImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UploadedImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UploadedImageGroupByOutputType[P]>
            : GetScalarType<T[P], UploadedImageGroupByOutputType[P]>
        }
      >
    >


  export type UploadedImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    uploadedById?: boolean
    fileName?: boolean
    originalFileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    imageType?: boolean
    imageConfidence?: boolean
    width?: boolean
    height?: boolean
    colorDepth?: boolean
    hasMetadata?: boolean
    dicomMetadata?: boolean
    analysisStatus?: boolean
    tags?: boolean
    description?: boolean
    consentObtained?: boolean
    dataClassification?: boolean
    anonymized?: boolean
    processingStartedAt?: boolean
    processingCompletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    analyses?: boolean | UploadedImage$analysesArgs<ExtArgs>
    project?: boolean | UploadedImage$projectArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | UploadedImageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["uploadedImage"]>

  export type UploadedImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    uploadedById?: boolean
    fileName?: boolean
    originalFileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    imageType?: boolean
    imageConfidence?: boolean
    width?: boolean
    height?: boolean
    colorDepth?: boolean
    hasMetadata?: boolean
    dicomMetadata?: boolean
    analysisStatus?: boolean
    tags?: boolean
    description?: boolean
    consentObtained?: boolean
    dataClassification?: boolean
    anonymized?: boolean
    processingStartedAt?: boolean
    processingCompletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | UploadedImage$projectArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["uploadedImage"]>

  export type UploadedImageSelectScalar = {
    id?: boolean
    projectId?: boolean
    uploadedById?: boolean
    fileName?: boolean
    originalFileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    imageType?: boolean
    imageConfidence?: boolean
    width?: boolean
    height?: boolean
    colorDepth?: boolean
    hasMetadata?: boolean
    dicomMetadata?: boolean
    analysisStatus?: boolean
    tags?: boolean
    description?: boolean
    consentObtained?: boolean
    dataClassification?: boolean
    anonymized?: boolean
    processingStartedAt?: boolean
    processingCompletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UploadedImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analyses?: boolean | UploadedImage$analysesArgs<ExtArgs>
    project?: boolean | UploadedImage$projectArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | UploadedImageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UploadedImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UploadedImage$projectArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UploadedImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UploadedImage"
    objects: {
      analyses: Prisma.$ResearchAnalysisPayload<ExtArgs>[]
      project: Prisma.$ResearchProjectPayload<ExtArgs> | null
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string | null
      uploadedById: string
      fileName: string
      originalFileName: string | null
      filePath: string
      fileSize: bigint | null
      mimeType: string | null
      imageType: string | null
      imageConfidence: Prisma.Decimal | null
      width: number | null
      height: number | null
      colorDepth: number | null
      hasMetadata: boolean
      dicomMetadata: Prisma.JsonValue | null
      analysisStatus: $Enums.AnalysisStatus
      tags: string[]
      description: string | null
      consentObtained: boolean
      dataClassification: string
      anonymized: boolean
      processingStartedAt: Date | null
      processingCompletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["uploadedImage"]>
    composites: {}
  }

  type UploadedImageGetPayload<S extends boolean | null | undefined | UploadedImageDefaultArgs> = $Result.GetResult<Prisma.$UploadedImagePayload, S>

  type UploadedImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UploadedImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UploadedImageCountAggregateInputType | true
    }

  export interface UploadedImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UploadedImage'], meta: { name: 'UploadedImage' } }
    /**
     * Find zero or one UploadedImage that matches the filter.
     * @param {UploadedImageFindUniqueArgs} args - Arguments to find a UploadedImage
     * @example
     * // Get one UploadedImage
     * const uploadedImage = await prisma.uploadedImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UploadedImageFindUniqueArgs>(args: SelectSubset<T, UploadedImageFindUniqueArgs<ExtArgs>>): Prisma__UploadedImageClient<$Result.GetResult<Prisma.$UploadedImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UploadedImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UploadedImageFindUniqueOrThrowArgs} args - Arguments to find a UploadedImage
     * @example
     * // Get one UploadedImage
     * const uploadedImage = await prisma.uploadedImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UploadedImageFindUniqueOrThrowArgs>(args: SelectSubset<T, UploadedImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UploadedImageClient<$Result.GetResult<Prisma.$UploadedImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UploadedImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedImageFindFirstArgs} args - Arguments to find a UploadedImage
     * @example
     * // Get one UploadedImage
     * const uploadedImage = await prisma.uploadedImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UploadedImageFindFirstArgs>(args?: SelectSubset<T, UploadedImageFindFirstArgs<ExtArgs>>): Prisma__UploadedImageClient<$Result.GetResult<Prisma.$UploadedImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UploadedImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedImageFindFirstOrThrowArgs} args - Arguments to find a UploadedImage
     * @example
     * // Get one UploadedImage
     * const uploadedImage = await prisma.uploadedImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UploadedImageFindFirstOrThrowArgs>(args?: SelectSubset<T, UploadedImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__UploadedImageClient<$Result.GetResult<Prisma.$UploadedImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UploadedImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UploadedImages
     * const uploadedImages = await prisma.uploadedImage.findMany()
     * 
     * // Get first 10 UploadedImages
     * const uploadedImages = await prisma.uploadedImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uploadedImageWithIdOnly = await prisma.uploadedImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UploadedImageFindManyArgs>(args?: SelectSubset<T, UploadedImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadedImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UploadedImage.
     * @param {UploadedImageCreateArgs} args - Arguments to create a UploadedImage.
     * @example
     * // Create one UploadedImage
     * const UploadedImage = await prisma.uploadedImage.create({
     *   data: {
     *     // ... data to create a UploadedImage
     *   }
     * })
     * 
     */
    create<T extends UploadedImageCreateArgs>(args: SelectSubset<T, UploadedImageCreateArgs<ExtArgs>>): Prisma__UploadedImageClient<$Result.GetResult<Prisma.$UploadedImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UploadedImages.
     * @param {UploadedImageCreateManyArgs} args - Arguments to create many UploadedImages.
     * @example
     * // Create many UploadedImages
     * const uploadedImage = await prisma.uploadedImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UploadedImageCreateManyArgs>(args?: SelectSubset<T, UploadedImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UploadedImages and returns the data saved in the database.
     * @param {UploadedImageCreateManyAndReturnArgs} args - Arguments to create many UploadedImages.
     * @example
     * // Create many UploadedImages
     * const uploadedImage = await prisma.uploadedImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UploadedImages and only return the `id`
     * const uploadedImageWithIdOnly = await prisma.uploadedImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UploadedImageCreateManyAndReturnArgs>(args?: SelectSubset<T, UploadedImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadedImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UploadedImage.
     * @param {UploadedImageDeleteArgs} args - Arguments to delete one UploadedImage.
     * @example
     * // Delete one UploadedImage
     * const UploadedImage = await prisma.uploadedImage.delete({
     *   where: {
     *     // ... filter to delete one UploadedImage
     *   }
     * })
     * 
     */
    delete<T extends UploadedImageDeleteArgs>(args: SelectSubset<T, UploadedImageDeleteArgs<ExtArgs>>): Prisma__UploadedImageClient<$Result.GetResult<Prisma.$UploadedImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UploadedImage.
     * @param {UploadedImageUpdateArgs} args - Arguments to update one UploadedImage.
     * @example
     * // Update one UploadedImage
     * const uploadedImage = await prisma.uploadedImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UploadedImageUpdateArgs>(args: SelectSubset<T, UploadedImageUpdateArgs<ExtArgs>>): Prisma__UploadedImageClient<$Result.GetResult<Prisma.$UploadedImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UploadedImages.
     * @param {UploadedImageDeleteManyArgs} args - Arguments to filter UploadedImages to delete.
     * @example
     * // Delete a few UploadedImages
     * const { count } = await prisma.uploadedImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UploadedImageDeleteManyArgs>(args?: SelectSubset<T, UploadedImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UploadedImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UploadedImages
     * const uploadedImage = await prisma.uploadedImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UploadedImageUpdateManyArgs>(args: SelectSubset<T, UploadedImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UploadedImage.
     * @param {UploadedImageUpsertArgs} args - Arguments to update or create a UploadedImage.
     * @example
     * // Update or create a UploadedImage
     * const uploadedImage = await prisma.uploadedImage.upsert({
     *   create: {
     *     // ... data to create a UploadedImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UploadedImage we want to update
     *   }
     * })
     */
    upsert<T extends UploadedImageUpsertArgs>(args: SelectSubset<T, UploadedImageUpsertArgs<ExtArgs>>): Prisma__UploadedImageClient<$Result.GetResult<Prisma.$UploadedImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UploadedImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedImageCountArgs} args - Arguments to filter UploadedImages to count.
     * @example
     * // Count the number of UploadedImages
     * const count = await prisma.uploadedImage.count({
     *   where: {
     *     // ... the filter for the UploadedImages we want to count
     *   }
     * })
    **/
    count<T extends UploadedImageCountArgs>(
      args?: Subset<T, UploadedImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UploadedImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UploadedImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UploadedImageAggregateArgs>(args: Subset<T, UploadedImageAggregateArgs>): Prisma.PrismaPromise<GetUploadedImageAggregateType<T>>

    /**
     * Group by UploadedImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UploadedImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UploadedImageGroupByArgs['orderBy'] }
        : { orderBy?: UploadedImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UploadedImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUploadedImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UploadedImage model
   */
  readonly fields: UploadedImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UploadedImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UploadedImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    analyses<T extends UploadedImage$analysesArgs<ExtArgs> = {}>(args?: Subset<T, UploadedImage$analysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchAnalysisPayload<ExtArgs>, T, "findMany"> | Null>
    project<T extends UploadedImage$projectArgs<ExtArgs> = {}>(args?: Subset<T, UploadedImage$projectArgs<ExtArgs>>): Prisma__ResearchProjectClient<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UploadedImage model
   */ 
  interface UploadedImageFieldRefs {
    readonly id: FieldRef<"UploadedImage", 'String'>
    readonly projectId: FieldRef<"UploadedImage", 'String'>
    readonly uploadedById: FieldRef<"UploadedImage", 'String'>
    readonly fileName: FieldRef<"UploadedImage", 'String'>
    readonly originalFileName: FieldRef<"UploadedImage", 'String'>
    readonly filePath: FieldRef<"UploadedImage", 'String'>
    readonly fileSize: FieldRef<"UploadedImage", 'BigInt'>
    readonly mimeType: FieldRef<"UploadedImage", 'String'>
    readonly imageType: FieldRef<"UploadedImage", 'String'>
    readonly imageConfidence: FieldRef<"UploadedImage", 'Decimal'>
    readonly width: FieldRef<"UploadedImage", 'Int'>
    readonly height: FieldRef<"UploadedImage", 'Int'>
    readonly colorDepth: FieldRef<"UploadedImage", 'Int'>
    readonly hasMetadata: FieldRef<"UploadedImage", 'Boolean'>
    readonly dicomMetadata: FieldRef<"UploadedImage", 'Json'>
    readonly analysisStatus: FieldRef<"UploadedImage", 'AnalysisStatus'>
    readonly tags: FieldRef<"UploadedImage", 'String[]'>
    readonly description: FieldRef<"UploadedImage", 'String'>
    readonly consentObtained: FieldRef<"UploadedImage", 'Boolean'>
    readonly dataClassification: FieldRef<"UploadedImage", 'String'>
    readonly anonymized: FieldRef<"UploadedImage", 'Boolean'>
    readonly processingStartedAt: FieldRef<"UploadedImage", 'DateTime'>
    readonly processingCompletedAt: FieldRef<"UploadedImage", 'DateTime'>
    readonly createdAt: FieldRef<"UploadedImage", 'DateTime'>
    readonly updatedAt: FieldRef<"UploadedImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UploadedImage findUnique
   */
  export type UploadedImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedImage
     */
    select?: UploadedImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedImageInclude<ExtArgs> | null
    /**
     * Filter, which UploadedImage to fetch.
     */
    where: UploadedImageWhereUniqueInput
  }

  /**
   * UploadedImage findUniqueOrThrow
   */
  export type UploadedImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedImage
     */
    select?: UploadedImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedImageInclude<ExtArgs> | null
    /**
     * Filter, which UploadedImage to fetch.
     */
    where: UploadedImageWhereUniqueInput
  }

  /**
   * UploadedImage findFirst
   */
  export type UploadedImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedImage
     */
    select?: UploadedImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedImageInclude<ExtArgs> | null
    /**
     * Filter, which UploadedImage to fetch.
     */
    where?: UploadedImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedImages to fetch.
     */
    orderBy?: UploadedImageOrderByWithRelationInput | UploadedImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UploadedImages.
     */
    cursor?: UploadedImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UploadedImages.
     */
    distinct?: UploadedImageScalarFieldEnum | UploadedImageScalarFieldEnum[]
  }

  /**
   * UploadedImage findFirstOrThrow
   */
  export type UploadedImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedImage
     */
    select?: UploadedImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedImageInclude<ExtArgs> | null
    /**
     * Filter, which UploadedImage to fetch.
     */
    where?: UploadedImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedImages to fetch.
     */
    orderBy?: UploadedImageOrderByWithRelationInput | UploadedImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UploadedImages.
     */
    cursor?: UploadedImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UploadedImages.
     */
    distinct?: UploadedImageScalarFieldEnum | UploadedImageScalarFieldEnum[]
  }

  /**
   * UploadedImage findMany
   */
  export type UploadedImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedImage
     */
    select?: UploadedImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedImageInclude<ExtArgs> | null
    /**
     * Filter, which UploadedImages to fetch.
     */
    where?: UploadedImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedImages to fetch.
     */
    orderBy?: UploadedImageOrderByWithRelationInput | UploadedImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UploadedImages.
     */
    cursor?: UploadedImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedImages.
     */
    skip?: number
    distinct?: UploadedImageScalarFieldEnum | UploadedImageScalarFieldEnum[]
  }

  /**
   * UploadedImage create
   */
  export type UploadedImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedImage
     */
    select?: UploadedImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedImageInclude<ExtArgs> | null
    /**
     * The data needed to create a UploadedImage.
     */
    data: XOR<UploadedImageCreateInput, UploadedImageUncheckedCreateInput>
  }

  /**
   * UploadedImage createMany
   */
  export type UploadedImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UploadedImages.
     */
    data: UploadedImageCreateManyInput | UploadedImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UploadedImage createManyAndReturn
   */
  export type UploadedImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedImage
     */
    select?: UploadedImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UploadedImages.
     */
    data: UploadedImageCreateManyInput | UploadedImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UploadedImage update
   */
  export type UploadedImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedImage
     */
    select?: UploadedImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedImageInclude<ExtArgs> | null
    /**
     * The data needed to update a UploadedImage.
     */
    data: XOR<UploadedImageUpdateInput, UploadedImageUncheckedUpdateInput>
    /**
     * Choose, which UploadedImage to update.
     */
    where: UploadedImageWhereUniqueInput
  }

  /**
   * UploadedImage updateMany
   */
  export type UploadedImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UploadedImages.
     */
    data: XOR<UploadedImageUpdateManyMutationInput, UploadedImageUncheckedUpdateManyInput>
    /**
     * Filter which UploadedImages to update
     */
    where?: UploadedImageWhereInput
  }

  /**
   * UploadedImage upsert
   */
  export type UploadedImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedImage
     */
    select?: UploadedImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedImageInclude<ExtArgs> | null
    /**
     * The filter to search for the UploadedImage to update in case it exists.
     */
    where: UploadedImageWhereUniqueInput
    /**
     * In case the UploadedImage found by the `where` argument doesn't exist, create a new UploadedImage with this data.
     */
    create: XOR<UploadedImageCreateInput, UploadedImageUncheckedCreateInput>
    /**
     * In case the UploadedImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UploadedImageUpdateInput, UploadedImageUncheckedUpdateInput>
  }

  /**
   * UploadedImage delete
   */
  export type UploadedImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedImage
     */
    select?: UploadedImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedImageInclude<ExtArgs> | null
    /**
     * Filter which UploadedImage to delete.
     */
    where: UploadedImageWhereUniqueInput
  }

  /**
   * UploadedImage deleteMany
   */
  export type UploadedImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UploadedImages to delete
     */
    where?: UploadedImageWhereInput
  }

  /**
   * UploadedImage.analyses
   */
  export type UploadedImage$analysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchAnalysis
     */
    select?: ResearchAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchAnalysisInclude<ExtArgs> | null
    where?: ResearchAnalysisWhereInput
    orderBy?: ResearchAnalysisOrderByWithRelationInput | ResearchAnalysisOrderByWithRelationInput[]
    cursor?: ResearchAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchAnalysisScalarFieldEnum | ResearchAnalysisScalarFieldEnum[]
  }

  /**
   * UploadedImage.project
   */
  export type UploadedImage$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProject
     */
    select?: ResearchProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectInclude<ExtArgs> | null
    where?: ResearchProjectWhereInput
  }

  /**
   * UploadedImage without action
   */
  export type UploadedImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedImage
     */
    select?: UploadedImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedImageInclude<ExtArgs> | null
  }


  /**
   * Model ResearchAnalysis
   */

  export type AggregateResearchAnalysis = {
    _count: ResearchAnalysisCountAggregateOutputType | null
    _avg: ResearchAnalysisAvgAggregateOutputType | null
    _sum: ResearchAnalysisSumAggregateOutputType | null
    _min: ResearchAnalysisMinAggregateOutputType | null
    _max: ResearchAnalysisMaxAggregateOutputType | null
  }

  export type ResearchAnalysisAvgAggregateOutputType = {
    confidenceScore: Decimal | null
    processingTimeSeconds: number | null
  }

  export type ResearchAnalysisSumAggregateOutputType = {
    confidenceScore: Decimal | null
    processingTimeSeconds: number | null
  }

  export type ResearchAnalysisMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    imageId: string | null
    analystId: string | null
    analysisType: string | null
    status: $Enums.AnalysisStatus | null
    confidenceScore: Decimal | null
    processingTimeSeconds: number | null
    algorithmVersion: string | null
    modelUsed: string | null
    errorMessage: string | null
    reviewRequired: boolean | null
    reviewedById: string | null
    reviewedAt: Date | null
    reviewNotes: string | null
    approvedById: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResearchAnalysisMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    imageId: string | null
    analystId: string | null
    analysisType: string | null
    status: $Enums.AnalysisStatus | null
    confidenceScore: Decimal | null
    processingTimeSeconds: number | null
    algorithmVersion: string | null
    modelUsed: string | null
    errorMessage: string | null
    reviewRequired: boolean | null
    reviewedById: string | null
    reviewedAt: Date | null
    reviewNotes: string | null
    approvedById: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResearchAnalysisCountAggregateOutputType = {
    id: number
    projectId: number
    imageId: number
    analystId: number
    analysisType: number
    status: number
    confidenceScore: number
    processingTimeSeconds: number
    algorithmVersion: number
    modelUsed: number
    findings: number
    recommendations: number
    differentialDiagnosis: number
    severityAssessment: number
    regionsOfInterest: number
    qualityMetrics: number
    errorMessage: number
    reviewRequired: number
    reviewedById: number
    reviewedAt: number
    reviewNotes: number
    approvedById: number
    approvedAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResearchAnalysisAvgAggregateInputType = {
    confidenceScore?: true
    processingTimeSeconds?: true
  }

  export type ResearchAnalysisSumAggregateInputType = {
    confidenceScore?: true
    processingTimeSeconds?: true
  }

  export type ResearchAnalysisMinAggregateInputType = {
    id?: true
    projectId?: true
    imageId?: true
    analystId?: true
    analysisType?: true
    status?: true
    confidenceScore?: true
    processingTimeSeconds?: true
    algorithmVersion?: true
    modelUsed?: true
    errorMessage?: true
    reviewRequired?: true
    reviewedById?: true
    reviewedAt?: true
    reviewNotes?: true
    approvedById?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResearchAnalysisMaxAggregateInputType = {
    id?: true
    projectId?: true
    imageId?: true
    analystId?: true
    analysisType?: true
    status?: true
    confidenceScore?: true
    processingTimeSeconds?: true
    algorithmVersion?: true
    modelUsed?: true
    errorMessage?: true
    reviewRequired?: true
    reviewedById?: true
    reviewedAt?: true
    reviewNotes?: true
    approvedById?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResearchAnalysisCountAggregateInputType = {
    id?: true
    projectId?: true
    imageId?: true
    analystId?: true
    analysisType?: true
    status?: true
    confidenceScore?: true
    processingTimeSeconds?: true
    algorithmVersion?: true
    modelUsed?: true
    findings?: true
    recommendations?: true
    differentialDiagnosis?: true
    severityAssessment?: true
    regionsOfInterest?: true
    qualityMetrics?: true
    errorMessage?: true
    reviewRequired?: true
    reviewedById?: true
    reviewedAt?: true
    reviewNotes?: true
    approvedById?: true
    approvedAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResearchAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchAnalysis to aggregate.
     */
    where?: ResearchAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchAnalyses to fetch.
     */
    orderBy?: ResearchAnalysisOrderByWithRelationInput | ResearchAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResearchAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResearchAnalyses
    **/
    _count?: true | ResearchAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResearchAnalysisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResearchAnalysisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResearchAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResearchAnalysisMaxAggregateInputType
  }

  export type GetResearchAnalysisAggregateType<T extends ResearchAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateResearchAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResearchAnalysis[P]>
      : GetScalarType<T[P], AggregateResearchAnalysis[P]>
  }




  export type ResearchAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchAnalysisWhereInput
    orderBy?: ResearchAnalysisOrderByWithAggregationInput | ResearchAnalysisOrderByWithAggregationInput[]
    by: ResearchAnalysisScalarFieldEnum[] | ResearchAnalysisScalarFieldEnum
    having?: ResearchAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResearchAnalysisCountAggregateInputType | true
    _avg?: ResearchAnalysisAvgAggregateInputType
    _sum?: ResearchAnalysisSumAggregateInputType
    _min?: ResearchAnalysisMinAggregateInputType
    _max?: ResearchAnalysisMaxAggregateInputType
  }

  export type ResearchAnalysisGroupByOutputType = {
    id: string
    projectId: string | null
    imageId: string | null
    analystId: string
    analysisType: string
    status: $Enums.AnalysisStatus
    confidenceScore: Decimal | null
    processingTimeSeconds: number | null
    algorithmVersion: string | null
    modelUsed: string | null
    findings: JsonValue | null
    recommendations: JsonValue | null
    differentialDiagnosis: JsonValue | null
    severityAssessment: JsonValue | null
    regionsOfInterest: JsonValue | null
    qualityMetrics: JsonValue | null
    errorMessage: string | null
    reviewRequired: boolean
    reviewedById: string | null
    reviewedAt: Date | null
    reviewNotes: string | null
    approvedById: string | null
    approvedAt: Date | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ResearchAnalysisCountAggregateOutputType | null
    _avg: ResearchAnalysisAvgAggregateOutputType | null
    _sum: ResearchAnalysisSumAggregateOutputType | null
    _min: ResearchAnalysisMinAggregateOutputType | null
    _max: ResearchAnalysisMaxAggregateOutputType | null
  }

  type GetResearchAnalysisGroupByPayload<T extends ResearchAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResearchAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResearchAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResearchAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], ResearchAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type ResearchAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    imageId?: boolean
    analystId?: boolean
    analysisType?: boolean
    status?: boolean
    confidenceScore?: boolean
    processingTimeSeconds?: boolean
    algorithmVersion?: boolean
    modelUsed?: boolean
    findings?: boolean
    recommendations?: boolean
    differentialDiagnosis?: boolean
    severityAssessment?: boolean
    regionsOfInterest?: boolean
    qualityMetrics?: boolean
    errorMessage?: boolean
    reviewRequired?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    reviewNotes?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    analyst?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | ResearchAnalysis$approvedByArgs<ExtArgs>
    image?: boolean | ResearchAnalysis$imageArgs<ExtArgs>
    project?: boolean | ResearchAnalysis$projectArgs<ExtArgs>
    reviewedBy?: boolean | ResearchAnalysis$reviewedByArgs<ExtArgs>
  }, ExtArgs["result"]["researchAnalysis"]>

  export type ResearchAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    imageId?: boolean
    analystId?: boolean
    analysisType?: boolean
    status?: boolean
    confidenceScore?: boolean
    processingTimeSeconds?: boolean
    algorithmVersion?: boolean
    modelUsed?: boolean
    findings?: boolean
    recommendations?: boolean
    differentialDiagnosis?: boolean
    severityAssessment?: boolean
    regionsOfInterest?: boolean
    qualityMetrics?: boolean
    errorMessage?: boolean
    reviewRequired?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    reviewNotes?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    analyst?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | ResearchAnalysis$approvedByArgs<ExtArgs>
    image?: boolean | ResearchAnalysis$imageArgs<ExtArgs>
    project?: boolean | ResearchAnalysis$projectArgs<ExtArgs>
    reviewedBy?: boolean | ResearchAnalysis$reviewedByArgs<ExtArgs>
  }, ExtArgs["result"]["researchAnalysis"]>

  export type ResearchAnalysisSelectScalar = {
    id?: boolean
    projectId?: boolean
    imageId?: boolean
    analystId?: boolean
    analysisType?: boolean
    status?: boolean
    confidenceScore?: boolean
    processingTimeSeconds?: boolean
    algorithmVersion?: boolean
    modelUsed?: boolean
    findings?: boolean
    recommendations?: boolean
    differentialDiagnosis?: boolean
    severityAssessment?: boolean
    regionsOfInterest?: boolean
    qualityMetrics?: boolean
    errorMessage?: boolean
    reviewRequired?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    reviewNotes?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResearchAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analyst?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | ResearchAnalysis$approvedByArgs<ExtArgs>
    image?: boolean | ResearchAnalysis$imageArgs<ExtArgs>
    project?: boolean | ResearchAnalysis$projectArgs<ExtArgs>
    reviewedBy?: boolean | ResearchAnalysis$reviewedByArgs<ExtArgs>
  }
  export type ResearchAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analyst?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | ResearchAnalysis$approvedByArgs<ExtArgs>
    image?: boolean | ResearchAnalysis$imageArgs<ExtArgs>
    project?: boolean | ResearchAnalysis$projectArgs<ExtArgs>
    reviewedBy?: boolean | ResearchAnalysis$reviewedByArgs<ExtArgs>
  }

  export type $ResearchAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResearchAnalysis"
    objects: {
      analyst: Prisma.$UserPayload<ExtArgs>
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
      image: Prisma.$UploadedImagePayload<ExtArgs> | null
      project: Prisma.$ResearchProjectPayload<ExtArgs> | null
      reviewedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string | null
      imageId: string | null
      analystId: string
      analysisType: string
      status: $Enums.AnalysisStatus
      confidenceScore: Prisma.Decimal | null
      processingTimeSeconds: number | null
      algorithmVersion: string | null
      modelUsed: string | null
      findings: Prisma.JsonValue | null
      recommendations: Prisma.JsonValue | null
      differentialDiagnosis: Prisma.JsonValue | null
      severityAssessment: Prisma.JsonValue | null
      regionsOfInterest: Prisma.JsonValue | null
      qualityMetrics: Prisma.JsonValue | null
      errorMessage: string | null
      reviewRequired: boolean
      reviewedById: string | null
      reviewedAt: Date | null
      reviewNotes: string | null
      approvedById: string | null
      approvedAt: Date | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["researchAnalysis"]>
    composites: {}
  }

  type ResearchAnalysisGetPayload<S extends boolean | null | undefined | ResearchAnalysisDefaultArgs> = $Result.GetResult<Prisma.$ResearchAnalysisPayload, S>

  type ResearchAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResearchAnalysisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResearchAnalysisCountAggregateInputType | true
    }

  export interface ResearchAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResearchAnalysis'], meta: { name: 'ResearchAnalysis' } }
    /**
     * Find zero or one ResearchAnalysis that matches the filter.
     * @param {ResearchAnalysisFindUniqueArgs} args - Arguments to find a ResearchAnalysis
     * @example
     * // Get one ResearchAnalysis
     * const researchAnalysis = await prisma.researchAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResearchAnalysisFindUniqueArgs>(args: SelectSubset<T, ResearchAnalysisFindUniqueArgs<ExtArgs>>): Prisma__ResearchAnalysisClient<$Result.GetResult<Prisma.$ResearchAnalysisPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ResearchAnalysis that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResearchAnalysisFindUniqueOrThrowArgs} args - Arguments to find a ResearchAnalysis
     * @example
     * // Get one ResearchAnalysis
     * const researchAnalysis = await prisma.researchAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResearchAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, ResearchAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResearchAnalysisClient<$Result.GetResult<Prisma.$ResearchAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ResearchAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchAnalysisFindFirstArgs} args - Arguments to find a ResearchAnalysis
     * @example
     * // Get one ResearchAnalysis
     * const researchAnalysis = await prisma.researchAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResearchAnalysisFindFirstArgs>(args?: SelectSubset<T, ResearchAnalysisFindFirstArgs<ExtArgs>>): Prisma__ResearchAnalysisClient<$Result.GetResult<Prisma.$ResearchAnalysisPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ResearchAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchAnalysisFindFirstOrThrowArgs} args - Arguments to find a ResearchAnalysis
     * @example
     * // Get one ResearchAnalysis
     * const researchAnalysis = await prisma.researchAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResearchAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, ResearchAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResearchAnalysisClient<$Result.GetResult<Prisma.$ResearchAnalysisPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ResearchAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResearchAnalyses
     * const researchAnalyses = await prisma.researchAnalysis.findMany()
     * 
     * // Get first 10 ResearchAnalyses
     * const researchAnalyses = await prisma.researchAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const researchAnalysisWithIdOnly = await prisma.researchAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResearchAnalysisFindManyArgs>(args?: SelectSubset<T, ResearchAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchAnalysisPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ResearchAnalysis.
     * @param {ResearchAnalysisCreateArgs} args - Arguments to create a ResearchAnalysis.
     * @example
     * // Create one ResearchAnalysis
     * const ResearchAnalysis = await prisma.researchAnalysis.create({
     *   data: {
     *     // ... data to create a ResearchAnalysis
     *   }
     * })
     * 
     */
    create<T extends ResearchAnalysisCreateArgs>(args: SelectSubset<T, ResearchAnalysisCreateArgs<ExtArgs>>): Prisma__ResearchAnalysisClient<$Result.GetResult<Prisma.$ResearchAnalysisPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ResearchAnalyses.
     * @param {ResearchAnalysisCreateManyArgs} args - Arguments to create many ResearchAnalyses.
     * @example
     * // Create many ResearchAnalyses
     * const researchAnalysis = await prisma.researchAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResearchAnalysisCreateManyArgs>(args?: SelectSubset<T, ResearchAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResearchAnalyses and returns the data saved in the database.
     * @param {ResearchAnalysisCreateManyAndReturnArgs} args - Arguments to create many ResearchAnalyses.
     * @example
     * // Create many ResearchAnalyses
     * const researchAnalysis = await prisma.researchAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResearchAnalyses and only return the `id`
     * const researchAnalysisWithIdOnly = await prisma.researchAnalysis.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResearchAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, ResearchAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchAnalysisPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ResearchAnalysis.
     * @param {ResearchAnalysisDeleteArgs} args - Arguments to delete one ResearchAnalysis.
     * @example
     * // Delete one ResearchAnalysis
     * const ResearchAnalysis = await prisma.researchAnalysis.delete({
     *   where: {
     *     // ... filter to delete one ResearchAnalysis
     *   }
     * })
     * 
     */
    delete<T extends ResearchAnalysisDeleteArgs>(args: SelectSubset<T, ResearchAnalysisDeleteArgs<ExtArgs>>): Prisma__ResearchAnalysisClient<$Result.GetResult<Prisma.$ResearchAnalysisPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ResearchAnalysis.
     * @param {ResearchAnalysisUpdateArgs} args - Arguments to update one ResearchAnalysis.
     * @example
     * // Update one ResearchAnalysis
     * const researchAnalysis = await prisma.researchAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResearchAnalysisUpdateArgs>(args: SelectSubset<T, ResearchAnalysisUpdateArgs<ExtArgs>>): Prisma__ResearchAnalysisClient<$Result.GetResult<Prisma.$ResearchAnalysisPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ResearchAnalyses.
     * @param {ResearchAnalysisDeleteManyArgs} args - Arguments to filter ResearchAnalyses to delete.
     * @example
     * // Delete a few ResearchAnalyses
     * const { count } = await prisma.researchAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResearchAnalysisDeleteManyArgs>(args?: SelectSubset<T, ResearchAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResearchAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResearchAnalyses
     * const researchAnalysis = await prisma.researchAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResearchAnalysisUpdateManyArgs>(args: SelectSubset<T, ResearchAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResearchAnalysis.
     * @param {ResearchAnalysisUpsertArgs} args - Arguments to update or create a ResearchAnalysis.
     * @example
     * // Update or create a ResearchAnalysis
     * const researchAnalysis = await prisma.researchAnalysis.upsert({
     *   create: {
     *     // ... data to create a ResearchAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResearchAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends ResearchAnalysisUpsertArgs>(args: SelectSubset<T, ResearchAnalysisUpsertArgs<ExtArgs>>): Prisma__ResearchAnalysisClient<$Result.GetResult<Prisma.$ResearchAnalysisPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ResearchAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchAnalysisCountArgs} args - Arguments to filter ResearchAnalyses to count.
     * @example
     * // Count the number of ResearchAnalyses
     * const count = await prisma.researchAnalysis.count({
     *   where: {
     *     // ... the filter for the ResearchAnalyses we want to count
     *   }
     * })
    **/
    count<T extends ResearchAnalysisCountArgs>(
      args?: Subset<T, ResearchAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResearchAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResearchAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResearchAnalysisAggregateArgs>(args: Subset<T, ResearchAnalysisAggregateArgs>): Prisma.PrismaPromise<GetResearchAnalysisAggregateType<T>>

    /**
     * Group by ResearchAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResearchAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResearchAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: ResearchAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResearchAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResearchAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResearchAnalysis model
   */
  readonly fields: ResearchAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResearchAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResearchAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    analyst<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approvedBy<T extends ResearchAnalysis$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, ResearchAnalysis$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    image<T extends ResearchAnalysis$imageArgs<ExtArgs> = {}>(args?: Subset<T, ResearchAnalysis$imageArgs<ExtArgs>>): Prisma__UploadedImageClient<$Result.GetResult<Prisma.$UploadedImagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    project<T extends ResearchAnalysis$projectArgs<ExtArgs> = {}>(args?: Subset<T, ResearchAnalysis$projectArgs<ExtArgs>>): Prisma__ResearchProjectClient<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reviewedBy<T extends ResearchAnalysis$reviewedByArgs<ExtArgs> = {}>(args?: Subset<T, ResearchAnalysis$reviewedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResearchAnalysis model
   */ 
  interface ResearchAnalysisFieldRefs {
    readonly id: FieldRef<"ResearchAnalysis", 'String'>
    readonly projectId: FieldRef<"ResearchAnalysis", 'String'>
    readonly imageId: FieldRef<"ResearchAnalysis", 'String'>
    readonly analystId: FieldRef<"ResearchAnalysis", 'String'>
    readonly analysisType: FieldRef<"ResearchAnalysis", 'String'>
    readonly status: FieldRef<"ResearchAnalysis", 'AnalysisStatus'>
    readonly confidenceScore: FieldRef<"ResearchAnalysis", 'Decimal'>
    readonly processingTimeSeconds: FieldRef<"ResearchAnalysis", 'Int'>
    readonly algorithmVersion: FieldRef<"ResearchAnalysis", 'String'>
    readonly modelUsed: FieldRef<"ResearchAnalysis", 'String'>
    readonly findings: FieldRef<"ResearchAnalysis", 'Json'>
    readonly recommendations: FieldRef<"ResearchAnalysis", 'Json'>
    readonly differentialDiagnosis: FieldRef<"ResearchAnalysis", 'Json'>
    readonly severityAssessment: FieldRef<"ResearchAnalysis", 'Json'>
    readonly regionsOfInterest: FieldRef<"ResearchAnalysis", 'Json'>
    readonly qualityMetrics: FieldRef<"ResearchAnalysis", 'Json'>
    readonly errorMessage: FieldRef<"ResearchAnalysis", 'String'>
    readonly reviewRequired: FieldRef<"ResearchAnalysis", 'Boolean'>
    readonly reviewedById: FieldRef<"ResearchAnalysis", 'String'>
    readonly reviewedAt: FieldRef<"ResearchAnalysis", 'DateTime'>
    readonly reviewNotes: FieldRef<"ResearchAnalysis", 'String'>
    readonly approvedById: FieldRef<"ResearchAnalysis", 'String'>
    readonly approvedAt: FieldRef<"ResearchAnalysis", 'DateTime'>
    readonly metadata: FieldRef<"ResearchAnalysis", 'Json'>
    readonly createdAt: FieldRef<"ResearchAnalysis", 'DateTime'>
    readonly updatedAt: FieldRef<"ResearchAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResearchAnalysis findUnique
   */
  export type ResearchAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchAnalysis
     */
    select?: ResearchAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which ResearchAnalysis to fetch.
     */
    where: ResearchAnalysisWhereUniqueInput
  }

  /**
   * ResearchAnalysis findUniqueOrThrow
   */
  export type ResearchAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchAnalysis
     */
    select?: ResearchAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which ResearchAnalysis to fetch.
     */
    where: ResearchAnalysisWhereUniqueInput
  }

  /**
   * ResearchAnalysis findFirst
   */
  export type ResearchAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchAnalysis
     */
    select?: ResearchAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which ResearchAnalysis to fetch.
     */
    where?: ResearchAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchAnalyses to fetch.
     */
    orderBy?: ResearchAnalysisOrderByWithRelationInput | ResearchAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchAnalyses.
     */
    cursor?: ResearchAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchAnalyses.
     */
    distinct?: ResearchAnalysisScalarFieldEnum | ResearchAnalysisScalarFieldEnum[]
  }

  /**
   * ResearchAnalysis findFirstOrThrow
   */
  export type ResearchAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchAnalysis
     */
    select?: ResearchAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which ResearchAnalysis to fetch.
     */
    where?: ResearchAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchAnalyses to fetch.
     */
    orderBy?: ResearchAnalysisOrderByWithRelationInput | ResearchAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchAnalyses.
     */
    cursor?: ResearchAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchAnalyses.
     */
    distinct?: ResearchAnalysisScalarFieldEnum | ResearchAnalysisScalarFieldEnum[]
  }

  /**
   * ResearchAnalysis findMany
   */
  export type ResearchAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchAnalysis
     */
    select?: ResearchAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which ResearchAnalyses to fetch.
     */
    where?: ResearchAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchAnalyses to fetch.
     */
    orderBy?: ResearchAnalysisOrderByWithRelationInput | ResearchAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResearchAnalyses.
     */
    cursor?: ResearchAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchAnalyses.
     */
    skip?: number
    distinct?: ResearchAnalysisScalarFieldEnum | ResearchAnalysisScalarFieldEnum[]
  }

  /**
   * ResearchAnalysis create
   */
  export type ResearchAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchAnalysis
     */
    select?: ResearchAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a ResearchAnalysis.
     */
    data: XOR<ResearchAnalysisCreateInput, ResearchAnalysisUncheckedCreateInput>
  }

  /**
   * ResearchAnalysis createMany
   */
  export type ResearchAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResearchAnalyses.
     */
    data: ResearchAnalysisCreateManyInput | ResearchAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResearchAnalysis createManyAndReturn
   */
  export type ResearchAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchAnalysis
     */
    select?: ResearchAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ResearchAnalyses.
     */
    data: ResearchAnalysisCreateManyInput | ResearchAnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResearchAnalysis update
   */
  export type ResearchAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchAnalysis
     */
    select?: ResearchAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a ResearchAnalysis.
     */
    data: XOR<ResearchAnalysisUpdateInput, ResearchAnalysisUncheckedUpdateInput>
    /**
     * Choose, which ResearchAnalysis to update.
     */
    where: ResearchAnalysisWhereUniqueInput
  }

  /**
   * ResearchAnalysis updateMany
   */
  export type ResearchAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResearchAnalyses.
     */
    data: XOR<ResearchAnalysisUpdateManyMutationInput, ResearchAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which ResearchAnalyses to update
     */
    where?: ResearchAnalysisWhereInput
  }

  /**
   * ResearchAnalysis upsert
   */
  export type ResearchAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchAnalysis
     */
    select?: ResearchAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the ResearchAnalysis to update in case it exists.
     */
    where: ResearchAnalysisWhereUniqueInput
    /**
     * In case the ResearchAnalysis found by the `where` argument doesn't exist, create a new ResearchAnalysis with this data.
     */
    create: XOR<ResearchAnalysisCreateInput, ResearchAnalysisUncheckedCreateInput>
    /**
     * In case the ResearchAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResearchAnalysisUpdateInput, ResearchAnalysisUncheckedUpdateInput>
  }

  /**
   * ResearchAnalysis delete
   */
  export type ResearchAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchAnalysis
     */
    select?: ResearchAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchAnalysisInclude<ExtArgs> | null
    /**
     * Filter which ResearchAnalysis to delete.
     */
    where: ResearchAnalysisWhereUniqueInput
  }

  /**
   * ResearchAnalysis deleteMany
   */
  export type ResearchAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchAnalyses to delete
     */
    where?: ResearchAnalysisWhereInput
  }

  /**
   * ResearchAnalysis.approvedBy
   */
  export type ResearchAnalysis$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ResearchAnalysis.image
   */
  export type ResearchAnalysis$imageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedImage
     */
    select?: UploadedImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedImageInclude<ExtArgs> | null
    where?: UploadedImageWhereInput
  }

  /**
   * ResearchAnalysis.project
   */
  export type ResearchAnalysis$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProject
     */
    select?: ResearchProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProjectInclude<ExtArgs> | null
    where?: ResearchProjectWhereInput
  }

  /**
   * ResearchAnalysis.reviewedBy
   */
  export type ResearchAnalysis$reviewedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ResearchAnalysis without action
   */
  export type ResearchAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchAnalysis
     */
    select?: ResearchAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeIntegration
   */

  export type AggregateKnowledgeIntegration = {
    _count: KnowledgeIntegrationCountAggregateOutputType | null
    _avg: KnowledgeIntegrationAvgAggregateOutputType | null
    _sum: KnowledgeIntegrationSumAggregateOutputType | null
    _min: KnowledgeIntegrationMinAggregateOutputType | null
    _max: KnowledgeIntegrationMaxAggregateOutputType | null
  }

  export type KnowledgeIntegrationAvgAggregateOutputType = {
    noveltyScore: Decimal | null
  }

  export type KnowledgeIntegrationSumAggregateOutputType = {
    noveltyScore: Decimal | null
  }

  export type KnowledgeIntegrationMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    sourceDisciplineId: string | null
    targetDisciplineId: string | null
    integrationType: $Enums.KnowledgeIntegrationType | null
    title: string | null
    description: string | null
    sourceKnowledge: string | null
    targetApplication: string | null
    integrationMethod: string | null
    validationStatus: string | null
    validationNotes: string | null
    noveltyScore: Decimal | null
    impactPotential: string | null
    implementationFeasibility: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeIntegrationMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    sourceDisciplineId: string | null
    targetDisciplineId: string | null
    integrationType: $Enums.KnowledgeIntegrationType | null
    title: string | null
    description: string | null
    sourceKnowledge: string | null
    targetApplication: string | null
    integrationMethod: string | null
    validationStatus: string | null
    validationNotes: string | null
    noveltyScore: Decimal | null
    impactPotential: string | null
    implementationFeasibility: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeIntegrationCountAggregateOutputType = {
    id: number
    projectId: number
    sourceDisciplineId: number
    targetDisciplineId: number
    integrationType: number
    title: number
    description: number
    sourceKnowledge: number
    targetApplication: number
    integrationMethod: number
    validationStatus: number
    validationNotes: number
    noveltyScore: number
    impactPotential: number
    implementationFeasibility: number
    references: number
    supportingEvidence: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KnowledgeIntegrationAvgAggregateInputType = {
    noveltyScore?: true
  }

  export type KnowledgeIntegrationSumAggregateInputType = {
    noveltyScore?: true
  }

  export type KnowledgeIntegrationMinAggregateInputType = {
    id?: true
    projectId?: true
    sourceDisciplineId?: true
    targetDisciplineId?: true
    integrationType?: true
    title?: true
    description?: true
    sourceKnowledge?: true
    targetApplication?: true
    integrationMethod?: true
    validationStatus?: true
    validationNotes?: true
    noveltyScore?: true
    impactPotential?: true
    implementationFeasibility?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeIntegrationMaxAggregateInputType = {
    id?: true
    projectId?: true
    sourceDisciplineId?: true
    targetDisciplineId?: true
    integrationType?: true
    title?: true
    description?: true
    sourceKnowledge?: true
    targetApplication?: true
    integrationMethod?: true
    validationStatus?: true
    validationNotes?: true
    noveltyScore?: true
    impactPotential?: true
    implementationFeasibility?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeIntegrationCountAggregateInputType = {
    id?: true
    projectId?: true
    sourceDisciplineId?: true
    targetDisciplineId?: true
    integrationType?: true
    title?: true
    description?: true
    sourceKnowledge?: true
    targetApplication?: true
    integrationMethod?: true
    validationStatus?: true
    validationNotes?: true
    noveltyScore?: true
    impactPotential?: true
    implementationFeasibility?: true
    references?: true
    supportingEvidence?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KnowledgeIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeIntegration to aggregate.
     */
    where?: KnowledgeIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeIntegrations to fetch.
     */
    orderBy?: KnowledgeIntegrationOrderByWithRelationInput | KnowledgeIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeIntegrations
    **/
    _count?: true | KnowledgeIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KnowledgeIntegrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KnowledgeIntegrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeIntegrationMaxAggregateInputType
  }

  export type GetKnowledgeIntegrationAggregateType<T extends KnowledgeIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeIntegration[P]>
      : GetScalarType<T[P], AggregateKnowledgeIntegration[P]>
  }




  export type KnowledgeIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeIntegrationWhereInput
    orderBy?: KnowledgeIntegrationOrderByWithAggregationInput | KnowledgeIntegrationOrderByWithAggregationInput[]
    by: KnowledgeIntegrationScalarFieldEnum[] | KnowledgeIntegrationScalarFieldEnum
    having?: KnowledgeIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeIntegrationCountAggregateInputType | true
    _avg?: KnowledgeIntegrationAvgAggregateInputType
    _sum?: KnowledgeIntegrationSumAggregateInputType
    _min?: KnowledgeIntegrationMinAggregateInputType
    _max?: KnowledgeIntegrationMaxAggregateInputType
  }

  export type KnowledgeIntegrationGroupByOutputType = {
    id: string
    projectId: string
    sourceDisciplineId: string
    targetDisciplineId: string
    integrationType: $Enums.KnowledgeIntegrationType
    title: string
    description: string | null
    sourceKnowledge: string | null
    targetApplication: string | null
    integrationMethod: string | null
    validationStatus: string
    validationNotes: string | null
    noveltyScore: Decimal | null
    impactPotential: string | null
    implementationFeasibility: string | null
    references: string[]
    supportingEvidence: JsonValue | null
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: KnowledgeIntegrationCountAggregateOutputType | null
    _avg: KnowledgeIntegrationAvgAggregateOutputType | null
    _sum: KnowledgeIntegrationSumAggregateOutputType | null
    _min: KnowledgeIntegrationMinAggregateOutputType | null
    _max: KnowledgeIntegrationMaxAggregateOutputType | null
  }

  type GetKnowledgeIntegrationGroupByPayload<T extends KnowledgeIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    sourceDisciplineId?: boolean
    targetDisciplineId?: boolean
    integrationType?: boolean
    title?: boolean
    description?: boolean
    sourceKnowledge?: boolean
    targetApplication?: boolean
    integrationMethod?: boolean
    validationStatus?: boolean
    validationNotes?: boolean
    noveltyScore?: boolean
    impactPotential?: boolean
    implementationFeasibility?: boolean
    references?: boolean
    supportingEvidence?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
    sourceDiscipline?: boolean | AcademicDisciplineDefaultArgs<ExtArgs>
    targetDiscipline?: boolean | AcademicDisciplineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeIntegration"]>

  export type KnowledgeIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    sourceDisciplineId?: boolean
    targetDisciplineId?: boolean
    integrationType?: boolean
    title?: boolean
    description?: boolean
    sourceKnowledge?: boolean
    targetApplication?: boolean
    integrationMethod?: boolean
    validationStatus?: boolean
    validationNotes?: boolean
    noveltyScore?: boolean
    impactPotential?: boolean
    implementationFeasibility?: boolean
    references?: boolean
    supportingEvidence?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
    sourceDiscipline?: boolean | AcademicDisciplineDefaultArgs<ExtArgs>
    targetDiscipline?: boolean | AcademicDisciplineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeIntegration"]>

  export type KnowledgeIntegrationSelectScalar = {
    id?: boolean
    projectId?: boolean
    sourceDisciplineId?: boolean
    targetDisciplineId?: boolean
    integrationType?: boolean
    title?: boolean
    description?: boolean
    sourceKnowledge?: boolean
    targetApplication?: boolean
    integrationMethod?: boolean
    validationStatus?: boolean
    validationNotes?: boolean
    noveltyScore?: boolean
    impactPotential?: boolean
    implementationFeasibility?: boolean
    references?: boolean
    supportingEvidence?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KnowledgeIntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
    sourceDiscipline?: boolean | AcademicDisciplineDefaultArgs<ExtArgs>
    targetDiscipline?: boolean | AcademicDisciplineDefaultArgs<ExtArgs>
  }
  export type KnowledgeIntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
    sourceDiscipline?: boolean | AcademicDisciplineDefaultArgs<ExtArgs>
    targetDiscipline?: boolean | AcademicDisciplineDefaultArgs<ExtArgs>
  }

  export type $KnowledgeIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeIntegration"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ResearchProjectPayload<ExtArgs>
      sourceDiscipline: Prisma.$AcademicDisciplinePayload<ExtArgs>
      targetDiscipline: Prisma.$AcademicDisciplinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      sourceDisciplineId: string
      targetDisciplineId: string
      integrationType: $Enums.KnowledgeIntegrationType
      title: string
      description: string | null
      sourceKnowledge: string | null
      targetApplication: string | null
      integrationMethod: string | null
      validationStatus: string
      validationNotes: string | null
      noveltyScore: Prisma.Decimal | null
      impactPotential: string | null
      implementationFeasibility: string | null
      references: string[]
      supportingEvidence: Prisma.JsonValue | null
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["knowledgeIntegration"]>
    composites: {}
  }

  type KnowledgeIntegrationGetPayload<S extends boolean | null | undefined | KnowledgeIntegrationDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeIntegrationPayload, S>

  type KnowledgeIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KnowledgeIntegrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KnowledgeIntegrationCountAggregateInputType | true
    }

  export interface KnowledgeIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeIntegration'], meta: { name: 'KnowledgeIntegration' } }
    /**
     * Find zero or one KnowledgeIntegration that matches the filter.
     * @param {KnowledgeIntegrationFindUniqueArgs} args - Arguments to find a KnowledgeIntegration
     * @example
     * // Get one KnowledgeIntegration
     * const knowledgeIntegration = await prisma.knowledgeIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeIntegrationFindUniqueArgs>(args: SelectSubset<T, KnowledgeIntegrationFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeIntegrationClient<$Result.GetResult<Prisma.$KnowledgeIntegrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KnowledgeIntegration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KnowledgeIntegrationFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeIntegration
     * @example
     * // Get one KnowledgeIntegration
     * const knowledgeIntegration = await prisma.knowledgeIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeIntegrationClient<$Result.GetResult<Prisma.$KnowledgeIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KnowledgeIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeIntegrationFindFirstArgs} args - Arguments to find a KnowledgeIntegration
     * @example
     * // Get one KnowledgeIntegration
     * const knowledgeIntegration = await prisma.knowledgeIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeIntegrationFindFirstArgs>(args?: SelectSubset<T, KnowledgeIntegrationFindFirstArgs<ExtArgs>>): Prisma__KnowledgeIntegrationClient<$Result.GetResult<Prisma.$KnowledgeIntegrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KnowledgeIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeIntegrationFindFirstOrThrowArgs} args - Arguments to find a KnowledgeIntegration
     * @example
     * // Get one KnowledgeIntegration
     * const knowledgeIntegration = await prisma.knowledgeIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeIntegrationClient<$Result.GetResult<Prisma.$KnowledgeIntegrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KnowledgeIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeIntegrations
     * const knowledgeIntegrations = await prisma.knowledgeIntegration.findMany()
     * 
     * // Get first 10 KnowledgeIntegrations
     * const knowledgeIntegrations = await prisma.knowledgeIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeIntegrationWithIdOnly = await prisma.knowledgeIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeIntegrationFindManyArgs>(args?: SelectSubset<T, KnowledgeIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeIntegrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KnowledgeIntegration.
     * @param {KnowledgeIntegrationCreateArgs} args - Arguments to create a KnowledgeIntegration.
     * @example
     * // Create one KnowledgeIntegration
     * const KnowledgeIntegration = await prisma.knowledgeIntegration.create({
     *   data: {
     *     // ... data to create a KnowledgeIntegration
     *   }
     * })
     * 
     */
    create<T extends KnowledgeIntegrationCreateArgs>(args: SelectSubset<T, KnowledgeIntegrationCreateArgs<ExtArgs>>): Prisma__KnowledgeIntegrationClient<$Result.GetResult<Prisma.$KnowledgeIntegrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KnowledgeIntegrations.
     * @param {KnowledgeIntegrationCreateManyArgs} args - Arguments to create many KnowledgeIntegrations.
     * @example
     * // Create many KnowledgeIntegrations
     * const knowledgeIntegration = await prisma.knowledgeIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeIntegrationCreateManyArgs>(args?: SelectSubset<T, KnowledgeIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeIntegrations and returns the data saved in the database.
     * @param {KnowledgeIntegrationCreateManyAndReturnArgs} args - Arguments to create many KnowledgeIntegrations.
     * @example
     * // Create many KnowledgeIntegrations
     * const knowledgeIntegration = await prisma.knowledgeIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeIntegrations and only return the `id`
     * const knowledgeIntegrationWithIdOnly = await prisma.knowledgeIntegration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeIntegrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KnowledgeIntegration.
     * @param {KnowledgeIntegrationDeleteArgs} args - Arguments to delete one KnowledgeIntegration.
     * @example
     * // Delete one KnowledgeIntegration
     * const KnowledgeIntegration = await prisma.knowledgeIntegration.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeIntegration
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeIntegrationDeleteArgs>(args: SelectSubset<T, KnowledgeIntegrationDeleteArgs<ExtArgs>>): Prisma__KnowledgeIntegrationClient<$Result.GetResult<Prisma.$KnowledgeIntegrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KnowledgeIntegration.
     * @param {KnowledgeIntegrationUpdateArgs} args - Arguments to update one KnowledgeIntegration.
     * @example
     * // Update one KnowledgeIntegration
     * const knowledgeIntegration = await prisma.knowledgeIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeIntegrationUpdateArgs>(args: SelectSubset<T, KnowledgeIntegrationUpdateArgs<ExtArgs>>): Prisma__KnowledgeIntegrationClient<$Result.GetResult<Prisma.$KnowledgeIntegrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KnowledgeIntegrations.
     * @param {KnowledgeIntegrationDeleteManyArgs} args - Arguments to filter KnowledgeIntegrations to delete.
     * @example
     * // Delete a few KnowledgeIntegrations
     * const { count } = await prisma.knowledgeIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeIntegrationDeleteManyArgs>(args?: SelectSubset<T, KnowledgeIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeIntegrations
     * const knowledgeIntegration = await prisma.knowledgeIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeIntegrationUpdateManyArgs>(args: SelectSubset<T, KnowledgeIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KnowledgeIntegration.
     * @param {KnowledgeIntegrationUpsertArgs} args - Arguments to update or create a KnowledgeIntegration.
     * @example
     * // Update or create a KnowledgeIntegration
     * const knowledgeIntegration = await prisma.knowledgeIntegration.upsert({
     *   create: {
     *     // ... data to create a KnowledgeIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeIntegration we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeIntegrationUpsertArgs>(args: SelectSubset<T, KnowledgeIntegrationUpsertArgs<ExtArgs>>): Prisma__KnowledgeIntegrationClient<$Result.GetResult<Prisma.$KnowledgeIntegrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KnowledgeIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeIntegrationCountArgs} args - Arguments to filter KnowledgeIntegrations to count.
     * @example
     * // Count the number of KnowledgeIntegrations
     * const count = await prisma.knowledgeIntegration.count({
     *   where: {
     *     // ... the filter for the KnowledgeIntegrations we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeIntegrationCountArgs>(
      args?: Subset<T, KnowledgeIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeIntegrationAggregateArgs>(args: Subset<T, KnowledgeIntegrationAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeIntegrationAggregateType<T>>

    /**
     * Group by KnowledgeIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeIntegration model
   */
  readonly fields: KnowledgeIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends ResearchProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResearchProjectDefaultArgs<ExtArgs>>): Prisma__ResearchProjectClient<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sourceDiscipline<T extends AcademicDisciplineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDisciplineDefaultArgs<ExtArgs>>): Prisma__AcademicDisciplineClient<$Result.GetResult<Prisma.$AcademicDisciplinePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    targetDiscipline<T extends AcademicDisciplineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDisciplineDefaultArgs<ExtArgs>>): Prisma__AcademicDisciplineClient<$Result.GetResult<Prisma.$AcademicDisciplinePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeIntegration model
   */ 
  interface KnowledgeIntegrationFieldRefs {
    readonly id: FieldRef<"KnowledgeIntegration", 'String'>
    readonly projectId: FieldRef<"KnowledgeIntegration", 'String'>
    readonly sourceDisciplineId: FieldRef<"KnowledgeIntegration", 'String'>
    readonly targetDisciplineId: FieldRef<"KnowledgeIntegration", 'String'>
    readonly integrationType: FieldRef<"KnowledgeIntegration", 'KnowledgeIntegrationType'>
    readonly title: FieldRef<"KnowledgeIntegration", 'String'>
    readonly description: FieldRef<"KnowledgeIntegration", 'String'>
    readonly sourceKnowledge: FieldRef<"KnowledgeIntegration", 'String'>
    readonly targetApplication: FieldRef<"KnowledgeIntegration", 'String'>
    readonly integrationMethod: FieldRef<"KnowledgeIntegration", 'String'>
    readonly validationStatus: FieldRef<"KnowledgeIntegration", 'String'>
    readonly validationNotes: FieldRef<"KnowledgeIntegration", 'String'>
    readonly noveltyScore: FieldRef<"KnowledgeIntegration", 'Decimal'>
    readonly impactPotential: FieldRef<"KnowledgeIntegration", 'String'>
    readonly implementationFeasibility: FieldRef<"KnowledgeIntegration", 'String'>
    readonly references: FieldRef<"KnowledgeIntegration", 'String[]'>
    readonly supportingEvidence: FieldRef<"KnowledgeIntegration", 'Json'>
    readonly createdById: FieldRef<"KnowledgeIntegration", 'String'>
    readonly createdAt: FieldRef<"KnowledgeIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"KnowledgeIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeIntegration findUnique
   */
  export type KnowledgeIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeIntegration
     */
    select?: KnowledgeIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeIntegration to fetch.
     */
    where: KnowledgeIntegrationWhereUniqueInput
  }

  /**
   * KnowledgeIntegration findUniqueOrThrow
   */
  export type KnowledgeIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeIntegration
     */
    select?: KnowledgeIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeIntegration to fetch.
     */
    where: KnowledgeIntegrationWhereUniqueInput
  }

  /**
   * KnowledgeIntegration findFirst
   */
  export type KnowledgeIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeIntegration
     */
    select?: KnowledgeIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeIntegration to fetch.
     */
    where?: KnowledgeIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeIntegrations to fetch.
     */
    orderBy?: KnowledgeIntegrationOrderByWithRelationInput | KnowledgeIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeIntegrations.
     */
    cursor?: KnowledgeIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeIntegrations.
     */
    distinct?: KnowledgeIntegrationScalarFieldEnum | KnowledgeIntegrationScalarFieldEnum[]
  }

  /**
   * KnowledgeIntegration findFirstOrThrow
   */
  export type KnowledgeIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeIntegration
     */
    select?: KnowledgeIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeIntegration to fetch.
     */
    where?: KnowledgeIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeIntegrations to fetch.
     */
    orderBy?: KnowledgeIntegrationOrderByWithRelationInput | KnowledgeIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeIntegrations.
     */
    cursor?: KnowledgeIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeIntegrations.
     */
    distinct?: KnowledgeIntegrationScalarFieldEnum | KnowledgeIntegrationScalarFieldEnum[]
  }

  /**
   * KnowledgeIntegration findMany
   */
  export type KnowledgeIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeIntegration
     */
    select?: KnowledgeIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeIntegrations to fetch.
     */
    where?: KnowledgeIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeIntegrations to fetch.
     */
    orderBy?: KnowledgeIntegrationOrderByWithRelationInput | KnowledgeIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeIntegrations.
     */
    cursor?: KnowledgeIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeIntegrations.
     */
    skip?: number
    distinct?: KnowledgeIntegrationScalarFieldEnum | KnowledgeIntegrationScalarFieldEnum[]
  }

  /**
   * KnowledgeIntegration create
   */
  export type KnowledgeIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeIntegration
     */
    select?: KnowledgeIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeIntegration.
     */
    data: XOR<KnowledgeIntegrationCreateInput, KnowledgeIntegrationUncheckedCreateInput>
  }

  /**
   * KnowledgeIntegration createMany
   */
  export type KnowledgeIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeIntegrations.
     */
    data: KnowledgeIntegrationCreateManyInput | KnowledgeIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeIntegration createManyAndReturn
   */
  export type KnowledgeIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeIntegration
     */
    select?: KnowledgeIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KnowledgeIntegrations.
     */
    data: KnowledgeIntegrationCreateManyInput | KnowledgeIntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeIntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeIntegration update
   */
  export type KnowledgeIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeIntegration
     */
    select?: KnowledgeIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeIntegration.
     */
    data: XOR<KnowledgeIntegrationUpdateInput, KnowledgeIntegrationUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeIntegration to update.
     */
    where: KnowledgeIntegrationWhereUniqueInput
  }

  /**
   * KnowledgeIntegration updateMany
   */
  export type KnowledgeIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeIntegrations.
     */
    data: XOR<KnowledgeIntegrationUpdateManyMutationInput, KnowledgeIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeIntegrations to update
     */
    where?: KnowledgeIntegrationWhereInput
  }

  /**
   * KnowledgeIntegration upsert
   */
  export type KnowledgeIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeIntegration
     */
    select?: KnowledgeIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeIntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeIntegration to update in case it exists.
     */
    where: KnowledgeIntegrationWhereUniqueInput
    /**
     * In case the KnowledgeIntegration found by the `where` argument doesn't exist, create a new KnowledgeIntegration with this data.
     */
    create: XOR<KnowledgeIntegrationCreateInput, KnowledgeIntegrationUncheckedCreateInput>
    /**
     * In case the KnowledgeIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeIntegrationUpdateInput, KnowledgeIntegrationUncheckedUpdateInput>
  }

  /**
   * KnowledgeIntegration delete
   */
  export type KnowledgeIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeIntegration
     */
    select?: KnowledgeIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeIntegrationInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeIntegration to delete.
     */
    where: KnowledgeIntegrationWhereUniqueInput
  }

  /**
   * KnowledgeIntegration deleteMany
   */
  export type KnowledgeIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeIntegrations to delete
     */
    where?: KnowledgeIntegrationWhereInput
  }

  /**
   * KnowledgeIntegration without action
   */
  export type KnowledgeIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeIntegration
     */
    select?: KnowledgeIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeIntegrationInclude<ExtArgs> | null
  }


  /**
   * Model ProjectCollaborator
   */

  export type AggregateProjectCollaborator = {
    _count: ProjectCollaboratorCountAggregateOutputType | null
    _min: ProjectCollaboratorMinAggregateOutputType | null
    _max: ProjectCollaboratorMaxAggregateOutputType | null
  }

  export type ProjectCollaboratorMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    role: string | null
    contributionDescription: string | null
    joinedAt: Date | null
    status: string | null
  }

  export type ProjectCollaboratorMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    role: string | null
    contributionDescription: string | null
    joinedAt: Date | null
    status: string | null
  }

  export type ProjectCollaboratorCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    role: number
    permissions: number
    contributionDescription: number
    joinedAt: number
    status: number
    _all: number
  }


  export type ProjectCollaboratorMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    contributionDescription?: true
    joinedAt?: true
    status?: true
  }

  export type ProjectCollaboratorMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    contributionDescription?: true
    joinedAt?: true
    status?: true
  }

  export type ProjectCollaboratorCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    permissions?: true
    contributionDescription?: true
    joinedAt?: true
    status?: true
    _all?: true
  }

  export type ProjectCollaboratorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectCollaborator to aggregate.
     */
    where?: ProjectCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectCollaborators to fetch.
     */
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectCollaborators
    **/
    _count?: true | ProjectCollaboratorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectCollaboratorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectCollaboratorMaxAggregateInputType
  }

  export type GetProjectCollaboratorAggregateType<T extends ProjectCollaboratorAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectCollaborator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectCollaborator[P]>
      : GetScalarType<T[P], AggregateProjectCollaborator[P]>
  }




  export type ProjectCollaboratorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectCollaboratorWhereInput
    orderBy?: ProjectCollaboratorOrderByWithAggregationInput | ProjectCollaboratorOrderByWithAggregationInput[]
    by: ProjectCollaboratorScalarFieldEnum[] | ProjectCollaboratorScalarFieldEnum
    having?: ProjectCollaboratorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCollaboratorCountAggregateInputType | true
    _min?: ProjectCollaboratorMinAggregateInputType
    _max?: ProjectCollaboratorMaxAggregateInputType
  }

  export type ProjectCollaboratorGroupByOutputType = {
    id: string
    projectId: string
    userId: string
    role: string
    permissions: JsonValue
    contributionDescription: string | null
    joinedAt: Date
    status: string
    _count: ProjectCollaboratorCountAggregateOutputType | null
    _min: ProjectCollaboratorMinAggregateOutputType | null
    _max: ProjectCollaboratorMaxAggregateOutputType | null
  }

  type GetProjectCollaboratorGroupByPayload<T extends ProjectCollaboratorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectCollaboratorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectCollaboratorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectCollaboratorGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectCollaboratorGroupByOutputType[P]>
        }
      >
    >


  export type ProjectCollaboratorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    contributionDescription?: boolean
    joinedAt?: boolean
    status?: boolean
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectCollaborator"]>

  export type ProjectCollaboratorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    contributionDescription?: boolean
    joinedAt?: boolean
    status?: boolean
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectCollaborator"]>

  export type ProjectCollaboratorSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    contributionDescription?: boolean
    joinedAt?: boolean
    status?: boolean
  }

  export type ProjectCollaboratorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectCollaboratorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ResearchProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectCollaboratorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectCollaborator"
    objects: {
      project: Prisma.$ResearchProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      userId: string
      role: string
      permissions: Prisma.JsonValue
      contributionDescription: string | null
      joinedAt: Date
      status: string
    }, ExtArgs["result"]["projectCollaborator"]>
    composites: {}
  }

  type ProjectCollaboratorGetPayload<S extends boolean | null | undefined | ProjectCollaboratorDefaultArgs> = $Result.GetResult<Prisma.$ProjectCollaboratorPayload, S>

  type ProjectCollaboratorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectCollaboratorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCollaboratorCountAggregateInputType | true
    }

  export interface ProjectCollaboratorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectCollaborator'], meta: { name: 'ProjectCollaborator' } }
    /**
     * Find zero or one ProjectCollaborator that matches the filter.
     * @param {ProjectCollaboratorFindUniqueArgs} args - Arguments to find a ProjectCollaborator
     * @example
     * // Get one ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectCollaboratorFindUniqueArgs>(args: SelectSubset<T, ProjectCollaboratorFindUniqueArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectCollaborator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectCollaboratorFindUniqueOrThrowArgs} args - Arguments to find a ProjectCollaborator
     * @example
     * // Get one ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectCollaboratorFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectCollaboratorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectCollaborator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorFindFirstArgs} args - Arguments to find a ProjectCollaborator
     * @example
     * // Get one ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectCollaboratorFindFirstArgs>(args?: SelectSubset<T, ProjectCollaboratorFindFirstArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectCollaborator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorFindFirstOrThrowArgs} args - Arguments to find a ProjectCollaborator
     * @example
     * // Get one ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectCollaboratorFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectCollaboratorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectCollaborators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectCollaborators
     * const projectCollaborators = await prisma.projectCollaborator.findMany()
     * 
     * // Get first 10 ProjectCollaborators
     * const projectCollaborators = await prisma.projectCollaborator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectCollaboratorWithIdOnly = await prisma.projectCollaborator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectCollaboratorFindManyArgs>(args?: SelectSubset<T, ProjectCollaboratorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectCollaborator.
     * @param {ProjectCollaboratorCreateArgs} args - Arguments to create a ProjectCollaborator.
     * @example
     * // Create one ProjectCollaborator
     * const ProjectCollaborator = await prisma.projectCollaborator.create({
     *   data: {
     *     // ... data to create a ProjectCollaborator
     *   }
     * })
     * 
     */
    create<T extends ProjectCollaboratorCreateArgs>(args: SelectSubset<T, ProjectCollaboratorCreateArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectCollaborators.
     * @param {ProjectCollaboratorCreateManyArgs} args - Arguments to create many ProjectCollaborators.
     * @example
     * // Create many ProjectCollaborators
     * const projectCollaborator = await prisma.projectCollaborator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCollaboratorCreateManyArgs>(args?: SelectSubset<T, ProjectCollaboratorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectCollaborators and returns the data saved in the database.
     * @param {ProjectCollaboratorCreateManyAndReturnArgs} args - Arguments to create many ProjectCollaborators.
     * @example
     * // Create many ProjectCollaborators
     * const projectCollaborator = await prisma.projectCollaborator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectCollaborators and only return the `id`
     * const projectCollaboratorWithIdOnly = await prisma.projectCollaborator.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCollaboratorCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCollaboratorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectCollaborator.
     * @param {ProjectCollaboratorDeleteArgs} args - Arguments to delete one ProjectCollaborator.
     * @example
     * // Delete one ProjectCollaborator
     * const ProjectCollaborator = await prisma.projectCollaborator.delete({
     *   where: {
     *     // ... filter to delete one ProjectCollaborator
     *   }
     * })
     * 
     */
    delete<T extends ProjectCollaboratorDeleteArgs>(args: SelectSubset<T, ProjectCollaboratorDeleteArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectCollaborator.
     * @param {ProjectCollaboratorUpdateArgs} args - Arguments to update one ProjectCollaborator.
     * @example
     * // Update one ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectCollaboratorUpdateArgs>(args: SelectSubset<T, ProjectCollaboratorUpdateArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectCollaborators.
     * @param {ProjectCollaboratorDeleteManyArgs} args - Arguments to filter ProjectCollaborators to delete.
     * @example
     * // Delete a few ProjectCollaborators
     * const { count } = await prisma.projectCollaborator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectCollaboratorDeleteManyArgs>(args?: SelectSubset<T, ProjectCollaboratorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectCollaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectCollaborators
     * const projectCollaborator = await prisma.projectCollaborator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectCollaboratorUpdateManyArgs>(args: SelectSubset<T, ProjectCollaboratorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectCollaborator.
     * @param {ProjectCollaboratorUpsertArgs} args - Arguments to update or create a ProjectCollaborator.
     * @example
     * // Update or create a ProjectCollaborator
     * const projectCollaborator = await prisma.projectCollaborator.upsert({
     *   create: {
     *     // ... data to create a ProjectCollaborator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectCollaborator we want to update
     *   }
     * })
     */
    upsert<T extends ProjectCollaboratorUpsertArgs>(args: SelectSubset<T, ProjectCollaboratorUpsertArgs<ExtArgs>>): Prisma__ProjectCollaboratorClient<$Result.GetResult<Prisma.$ProjectCollaboratorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectCollaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorCountArgs} args - Arguments to filter ProjectCollaborators to count.
     * @example
     * // Count the number of ProjectCollaborators
     * const count = await prisma.projectCollaborator.count({
     *   where: {
     *     // ... the filter for the ProjectCollaborators we want to count
     *   }
     * })
    **/
    count<T extends ProjectCollaboratorCountArgs>(
      args?: Subset<T, ProjectCollaboratorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCollaboratorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectCollaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectCollaboratorAggregateArgs>(args: Subset<T, ProjectCollaboratorAggregateArgs>): Prisma.PrismaPromise<GetProjectCollaboratorAggregateType<T>>

    /**
     * Group by ProjectCollaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCollaboratorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectCollaboratorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectCollaboratorGroupByArgs['orderBy'] }
        : { orderBy?: ProjectCollaboratorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectCollaboratorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectCollaboratorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectCollaborator model
   */
  readonly fields: ProjectCollaboratorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectCollaborator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectCollaboratorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ResearchProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResearchProjectDefaultArgs<ExtArgs>>): Prisma__ResearchProjectClient<$Result.GetResult<Prisma.$ResearchProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectCollaborator model
   */ 
  interface ProjectCollaboratorFieldRefs {
    readonly id: FieldRef<"ProjectCollaborator", 'String'>
    readonly projectId: FieldRef<"ProjectCollaborator", 'String'>
    readonly userId: FieldRef<"ProjectCollaborator", 'String'>
    readonly role: FieldRef<"ProjectCollaborator", 'String'>
    readonly permissions: FieldRef<"ProjectCollaborator", 'Json'>
    readonly contributionDescription: FieldRef<"ProjectCollaborator", 'String'>
    readonly joinedAt: FieldRef<"ProjectCollaborator", 'DateTime'>
    readonly status: FieldRef<"ProjectCollaborator", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectCollaborator findUnique
   */
  export type ProjectCollaboratorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ProjectCollaborator to fetch.
     */
    where: ProjectCollaboratorWhereUniqueInput
  }

  /**
   * ProjectCollaborator findUniqueOrThrow
   */
  export type ProjectCollaboratorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ProjectCollaborator to fetch.
     */
    where: ProjectCollaboratorWhereUniqueInput
  }

  /**
   * ProjectCollaborator findFirst
   */
  export type ProjectCollaboratorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ProjectCollaborator to fetch.
     */
    where?: ProjectCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectCollaborators to fetch.
     */
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectCollaborators.
     */
    cursor?: ProjectCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectCollaborators.
     */
    distinct?: ProjectCollaboratorScalarFieldEnum | ProjectCollaboratorScalarFieldEnum[]
  }

  /**
   * ProjectCollaborator findFirstOrThrow
   */
  export type ProjectCollaboratorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ProjectCollaborator to fetch.
     */
    where?: ProjectCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectCollaborators to fetch.
     */
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectCollaborators.
     */
    cursor?: ProjectCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectCollaborators.
     */
    distinct?: ProjectCollaboratorScalarFieldEnum | ProjectCollaboratorScalarFieldEnum[]
  }

  /**
   * ProjectCollaborator findMany
   */
  export type ProjectCollaboratorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ProjectCollaborators to fetch.
     */
    where?: ProjectCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectCollaborators to fetch.
     */
    orderBy?: ProjectCollaboratorOrderByWithRelationInput | ProjectCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectCollaborators.
     */
    cursor?: ProjectCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectCollaborators.
     */
    skip?: number
    distinct?: ProjectCollaboratorScalarFieldEnum | ProjectCollaboratorScalarFieldEnum[]
  }

  /**
   * ProjectCollaborator create
   */
  export type ProjectCollaboratorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectCollaborator.
     */
    data: XOR<ProjectCollaboratorCreateInput, ProjectCollaboratorUncheckedCreateInput>
  }

  /**
   * ProjectCollaborator createMany
   */
  export type ProjectCollaboratorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectCollaborators.
     */
    data: ProjectCollaboratorCreateManyInput | ProjectCollaboratorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectCollaborator createManyAndReturn
   */
  export type ProjectCollaboratorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectCollaborators.
     */
    data: ProjectCollaboratorCreateManyInput | ProjectCollaboratorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectCollaborator update
   */
  export type ProjectCollaboratorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectCollaborator.
     */
    data: XOR<ProjectCollaboratorUpdateInput, ProjectCollaboratorUncheckedUpdateInput>
    /**
     * Choose, which ProjectCollaborator to update.
     */
    where: ProjectCollaboratorWhereUniqueInput
  }

  /**
   * ProjectCollaborator updateMany
   */
  export type ProjectCollaboratorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectCollaborators.
     */
    data: XOR<ProjectCollaboratorUpdateManyMutationInput, ProjectCollaboratorUncheckedUpdateManyInput>
    /**
     * Filter which ProjectCollaborators to update
     */
    where?: ProjectCollaboratorWhereInput
  }

  /**
   * ProjectCollaborator upsert
   */
  export type ProjectCollaboratorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectCollaborator to update in case it exists.
     */
    where: ProjectCollaboratorWhereUniqueInput
    /**
     * In case the ProjectCollaborator found by the `where` argument doesn't exist, create a new ProjectCollaborator with this data.
     */
    create: XOR<ProjectCollaboratorCreateInput, ProjectCollaboratorUncheckedCreateInput>
    /**
     * In case the ProjectCollaborator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectCollaboratorUpdateInput, ProjectCollaboratorUncheckedUpdateInput>
  }

  /**
   * ProjectCollaborator delete
   */
  export type ProjectCollaboratorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
    /**
     * Filter which ProjectCollaborator to delete.
     */
    where: ProjectCollaboratorWhereUniqueInput
  }

  /**
   * ProjectCollaborator deleteMany
   */
  export type ProjectCollaboratorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectCollaborators to delete
     */
    where?: ProjectCollaboratorWhereInput
  }

  /**
   * ProjectCollaborator without action
   */
  export type ProjectCollaboratorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCollaborator
     */
    select?: ProjectCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCollaboratorInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    avatar: 'avatar',
    role: 'role',
    institution: 'institution',
    department: 'department',
    specialization: 'specialization',
    orcidId: 'orcidId',
    googleScholarId: 'googleScholarId',
    linkedinUrl: 'linkedinUrl',
    isVerified: 'isVerified',
    preferences: 'preferences',
    memberSince: 'memberSince',
    lastActive: 'lastActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tokensTotal: 'tokensTotal',
    tokensUsedToday: 'tokensUsedToday',
    tokenLastResetDate: 'tokenLastResetDate',
    isPro: 'isPro'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AcademicDisciplineScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    parentDisciplineId: 'parentDisciplineId',
    level: 'level',
    description: 'description',
    keywords: 'keywords',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type AcademicDisciplineScalarFieldEnum = (typeof AcademicDisciplineScalarFieldEnum)[keyof typeof AcademicDisciplineScalarFieldEnum]


  export const OnetOccupationScalarFieldEnum: {
    id: 'id',
    onetCode: 'onetCode',
    title: 'title',
    description: 'description',
    category: 'category',
    subdomain: 'subdomain',
    tasks: 'tasks',
    skills: 'skills',
    knowledgeAreas: 'knowledgeAreas',
    abilities: 'abilities',
    educationLevel: 'educationLevel',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type OnetOccupationScalarFieldEnum = (typeof OnetOccupationScalarFieldEnum)[keyof typeof OnetOccupationScalarFieldEnum]


  export const ResearchProjectScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    principalInvestigatorId: 'principalInvestigatorId',
    startDate: 'startDate',
    endDate: 'endDate',
    fundingSource: 'fundingSource',
    fundingAmount: 'fundingAmount',
    institutions: 'institutions',
    methodologyType: 'methodologyType',
    researchQuestions: 'researchQuestions',
    objectives: 'objectives',
    hypotheses: 'hypotheses',
    ethicalApprovalRequired: 'ethicalApprovalRequired',
    ethicalApprovalStatus: 'ethicalApprovalStatus',
    dataClassification: 'dataClassification',
    collaborationLevel: 'collaborationLevel',
    isPublic: 'isPublic',
    tags: 'tags',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResearchProjectScalarFieldEnum = (typeof ResearchProjectScalarFieldEnum)[keyof typeof ResearchProjectScalarFieldEnum]


  export const ProjectDisciplineScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    disciplineId: 'disciplineId',
    primaryDiscipline: 'primaryDiscipline',
    contributionLevel: 'contributionLevel',
    createdAt: 'createdAt'
  };

  export type ProjectDisciplineScalarFieldEnum = (typeof ProjectDisciplineScalarFieldEnum)[keyof typeof ProjectDisciplineScalarFieldEnum]


  export const ProjectOccupationScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    occupationId: 'occupationId',
    relevanceLevel: 'relevanceLevel',
    roleDescription: 'roleDescription',
    createdAt: 'createdAt'
  };

  export type ProjectOccupationScalarFieldEnum = (typeof ProjectOccupationScalarFieldEnum)[keyof typeof ProjectOccupationScalarFieldEnum]


  export const MethodologyStepScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    methodologyType: 'methodologyType',
    stepOrder: 'stepOrder',
    estimatedDurationHours: 'estimatedDurationHours',
    requiredResources: 'requiredResources',
    deliverables: 'deliverables',
    successCriteria: 'successCriteria',
    dependencies: 'dependencies',
    templateData: 'templateData',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type MethodologyStepScalarFieldEnum = (typeof MethodologyStepScalarFieldEnum)[keyof typeof MethodologyStepScalarFieldEnum]


  export const ProjectMethodologyStepScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    methodologyStepId: 'methodologyStepId',
    assignedToId: 'assignedToId',
    status: 'status',
    actualStartDate: 'actualStartDate',
    actualEndDate: 'actualEndDate',
    notes: 'notes',
    deliverablesUploaded: 'deliverablesUploaded',
    completionPercentage: 'completionPercentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectMethodologyStepScalarFieldEnum = (typeof ProjectMethodologyStepScalarFieldEnum)[keyof typeof ProjectMethodologyStepScalarFieldEnum]


  export const UploadedImageScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    uploadedById: 'uploadedById',
    fileName: 'fileName',
    originalFileName: 'originalFileName',
    filePath: 'filePath',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    imageType: 'imageType',
    imageConfidence: 'imageConfidence',
    width: 'width',
    height: 'height',
    colorDepth: 'colorDepth',
    hasMetadata: 'hasMetadata',
    dicomMetadata: 'dicomMetadata',
    analysisStatus: 'analysisStatus',
    tags: 'tags',
    description: 'description',
    consentObtained: 'consentObtained',
    dataClassification: 'dataClassification',
    anonymized: 'anonymized',
    processingStartedAt: 'processingStartedAt',
    processingCompletedAt: 'processingCompletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UploadedImageScalarFieldEnum = (typeof UploadedImageScalarFieldEnum)[keyof typeof UploadedImageScalarFieldEnum]


  export const ResearchAnalysisScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    imageId: 'imageId',
    analystId: 'analystId',
    analysisType: 'analysisType',
    status: 'status',
    confidenceScore: 'confidenceScore',
    processingTimeSeconds: 'processingTimeSeconds',
    algorithmVersion: 'algorithmVersion',
    modelUsed: 'modelUsed',
    findings: 'findings',
    recommendations: 'recommendations',
    differentialDiagnosis: 'differentialDiagnosis',
    severityAssessment: 'severityAssessment',
    regionsOfInterest: 'regionsOfInterest',
    qualityMetrics: 'qualityMetrics',
    errorMessage: 'errorMessage',
    reviewRequired: 'reviewRequired',
    reviewedById: 'reviewedById',
    reviewedAt: 'reviewedAt',
    reviewNotes: 'reviewNotes',
    approvedById: 'approvedById',
    approvedAt: 'approvedAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResearchAnalysisScalarFieldEnum = (typeof ResearchAnalysisScalarFieldEnum)[keyof typeof ResearchAnalysisScalarFieldEnum]


  export const KnowledgeIntegrationScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    sourceDisciplineId: 'sourceDisciplineId',
    targetDisciplineId: 'targetDisciplineId',
    integrationType: 'integrationType',
    title: 'title',
    description: 'description',
    sourceKnowledge: 'sourceKnowledge',
    targetApplication: 'targetApplication',
    integrationMethod: 'integrationMethod',
    validationStatus: 'validationStatus',
    validationNotes: 'validationNotes',
    noveltyScore: 'noveltyScore',
    impactPotential: 'impactPotential',
    implementationFeasibility: 'implementationFeasibility',
    references: 'references',
    supportingEvidence: 'supportingEvidence',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KnowledgeIntegrationScalarFieldEnum = (typeof KnowledgeIntegrationScalarFieldEnum)[keyof typeof KnowledgeIntegrationScalarFieldEnum]


  export const ProjectCollaboratorScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    role: 'role',
    permissions: 'permissions',
    contributionDescription: 'contributionDescription',
    joinedAt: 'joinedAt',
    status: 'status'
  };

  export type ProjectCollaboratorScalarFieldEnum = (typeof ProjectCollaboratorScalarFieldEnum)[keyof typeof ProjectCollaboratorScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'MethodologyType'
   */
  export type EnumMethodologyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MethodologyType'>
    


  /**
   * Reference to a field of type 'MethodologyType[]'
   */
  export type ListEnumMethodologyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MethodologyType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'AnalysisStatus'
   */
  export type EnumAnalysisStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalysisStatus'>
    


  /**
   * Reference to a field of type 'AnalysisStatus[]'
   */
  export type ListEnumAnalysisStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalysisStatus[]'>
    


  /**
   * Reference to a field of type 'KnowledgeIntegrationType'
   */
  export type EnumKnowledgeIntegrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KnowledgeIntegrationType'>
    


  /**
   * Reference to a field of type 'KnowledgeIntegrationType[]'
   */
  export type ListEnumKnowledgeIntegrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KnowledgeIntegrationType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    institution?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    specialization?: StringNullableListFilter<"User">
    orcidId?: StringNullableFilter<"User"> | string | null
    googleScholarId?: StringNullableFilter<"User"> | string | null
    linkedinUrl?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    preferences?: JsonFilter<"User">
    memberSince?: DateTimeFilter<"User"> | Date | string
    lastActive?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tokensTotal?: IntFilter<"User"> | number
    tokensUsedToday?: IntFilter<"User"> | number
    tokenLastResetDate?: DateTimeFilter<"User"> | Date | string
    isPro?: BoolFilter<"User"> | boolean
    knowledgeIntegrations?: KnowledgeIntegrationListRelationFilter
    projectCollaborations?: ProjectCollaboratorListRelationFilter
    assignedMethodologySteps?: ProjectMethodologyStepListRelationFilter
    analyses?: ResearchAnalysisListRelationFilter
    approvedAnalyses?: ResearchAnalysisListRelationFilter
    reviewedAnalyses?: ResearchAnalysisListRelationFilter
    projects?: ResearchProjectListRelationFilter
    uploadedImages?: UploadedImageListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    institution?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    specialization?: SortOrder
    orcidId?: SortOrderInput | SortOrder
    googleScholarId?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    preferences?: SortOrder
    memberSince?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokensTotal?: SortOrder
    tokensUsedToday?: SortOrder
    tokenLastResetDate?: SortOrder
    isPro?: SortOrder
    knowledgeIntegrations?: KnowledgeIntegrationOrderByRelationAggregateInput
    projectCollaborations?: ProjectCollaboratorOrderByRelationAggregateInput
    assignedMethodologySteps?: ProjectMethodologyStepOrderByRelationAggregateInput
    analyses?: ResearchAnalysisOrderByRelationAggregateInput
    approvedAnalyses?: ResearchAnalysisOrderByRelationAggregateInput
    reviewedAnalyses?: ResearchAnalysisOrderByRelationAggregateInput
    projects?: ResearchProjectOrderByRelationAggregateInput
    uploadedImages?: UploadedImageOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    institution?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    specialization?: StringNullableListFilter<"User">
    orcidId?: StringNullableFilter<"User"> | string | null
    googleScholarId?: StringNullableFilter<"User"> | string | null
    linkedinUrl?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    preferences?: JsonFilter<"User">
    memberSince?: DateTimeFilter<"User"> | Date | string
    lastActive?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tokensTotal?: IntFilter<"User"> | number
    tokensUsedToday?: IntFilter<"User"> | number
    tokenLastResetDate?: DateTimeFilter<"User"> | Date | string
    isPro?: BoolFilter<"User"> | boolean
    knowledgeIntegrations?: KnowledgeIntegrationListRelationFilter
    projectCollaborations?: ProjectCollaboratorListRelationFilter
    assignedMethodologySteps?: ProjectMethodologyStepListRelationFilter
    analyses?: ResearchAnalysisListRelationFilter
    approvedAnalyses?: ResearchAnalysisListRelationFilter
    reviewedAnalyses?: ResearchAnalysisListRelationFilter
    projects?: ResearchProjectListRelationFilter
    uploadedImages?: UploadedImageListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    institution?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    specialization?: SortOrder
    orcidId?: SortOrderInput | SortOrder
    googleScholarId?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    preferences?: SortOrder
    memberSince?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokensTotal?: SortOrder
    tokensUsedToday?: SortOrder
    tokenLastResetDate?: SortOrder
    isPro?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    institution?: StringNullableWithAggregatesFilter<"User"> | string | null
    department?: StringNullableWithAggregatesFilter<"User"> | string | null
    specialization?: StringNullableListFilter<"User">
    orcidId?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleScholarId?: StringNullableWithAggregatesFilter<"User"> | string | null
    linkedinUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    preferences?: JsonWithAggregatesFilter<"User">
    memberSince?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastActive?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    tokensTotal?: IntWithAggregatesFilter<"User"> | number
    tokensUsedToday?: IntWithAggregatesFilter<"User"> | number
    tokenLastResetDate?: DateTimeWithAggregatesFilter<"User"> | Date | string
    isPro?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type AcademicDisciplineWhereInput = {
    AND?: AcademicDisciplineWhereInput | AcademicDisciplineWhereInput[]
    OR?: AcademicDisciplineWhereInput[]
    NOT?: AcademicDisciplineWhereInput | AcademicDisciplineWhereInput[]
    id?: StringFilter<"AcademicDiscipline"> | string
    code?: StringFilter<"AcademicDiscipline"> | string
    name?: StringFilter<"AcademicDiscipline"> | string
    parentDisciplineId?: StringNullableFilter<"AcademicDiscipline"> | string | null
    level?: IntFilter<"AcademicDiscipline"> | number
    description?: StringNullableFilter<"AcademicDiscipline"> | string | null
    keywords?: StringNullableListFilter<"AcademicDiscipline">
    isActive?: BoolFilter<"AcademicDiscipline"> | boolean
    createdAt?: DateTimeFilter<"AcademicDiscipline"> | Date | string
    parentDiscipline?: XOR<AcademicDisciplineNullableRelationFilter, AcademicDisciplineWhereInput> | null
    childDisciplines?: AcademicDisciplineListRelationFilter
    knowledgeIntegrationsSource?: KnowledgeIntegrationListRelationFilter
    knowledgeIntegrationsTarget?: KnowledgeIntegrationListRelationFilter
    projectDisciplines?: ProjectDisciplineListRelationFilter
  }

  export type AcademicDisciplineOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    parentDisciplineId?: SortOrderInput | SortOrder
    level?: SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    parentDiscipline?: AcademicDisciplineOrderByWithRelationInput
    childDisciplines?: AcademicDisciplineOrderByRelationAggregateInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationOrderByRelationAggregateInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationOrderByRelationAggregateInput
    projectDisciplines?: ProjectDisciplineOrderByRelationAggregateInput
  }

  export type AcademicDisciplineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: AcademicDisciplineWhereInput | AcademicDisciplineWhereInput[]
    OR?: AcademicDisciplineWhereInput[]
    NOT?: AcademicDisciplineWhereInput | AcademicDisciplineWhereInput[]
    name?: StringFilter<"AcademicDiscipline"> | string
    parentDisciplineId?: StringNullableFilter<"AcademicDiscipline"> | string | null
    level?: IntFilter<"AcademicDiscipline"> | number
    description?: StringNullableFilter<"AcademicDiscipline"> | string | null
    keywords?: StringNullableListFilter<"AcademicDiscipline">
    isActive?: BoolFilter<"AcademicDiscipline"> | boolean
    createdAt?: DateTimeFilter<"AcademicDiscipline"> | Date | string
    parentDiscipline?: XOR<AcademicDisciplineNullableRelationFilter, AcademicDisciplineWhereInput> | null
    childDisciplines?: AcademicDisciplineListRelationFilter
    knowledgeIntegrationsSource?: KnowledgeIntegrationListRelationFilter
    knowledgeIntegrationsTarget?: KnowledgeIntegrationListRelationFilter
    projectDisciplines?: ProjectDisciplineListRelationFilter
  }, "id" | "code">

  export type AcademicDisciplineOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    parentDisciplineId?: SortOrderInput | SortOrder
    level?: SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: AcademicDisciplineCountOrderByAggregateInput
    _avg?: AcademicDisciplineAvgOrderByAggregateInput
    _max?: AcademicDisciplineMaxOrderByAggregateInput
    _min?: AcademicDisciplineMinOrderByAggregateInput
    _sum?: AcademicDisciplineSumOrderByAggregateInput
  }

  export type AcademicDisciplineScalarWhereWithAggregatesInput = {
    AND?: AcademicDisciplineScalarWhereWithAggregatesInput | AcademicDisciplineScalarWhereWithAggregatesInput[]
    OR?: AcademicDisciplineScalarWhereWithAggregatesInput[]
    NOT?: AcademicDisciplineScalarWhereWithAggregatesInput | AcademicDisciplineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicDiscipline"> | string
    code?: StringWithAggregatesFilter<"AcademicDiscipline"> | string
    name?: StringWithAggregatesFilter<"AcademicDiscipline"> | string
    parentDisciplineId?: StringNullableWithAggregatesFilter<"AcademicDiscipline"> | string | null
    level?: IntWithAggregatesFilter<"AcademicDiscipline"> | number
    description?: StringNullableWithAggregatesFilter<"AcademicDiscipline"> | string | null
    keywords?: StringNullableListFilter<"AcademicDiscipline">
    isActive?: BoolWithAggregatesFilter<"AcademicDiscipline"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AcademicDiscipline"> | Date | string
  }

  export type OnetOccupationWhereInput = {
    AND?: OnetOccupationWhereInput | OnetOccupationWhereInput[]
    OR?: OnetOccupationWhereInput[]
    NOT?: OnetOccupationWhereInput | OnetOccupationWhereInput[]
    id?: StringFilter<"OnetOccupation"> | string
    onetCode?: StringFilter<"OnetOccupation"> | string
    title?: StringFilter<"OnetOccupation"> | string
    description?: StringNullableFilter<"OnetOccupation"> | string | null
    category?: StringNullableFilter<"OnetOccupation"> | string | null
    subdomain?: StringNullableFilter<"OnetOccupation"> | string | null
    tasks?: StringNullableListFilter<"OnetOccupation">
    skills?: StringNullableListFilter<"OnetOccupation">
    knowledgeAreas?: StringNullableListFilter<"OnetOccupation">
    abilities?: StringNullableListFilter<"OnetOccupation">
    educationLevel?: StringNullableFilter<"OnetOccupation"> | string | null
    isActive?: BoolFilter<"OnetOccupation"> | boolean
    createdAt?: DateTimeFilter<"OnetOccupation"> | Date | string
    projectOccupations?: ProjectOccupationListRelationFilter
  }

  export type OnetOccupationOrderByWithRelationInput = {
    id?: SortOrder
    onetCode?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    subdomain?: SortOrderInput | SortOrder
    tasks?: SortOrder
    skills?: SortOrder
    knowledgeAreas?: SortOrder
    abilities?: SortOrder
    educationLevel?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    projectOccupations?: ProjectOccupationOrderByRelationAggregateInput
  }

  export type OnetOccupationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    onetCode?: string
    AND?: OnetOccupationWhereInput | OnetOccupationWhereInput[]
    OR?: OnetOccupationWhereInput[]
    NOT?: OnetOccupationWhereInput | OnetOccupationWhereInput[]
    title?: StringFilter<"OnetOccupation"> | string
    description?: StringNullableFilter<"OnetOccupation"> | string | null
    category?: StringNullableFilter<"OnetOccupation"> | string | null
    subdomain?: StringNullableFilter<"OnetOccupation"> | string | null
    tasks?: StringNullableListFilter<"OnetOccupation">
    skills?: StringNullableListFilter<"OnetOccupation">
    knowledgeAreas?: StringNullableListFilter<"OnetOccupation">
    abilities?: StringNullableListFilter<"OnetOccupation">
    educationLevel?: StringNullableFilter<"OnetOccupation"> | string | null
    isActive?: BoolFilter<"OnetOccupation"> | boolean
    createdAt?: DateTimeFilter<"OnetOccupation"> | Date | string
    projectOccupations?: ProjectOccupationListRelationFilter
  }, "id" | "onetCode">

  export type OnetOccupationOrderByWithAggregationInput = {
    id?: SortOrder
    onetCode?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    subdomain?: SortOrderInput | SortOrder
    tasks?: SortOrder
    skills?: SortOrder
    knowledgeAreas?: SortOrder
    abilities?: SortOrder
    educationLevel?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: OnetOccupationCountOrderByAggregateInput
    _max?: OnetOccupationMaxOrderByAggregateInput
    _min?: OnetOccupationMinOrderByAggregateInput
  }

  export type OnetOccupationScalarWhereWithAggregatesInput = {
    AND?: OnetOccupationScalarWhereWithAggregatesInput | OnetOccupationScalarWhereWithAggregatesInput[]
    OR?: OnetOccupationScalarWhereWithAggregatesInput[]
    NOT?: OnetOccupationScalarWhereWithAggregatesInput | OnetOccupationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OnetOccupation"> | string
    onetCode?: StringWithAggregatesFilter<"OnetOccupation"> | string
    title?: StringWithAggregatesFilter<"OnetOccupation"> | string
    description?: StringNullableWithAggregatesFilter<"OnetOccupation"> | string | null
    category?: StringNullableWithAggregatesFilter<"OnetOccupation"> | string | null
    subdomain?: StringNullableWithAggregatesFilter<"OnetOccupation"> | string | null
    tasks?: StringNullableListFilter<"OnetOccupation">
    skills?: StringNullableListFilter<"OnetOccupation">
    knowledgeAreas?: StringNullableListFilter<"OnetOccupation">
    abilities?: StringNullableListFilter<"OnetOccupation">
    educationLevel?: StringNullableWithAggregatesFilter<"OnetOccupation"> | string | null
    isActive?: BoolWithAggregatesFilter<"OnetOccupation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OnetOccupation"> | Date | string
  }

  export type ResearchProjectWhereInput = {
    AND?: ResearchProjectWhereInput | ResearchProjectWhereInput[]
    OR?: ResearchProjectWhereInput[]
    NOT?: ResearchProjectWhereInput | ResearchProjectWhereInput[]
    id?: StringFilter<"ResearchProject"> | string
    title?: StringFilter<"ResearchProject"> | string
    description?: StringNullableFilter<"ResearchProject"> | string | null
    status?: EnumProjectStatusFilter<"ResearchProject"> | $Enums.ProjectStatus
    principalInvestigatorId?: StringFilter<"ResearchProject"> | string
    startDate?: DateTimeNullableFilter<"ResearchProject"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ResearchProject"> | Date | string | null
    fundingSource?: StringNullableFilter<"ResearchProject"> | string | null
    fundingAmount?: DecimalNullableFilter<"ResearchProject"> | Decimal | DecimalJsLike | number | string | null
    institutions?: StringNullableListFilter<"ResearchProject">
    methodologyType?: EnumMethodologyTypeFilter<"ResearchProject"> | $Enums.MethodologyType
    researchQuestions?: StringNullableListFilter<"ResearchProject">
    objectives?: StringNullableListFilter<"ResearchProject">
    hypotheses?: StringNullableListFilter<"ResearchProject">
    ethicalApprovalRequired?: BoolFilter<"ResearchProject"> | boolean
    ethicalApprovalStatus?: StringNullableFilter<"ResearchProject"> | string | null
    dataClassification?: StringFilter<"ResearchProject"> | string
    collaborationLevel?: StringFilter<"ResearchProject"> | string
    isPublic?: BoolFilter<"ResearchProject"> | boolean
    tags?: StringNullableListFilter<"ResearchProject">
    metadata?: JsonFilter<"ResearchProject">
    createdAt?: DateTimeFilter<"ResearchProject"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchProject"> | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationListRelationFilter
    collaborators?: ProjectCollaboratorListRelationFilter
    disciplines?: ProjectDisciplineListRelationFilter
    methodologySteps?: ProjectMethodologyStepListRelationFilter
    occupations?: ProjectOccupationListRelationFilter
    analyses?: ResearchAnalysisListRelationFilter
    principalInvestigator?: XOR<UserRelationFilter, UserWhereInput>
    images?: UploadedImageListRelationFilter
  }

  export type ResearchProjectOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    principalInvestigatorId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    fundingSource?: SortOrderInput | SortOrder
    fundingAmount?: SortOrderInput | SortOrder
    institutions?: SortOrder
    methodologyType?: SortOrder
    researchQuestions?: SortOrder
    objectives?: SortOrder
    hypotheses?: SortOrder
    ethicalApprovalRequired?: SortOrder
    ethicalApprovalStatus?: SortOrderInput | SortOrder
    dataClassification?: SortOrder
    collaborationLevel?: SortOrder
    isPublic?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    knowledgeIntegrations?: KnowledgeIntegrationOrderByRelationAggregateInput
    collaborators?: ProjectCollaboratorOrderByRelationAggregateInput
    disciplines?: ProjectDisciplineOrderByRelationAggregateInput
    methodologySteps?: ProjectMethodologyStepOrderByRelationAggregateInput
    occupations?: ProjectOccupationOrderByRelationAggregateInput
    analyses?: ResearchAnalysisOrderByRelationAggregateInput
    principalInvestigator?: UserOrderByWithRelationInput
    images?: UploadedImageOrderByRelationAggregateInput
  }

  export type ResearchProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResearchProjectWhereInput | ResearchProjectWhereInput[]
    OR?: ResearchProjectWhereInput[]
    NOT?: ResearchProjectWhereInput | ResearchProjectWhereInput[]
    title?: StringFilter<"ResearchProject"> | string
    description?: StringNullableFilter<"ResearchProject"> | string | null
    status?: EnumProjectStatusFilter<"ResearchProject"> | $Enums.ProjectStatus
    principalInvestigatorId?: StringFilter<"ResearchProject"> | string
    startDate?: DateTimeNullableFilter<"ResearchProject"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ResearchProject"> | Date | string | null
    fundingSource?: StringNullableFilter<"ResearchProject"> | string | null
    fundingAmount?: DecimalNullableFilter<"ResearchProject"> | Decimal | DecimalJsLike | number | string | null
    institutions?: StringNullableListFilter<"ResearchProject">
    methodologyType?: EnumMethodologyTypeFilter<"ResearchProject"> | $Enums.MethodologyType
    researchQuestions?: StringNullableListFilter<"ResearchProject">
    objectives?: StringNullableListFilter<"ResearchProject">
    hypotheses?: StringNullableListFilter<"ResearchProject">
    ethicalApprovalRequired?: BoolFilter<"ResearchProject"> | boolean
    ethicalApprovalStatus?: StringNullableFilter<"ResearchProject"> | string | null
    dataClassification?: StringFilter<"ResearchProject"> | string
    collaborationLevel?: StringFilter<"ResearchProject"> | string
    isPublic?: BoolFilter<"ResearchProject"> | boolean
    tags?: StringNullableListFilter<"ResearchProject">
    metadata?: JsonFilter<"ResearchProject">
    createdAt?: DateTimeFilter<"ResearchProject"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchProject"> | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationListRelationFilter
    collaborators?: ProjectCollaboratorListRelationFilter
    disciplines?: ProjectDisciplineListRelationFilter
    methodologySteps?: ProjectMethodologyStepListRelationFilter
    occupations?: ProjectOccupationListRelationFilter
    analyses?: ResearchAnalysisListRelationFilter
    principalInvestigator?: XOR<UserRelationFilter, UserWhereInput>
    images?: UploadedImageListRelationFilter
  }, "id">

  export type ResearchProjectOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    principalInvestigatorId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    fundingSource?: SortOrderInput | SortOrder
    fundingAmount?: SortOrderInput | SortOrder
    institutions?: SortOrder
    methodologyType?: SortOrder
    researchQuestions?: SortOrder
    objectives?: SortOrder
    hypotheses?: SortOrder
    ethicalApprovalRequired?: SortOrder
    ethicalApprovalStatus?: SortOrderInput | SortOrder
    dataClassification?: SortOrder
    collaborationLevel?: SortOrder
    isPublic?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResearchProjectCountOrderByAggregateInput
    _avg?: ResearchProjectAvgOrderByAggregateInput
    _max?: ResearchProjectMaxOrderByAggregateInput
    _min?: ResearchProjectMinOrderByAggregateInput
    _sum?: ResearchProjectSumOrderByAggregateInput
  }

  export type ResearchProjectScalarWhereWithAggregatesInput = {
    AND?: ResearchProjectScalarWhereWithAggregatesInput | ResearchProjectScalarWhereWithAggregatesInput[]
    OR?: ResearchProjectScalarWhereWithAggregatesInput[]
    NOT?: ResearchProjectScalarWhereWithAggregatesInput | ResearchProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResearchProject"> | string
    title?: StringWithAggregatesFilter<"ResearchProject"> | string
    description?: StringNullableWithAggregatesFilter<"ResearchProject"> | string | null
    status?: EnumProjectStatusWithAggregatesFilter<"ResearchProject"> | $Enums.ProjectStatus
    principalInvestigatorId?: StringWithAggregatesFilter<"ResearchProject"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"ResearchProject"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"ResearchProject"> | Date | string | null
    fundingSource?: StringNullableWithAggregatesFilter<"ResearchProject"> | string | null
    fundingAmount?: DecimalNullableWithAggregatesFilter<"ResearchProject"> | Decimal | DecimalJsLike | number | string | null
    institutions?: StringNullableListFilter<"ResearchProject">
    methodologyType?: EnumMethodologyTypeWithAggregatesFilter<"ResearchProject"> | $Enums.MethodologyType
    researchQuestions?: StringNullableListFilter<"ResearchProject">
    objectives?: StringNullableListFilter<"ResearchProject">
    hypotheses?: StringNullableListFilter<"ResearchProject">
    ethicalApprovalRequired?: BoolWithAggregatesFilter<"ResearchProject"> | boolean
    ethicalApprovalStatus?: StringNullableWithAggregatesFilter<"ResearchProject"> | string | null
    dataClassification?: StringWithAggregatesFilter<"ResearchProject"> | string
    collaborationLevel?: StringWithAggregatesFilter<"ResearchProject"> | string
    isPublic?: BoolWithAggregatesFilter<"ResearchProject"> | boolean
    tags?: StringNullableListFilter<"ResearchProject">
    metadata?: JsonWithAggregatesFilter<"ResearchProject">
    createdAt?: DateTimeWithAggregatesFilter<"ResearchProject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ResearchProject"> | Date | string
  }

  export type ProjectDisciplineWhereInput = {
    AND?: ProjectDisciplineWhereInput | ProjectDisciplineWhereInput[]
    OR?: ProjectDisciplineWhereInput[]
    NOT?: ProjectDisciplineWhereInput | ProjectDisciplineWhereInput[]
    id?: StringFilter<"ProjectDiscipline"> | string
    projectId?: StringFilter<"ProjectDiscipline"> | string
    disciplineId?: StringFilter<"ProjectDiscipline"> | string
    primaryDiscipline?: BoolFilter<"ProjectDiscipline"> | boolean
    contributionLevel?: StringFilter<"ProjectDiscipline"> | string
    createdAt?: DateTimeFilter<"ProjectDiscipline"> | Date | string
    discipline?: XOR<AcademicDisciplineRelationFilter, AcademicDisciplineWhereInput>
    project?: XOR<ResearchProjectRelationFilter, ResearchProjectWhereInput>
  }

  export type ProjectDisciplineOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    disciplineId?: SortOrder
    primaryDiscipline?: SortOrder
    contributionLevel?: SortOrder
    createdAt?: SortOrder
    discipline?: AcademicDisciplineOrderByWithRelationInput
    project?: ResearchProjectOrderByWithRelationInput
  }

  export type ProjectDisciplineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_disciplineId?: ProjectDisciplineProjectIdDisciplineIdCompoundUniqueInput
    AND?: ProjectDisciplineWhereInput | ProjectDisciplineWhereInput[]
    OR?: ProjectDisciplineWhereInput[]
    NOT?: ProjectDisciplineWhereInput | ProjectDisciplineWhereInput[]
    projectId?: StringFilter<"ProjectDiscipline"> | string
    disciplineId?: StringFilter<"ProjectDiscipline"> | string
    primaryDiscipline?: BoolFilter<"ProjectDiscipline"> | boolean
    contributionLevel?: StringFilter<"ProjectDiscipline"> | string
    createdAt?: DateTimeFilter<"ProjectDiscipline"> | Date | string
    discipline?: XOR<AcademicDisciplineRelationFilter, AcademicDisciplineWhereInput>
    project?: XOR<ResearchProjectRelationFilter, ResearchProjectWhereInput>
  }, "id" | "projectId_disciplineId">

  export type ProjectDisciplineOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    disciplineId?: SortOrder
    primaryDiscipline?: SortOrder
    contributionLevel?: SortOrder
    createdAt?: SortOrder
    _count?: ProjectDisciplineCountOrderByAggregateInput
    _max?: ProjectDisciplineMaxOrderByAggregateInput
    _min?: ProjectDisciplineMinOrderByAggregateInput
  }

  export type ProjectDisciplineScalarWhereWithAggregatesInput = {
    AND?: ProjectDisciplineScalarWhereWithAggregatesInput | ProjectDisciplineScalarWhereWithAggregatesInput[]
    OR?: ProjectDisciplineScalarWhereWithAggregatesInput[]
    NOT?: ProjectDisciplineScalarWhereWithAggregatesInput | ProjectDisciplineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectDiscipline"> | string
    projectId?: StringWithAggregatesFilter<"ProjectDiscipline"> | string
    disciplineId?: StringWithAggregatesFilter<"ProjectDiscipline"> | string
    primaryDiscipline?: BoolWithAggregatesFilter<"ProjectDiscipline"> | boolean
    contributionLevel?: StringWithAggregatesFilter<"ProjectDiscipline"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProjectDiscipline"> | Date | string
  }

  export type ProjectOccupationWhereInput = {
    AND?: ProjectOccupationWhereInput | ProjectOccupationWhereInput[]
    OR?: ProjectOccupationWhereInput[]
    NOT?: ProjectOccupationWhereInput | ProjectOccupationWhereInput[]
    id?: StringFilter<"ProjectOccupation"> | string
    projectId?: StringFilter<"ProjectOccupation"> | string
    occupationId?: StringFilter<"ProjectOccupation"> | string
    relevanceLevel?: StringFilter<"ProjectOccupation"> | string
    roleDescription?: StringNullableFilter<"ProjectOccupation"> | string | null
    createdAt?: DateTimeFilter<"ProjectOccupation"> | Date | string
    occupation?: XOR<OnetOccupationRelationFilter, OnetOccupationWhereInput>
    project?: XOR<ResearchProjectRelationFilter, ResearchProjectWhereInput>
  }

  export type ProjectOccupationOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    occupationId?: SortOrder
    relevanceLevel?: SortOrder
    roleDescription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    occupation?: OnetOccupationOrderByWithRelationInput
    project?: ResearchProjectOrderByWithRelationInput
  }

  export type ProjectOccupationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_occupationId?: ProjectOccupationProjectIdOccupationIdCompoundUniqueInput
    AND?: ProjectOccupationWhereInput | ProjectOccupationWhereInput[]
    OR?: ProjectOccupationWhereInput[]
    NOT?: ProjectOccupationWhereInput | ProjectOccupationWhereInput[]
    projectId?: StringFilter<"ProjectOccupation"> | string
    occupationId?: StringFilter<"ProjectOccupation"> | string
    relevanceLevel?: StringFilter<"ProjectOccupation"> | string
    roleDescription?: StringNullableFilter<"ProjectOccupation"> | string | null
    createdAt?: DateTimeFilter<"ProjectOccupation"> | Date | string
    occupation?: XOR<OnetOccupationRelationFilter, OnetOccupationWhereInput>
    project?: XOR<ResearchProjectRelationFilter, ResearchProjectWhereInput>
  }, "id" | "projectId_occupationId">

  export type ProjectOccupationOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    occupationId?: SortOrder
    relevanceLevel?: SortOrder
    roleDescription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProjectOccupationCountOrderByAggregateInput
    _max?: ProjectOccupationMaxOrderByAggregateInput
    _min?: ProjectOccupationMinOrderByAggregateInput
  }

  export type ProjectOccupationScalarWhereWithAggregatesInput = {
    AND?: ProjectOccupationScalarWhereWithAggregatesInput | ProjectOccupationScalarWhereWithAggregatesInput[]
    OR?: ProjectOccupationScalarWhereWithAggregatesInput[]
    NOT?: ProjectOccupationScalarWhereWithAggregatesInput | ProjectOccupationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectOccupation"> | string
    projectId?: StringWithAggregatesFilter<"ProjectOccupation"> | string
    occupationId?: StringWithAggregatesFilter<"ProjectOccupation"> | string
    relevanceLevel?: StringWithAggregatesFilter<"ProjectOccupation"> | string
    roleDescription?: StringNullableWithAggregatesFilter<"ProjectOccupation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProjectOccupation"> | Date | string
  }

  export type MethodologyStepWhereInput = {
    AND?: MethodologyStepWhereInput | MethodologyStepWhereInput[]
    OR?: MethodologyStepWhereInput[]
    NOT?: MethodologyStepWhereInput | MethodologyStepWhereInput[]
    id?: StringFilter<"MethodologyStep"> | string
    name?: StringFilter<"MethodologyStep"> | string
    description?: StringNullableFilter<"MethodologyStep"> | string | null
    methodologyType?: EnumMethodologyTypeFilter<"MethodologyStep"> | $Enums.MethodologyType
    stepOrder?: IntFilter<"MethodologyStep"> | number
    estimatedDurationHours?: IntNullableFilter<"MethodologyStep"> | number | null
    requiredResources?: StringNullableListFilter<"MethodologyStep">
    deliverables?: StringNullableListFilter<"MethodologyStep">
    successCriteria?: StringNullableListFilter<"MethodologyStep">
    dependencies?: StringNullableListFilter<"MethodologyStep">
    templateData?: JsonFilter<"MethodologyStep">
    isActive?: BoolFilter<"MethodologyStep"> | boolean
    createdAt?: DateTimeFilter<"MethodologyStep"> | Date | string
    projectSteps?: ProjectMethodologyStepListRelationFilter
  }

  export type MethodologyStepOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    methodologyType?: SortOrder
    stepOrder?: SortOrder
    estimatedDurationHours?: SortOrderInput | SortOrder
    requiredResources?: SortOrder
    deliverables?: SortOrder
    successCriteria?: SortOrder
    dependencies?: SortOrder
    templateData?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    projectSteps?: ProjectMethodologyStepOrderByRelationAggregateInput
  }

  export type MethodologyStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MethodologyStepWhereInput | MethodologyStepWhereInput[]
    OR?: MethodologyStepWhereInput[]
    NOT?: MethodologyStepWhereInput | MethodologyStepWhereInput[]
    name?: StringFilter<"MethodologyStep"> | string
    description?: StringNullableFilter<"MethodologyStep"> | string | null
    methodologyType?: EnumMethodologyTypeFilter<"MethodologyStep"> | $Enums.MethodologyType
    stepOrder?: IntFilter<"MethodologyStep"> | number
    estimatedDurationHours?: IntNullableFilter<"MethodologyStep"> | number | null
    requiredResources?: StringNullableListFilter<"MethodologyStep">
    deliverables?: StringNullableListFilter<"MethodologyStep">
    successCriteria?: StringNullableListFilter<"MethodologyStep">
    dependencies?: StringNullableListFilter<"MethodologyStep">
    templateData?: JsonFilter<"MethodologyStep">
    isActive?: BoolFilter<"MethodologyStep"> | boolean
    createdAt?: DateTimeFilter<"MethodologyStep"> | Date | string
    projectSteps?: ProjectMethodologyStepListRelationFilter
  }, "id">

  export type MethodologyStepOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    methodologyType?: SortOrder
    stepOrder?: SortOrder
    estimatedDurationHours?: SortOrderInput | SortOrder
    requiredResources?: SortOrder
    deliverables?: SortOrder
    successCriteria?: SortOrder
    dependencies?: SortOrder
    templateData?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: MethodologyStepCountOrderByAggregateInput
    _avg?: MethodologyStepAvgOrderByAggregateInput
    _max?: MethodologyStepMaxOrderByAggregateInput
    _min?: MethodologyStepMinOrderByAggregateInput
    _sum?: MethodologyStepSumOrderByAggregateInput
  }

  export type MethodologyStepScalarWhereWithAggregatesInput = {
    AND?: MethodologyStepScalarWhereWithAggregatesInput | MethodologyStepScalarWhereWithAggregatesInput[]
    OR?: MethodologyStepScalarWhereWithAggregatesInput[]
    NOT?: MethodologyStepScalarWhereWithAggregatesInput | MethodologyStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MethodologyStep"> | string
    name?: StringWithAggregatesFilter<"MethodologyStep"> | string
    description?: StringNullableWithAggregatesFilter<"MethodologyStep"> | string | null
    methodologyType?: EnumMethodologyTypeWithAggregatesFilter<"MethodologyStep"> | $Enums.MethodologyType
    stepOrder?: IntWithAggregatesFilter<"MethodologyStep"> | number
    estimatedDurationHours?: IntNullableWithAggregatesFilter<"MethodologyStep"> | number | null
    requiredResources?: StringNullableListFilter<"MethodologyStep">
    deliverables?: StringNullableListFilter<"MethodologyStep">
    successCriteria?: StringNullableListFilter<"MethodologyStep">
    dependencies?: StringNullableListFilter<"MethodologyStep">
    templateData?: JsonWithAggregatesFilter<"MethodologyStep">
    isActive?: BoolWithAggregatesFilter<"MethodologyStep"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MethodologyStep"> | Date | string
  }

  export type ProjectMethodologyStepWhereInput = {
    AND?: ProjectMethodologyStepWhereInput | ProjectMethodologyStepWhereInput[]
    OR?: ProjectMethodologyStepWhereInput[]
    NOT?: ProjectMethodologyStepWhereInput | ProjectMethodologyStepWhereInput[]
    id?: StringFilter<"ProjectMethodologyStep"> | string
    projectId?: StringFilter<"ProjectMethodologyStep"> | string
    methodologyStepId?: StringFilter<"ProjectMethodologyStep"> | string
    assignedToId?: StringNullableFilter<"ProjectMethodologyStep"> | string | null
    status?: StringFilter<"ProjectMethodologyStep"> | string
    actualStartDate?: DateTimeNullableFilter<"ProjectMethodologyStep"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"ProjectMethodologyStep"> | Date | string | null
    notes?: StringNullableFilter<"ProjectMethodologyStep"> | string | null
    deliverablesUploaded?: StringNullableListFilter<"ProjectMethodologyStep">
    completionPercentage?: IntFilter<"ProjectMethodologyStep"> | number
    createdAt?: DateTimeFilter<"ProjectMethodologyStep"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMethodologyStep"> | Date | string
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    methodologyStep?: XOR<MethodologyStepRelationFilter, MethodologyStepWhereInput>
    project?: XOR<ResearchProjectRelationFilter, ResearchProjectWhereInput>
  }

  export type ProjectMethodologyStepOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    methodologyStepId?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    status?: SortOrder
    actualStartDate?: SortOrderInput | SortOrder
    actualEndDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    deliverablesUploaded?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedTo?: UserOrderByWithRelationInput
    methodologyStep?: MethodologyStepOrderByWithRelationInput
    project?: ResearchProjectOrderByWithRelationInput
  }

  export type ProjectMethodologyStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_methodologyStepId?: ProjectMethodologyStepProjectIdMethodologyStepIdCompoundUniqueInput
    AND?: ProjectMethodologyStepWhereInput | ProjectMethodologyStepWhereInput[]
    OR?: ProjectMethodologyStepWhereInput[]
    NOT?: ProjectMethodologyStepWhereInput | ProjectMethodologyStepWhereInput[]
    projectId?: StringFilter<"ProjectMethodologyStep"> | string
    methodologyStepId?: StringFilter<"ProjectMethodologyStep"> | string
    assignedToId?: StringNullableFilter<"ProjectMethodologyStep"> | string | null
    status?: StringFilter<"ProjectMethodologyStep"> | string
    actualStartDate?: DateTimeNullableFilter<"ProjectMethodologyStep"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"ProjectMethodologyStep"> | Date | string | null
    notes?: StringNullableFilter<"ProjectMethodologyStep"> | string | null
    deliverablesUploaded?: StringNullableListFilter<"ProjectMethodologyStep">
    completionPercentage?: IntFilter<"ProjectMethodologyStep"> | number
    createdAt?: DateTimeFilter<"ProjectMethodologyStep"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMethodologyStep"> | Date | string
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    methodologyStep?: XOR<MethodologyStepRelationFilter, MethodologyStepWhereInput>
    project?: XOR<ResearchProjectRelationFilter, ResearchProjectWhereInput>
  }, "id" | "projectId_methodologyStepId">

  export type ProjectMethodologyStepOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    methodologyStepId?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    status?: SortOrder
    actualStartDate?: SortOrderInput | SortOrder
    actualEndDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    deliverablesUploaded?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectMethodologyStepCountOrderByAggregateInput
    _avg?: ProjectMethodologyStepAvgOrderByAggregateInput
    _max?: ProjectMethodologyStepMaxOrderByAggregateInput
    _min?: ProjectMethodologyStepMinOrderByAggregateInput
    _sum?: ProjectMethodologyStepSumOrderByAggregateInput
  }

  export type ProjectMethodologyStepScalarWhereWithAggregatesInput = {
    AND?: ProjectMethodologyStepScalarWhereWithAggregatesInput | ProjectMethodologyStepScalarWhereWithAggregatesInput[]
    OR?: ProjectMethodologyStepScalarWhereWithAggregatesInput[]
    NOT?: ProjectMethodologyStepScalarWhereWithAggregatesInput | ProjectMethodologyStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectMethodologyStep"> | string
    projectId?: StringWithAggregatesFilter<"ProjectMethodologyStep"> | string
    methodologyStepId?: StringWithAggregatesFilter<"ProjectMethodologyStep"> | string
    assignedToId?: StringNullableWithAggregatesFilter<"ProjectMethodologyStep"> | string | null
    status?: StringWithAggregatesFilter<"ProjectMethodologyStep"> | string
    actualStartDate?: DateTimeNullableWithAggregatesFilter<"ProjectMethodologyStep"> | Date | string | null
    actualEndDate?: DateTimeNullableWithAggregatesFilter<"ProjectMethodologyStep"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"ProjectMethodologyStep"> | string | null
    deliverablesUploaded?: StringNullableListFilter<"ProjectMethodologyStep">
    completionPercentage?: IntWithAggregatesFilter<"ProjectMethodologyStep"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProjectMethodologyStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectMethodologyStep"> | Date | string
  }

  export type UploadedImageWhereInput = {
    AND?: UploadedImageWhereInput | UploadedImageWhereInput[]
    OR?: UploadedImageWhereInput[]
    NOT?: UploadedImageWhereInput | UploadedImageWhereInput[]
    id?: StringFilter<"UploadedImage"> | string
    projectId?: StringNullableFilter<"UploadedImage"> | string | null
    uploadedById?: StringFilter<"UploadedImage"> | string
    fileName?: StringFilter<"UploadedImage"> | string
    originalFileName?: StringNullableFilter<"UploadedImage"> | string | null
    filePath?: StringFilter<"UploadedImage"> | string
    fileSize?: BigIntNullableFilter<"UploadedImage"> | bigint | number | null
    mimeType?: StringNullableFilter<"UploadedImage"> | string | null
    imageType?: StringNullableFilter<"UploadedImage"> | string | null
    imageConfidence?: DecimalNullableFilter<"UploadedImage"> | Decimal | DecimalJsLike | number | string | null
    width?: IntNullableFilter<"UploadedImage"> | number | null
    height?: IntNullableFilter<"UploadedImage"> | number | null
    colorDepth?: IntNullableFilter<"UploadedImage"> | number | null
    hasMetadata?: BoolFilter<"UploadedImage"> | boolean
    dicomMetadata?: JsonNullableFilter<"UploadedImage">
    analysisStatus?: EnumAnalysisStatusFilter<"UploadedImage"> | $Enums.AnalysisStatus
    tags?: StringNullableListFilter<"UploadedImage">
    description?: StringNullableFilter<"UploadedImage"> | string | null
    consentObtained?: BoolFilter<"UploadedImage"> | boolean
    dataClassification?: StringFilter<"UploadedImage"> | string
    anonymized?: BoolFilter<"UploadedImage"> | boolean
    processingStartedAt?: DateTimeNullableFilter<"UploadedImage"> | Date | string | null
    processingCompletedAt?: DateTimeNullableFilter<"UploadedImage"> | Date | string | null
    createdAt?: DateTimeFilter<"UploadedImage"> | Date | string
    updatedAt?: DateTimeFilter<"UploadedImage"> | Date | string
    analyses?: ResearchAnalysisListRelationFilter
    project?: XOR<ResearchProjectNullableRelationFilter, ResearchProjectWhereInput> | null
    uploadedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UploadedImageOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    fileName?: SortOrder
    originalFileName?: SortOrderInput | SortOrder
    filePath?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    imageType?: SortOrderInput | SortOrder
    imageConfidence?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    colorDepth?: SortOrderInput | SortOrder
    hasMetadata?: SortOrder
    dicomMetadata?: SortOrderInput | SortOrder
    analysisStatus?: SortOrder
    tags?: SortOrder
    description?: SortOrderInput | SortOrder
    consentObtained?: SortOrder
    dataClassification?: SortOrder
    anonymized?: SortOrder
    processingStartedAt?: SortOrderInput | SortOrder
    processingCompletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    analyses?: ResearchAnalysisOrderByRelationAggregateInput
    project?: ResearchProjectOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type UploadedImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UploadedImageWhereInput | UploadedImageWhereInput[]
    OR?: UploadedImageWhereInput[]
    NOT?: UploadedImageWhereInput | UploadedImageWhereInput[]
    projectId?: StringNullableFilter<"UploadedImage"> | string | null
    uploadedById?: StringFilter<"UploadedImage"> | string
    fileName?: StringFilter<"UploadedImage"> | string
    originalFileName?: StringNullableFilter<"UploadedImage"> | string | null
    filePath?: StringFilter<"UploadedImage"> | string
    fileSize?: BigIntNullableFilter<"UploadedImage"> | bigint | number | null
    mimeType?: StringNullableFilter<"UploadedImage"> | string | null
    imageType?: StringNullableFilter<"UploadedImage"> | string | null
    imageConfidence?: DecimalNullableFilter<"UploadedImage"> | Decimal | DecimalJsLike | number | string | null
    width?: IntNullableFilter<"UploadedImage"> | number | null
    height?: IntNullableFilter<"UploadedImage"> | number | null
    colorDepth?: IntNullableFilter<"UploadedImage"> | number | null
    hasMetadata?: BoolFilter<"UploadedImage"> | boolean
    dicomMetadata?: JsonNullableFilter<"UploadedImage">
    analysisStatus?: EnumAnalysisStatusFilter<"UploadedImage"> | $Enums.AnalysisStatus
    tags?: StringNullableListFilter<"UploadedImage">
    description?: StringNullableFilter<"UploadedImage"> | string | null
    consentObtained?: BoolFilter<"UploadedImage"> | boolean
    dataClassification?: StringFilter<"UploadedImage"> | string
    anonymized?: BoolFilter<"UploadedImage"> | boolean
    processingStartedAt?: DateTimeNullableFilter<"UploadedImage"> | Date | string | null
    processingCompletedAt?: DateTimeNullableFilter<"UploadedImage"> | Date | string | null
    createdAt?: DateTimeFilter<"UploadedImage"> | Date | string
    updatedAt?: DateTimeFilter<"UploadedImage"> | Date | string
    analyses?: ResearchAnalysisListRelationFilter
    project?: XOR<ResearchProjectNullableRelationFilter, ResearchProjectWhereInput> | null
    uploadedBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UploadedImageOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    fileName?: SortOrder
    originalFileName?: SortOrderInput | SortOrder
    filePath?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    imageType?: SortOrderInput | SortOrder
    imageConfidence?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    colorDepth?: SortOrderInput | SortOrder
    hasMetadata?: SortOrder
    dicomMetadata?: SortOrderInput | SortOrder
    analysisStatus?: SortOrder
    tags?: SortOrder
    description?: SortOrderInput | SortOrder
    consentObtained?: SortOrder
    dataClassification?: SortOrder
    anonymized?: SortOrder
    processingStartedAt?: SortOrderInput | SortOrder
    processingCompletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UploadedImageCountOrderByAggregateInput
    _avg?: UploadedImageAvgOrderByAggregateInput
    _max?: UploadedImageMaxOrderByAggregateInput
    _min?: UploadedImageMinOrderByAggregateInput
    _sum?: UploadedImageSumOrderByAggregateInput
  }

  export type UploadedImageScalarWhereWithAggregatesInput = {
    AND?: UploadedImageScalarWhereWithAggregatesInput | UploadedImageScalarWhereWithAggregatesInput[]
    OR?: UploadedImageScalarWhereWithAggregatesInput[]
    NOT?: UploadedImageScalarWhereWithAggregatesInput | UploadedImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UploadedImage"> | string
    projectId?: StringNullableWithAggregatesFilter<"UploadedImage"> | string | null
    uploadedById?: StringWithAggregatesFilter<"UploadedImage"> | string
    fileName?: StringWithAggregatesFilter<"UploadedImage"> | string
    originalFileName?: StringNullableWithAggregatesFilter<"UploadedImage"> | string | null
    filePath?: StringWithAggregatesFilter<"UploadedImage"> | string
    fileSize?: BigIntNullableWithAggregatesFilter<"UploadedImage"> | bigint | number | null
    mimeType?: StringNullableWithAggregatesFilter<"UploadedImage"> | string | null
    imageType?: StringNullableWithAggregatesFilter<"UploadedImage"> | string | null
    imageConfidence?: DecimalNullableWithAggregatesFilter<"UploadedImage"> | Decimal | DecimalJsLike | number | string | null
    width?: IntNullableWithAggregatesFilter<"UploadedImage"> | number | null
    height?: IntNullableWithAggregatesFilter<"UploadedImage"> | number | null
    colorDepth?: IntNullableWithAggregatesFilter<"UploadedImage"> | number | null
    hasMetadata?: BoolWithAggregatesFilter<"UploadedImage"> | boolean
    dicomMetadata?: JsonNullableWithAggregatesFilter<"UploadedImage">
    analysisStatus?: EnumAnalysisStatusWithAggregatesFilter<"UploadedImage"> | $Enums.AnalysisStatus
    tags?: StringNullableListFilter<"UploadedImage">
    description?: StringNullableWithAggregatesFilter<"UploadedImage"> | string | null
    consentObtained?: BoolWithAggregatesFilter<"UploadedImage"> | boolean
    dataClassification?: StringWithAggregatesFilter<"UploadedImage"> | string
    anonymized?: BoolWithAggregatesFilter<"UploadedImage"> | boolean
    processingStartedAt?: DateTimeNullableWithAggregatesFilter<"UploadedImage"> | Date | string | null
    processingCompletedAt?: DateTimeNullableWithAggregatesFilter<"UploadedImage"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UploadedImage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UploadedImage"> | Date | string
  }

  export type ResearchAnalysisWhereInput = {
    AND?: ResearchAnalysisWhereInput | ResearchAnalysisWhereInput[]
    OR?: ResearchAnalysisWhereInput[]
    NOT?: ResearchAnalysisWhereInput | ResearchAnalysisWhereInput[]
    id?: StringFilter<"ResearchAnalysis"> | string
    projectId?: StringNullableFilter<"ResearchAnalysis"> | string | null
    imageId?: StringNullableFilter<"ResearchAnalysis"> | string | null
    analystId?: StringFilter<"ResearchAnalysis"> | string
    analysisType?: StringFilter<"ResearchAnalysis"> | string
    status?: EnumAnalysisStatusFilter<"ResearchAnalysis"> | $Enums.AnalysisStatus
    confidenceScore?: DecimalNullableFilter<"ResearchAnalysis"> | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: IntNullableFilter<"ResearchAnalysis"> | number | null
    algorithmVersion?: StringNullableFilter<"ResearchAnalysis"> | string | null
    modelUsed?: StringNullableFilter<"ResearchAnalysis"> | string | null
    findings?: JsonNullableFilter<"ResearchAnalysis">
    recommendations?: JsonNullableFilter<"ResearchAnalysis">
    differentialDiagnosis?: JsonNullableFilter<"ResearchAnalysis">
    severityAssessment?: JsonNullableFilter<"ResearchAnalysis">
    regionsOfInterest?: JsonNullableFilter<"ResearchAnalysis">
    qualityMetrics?: JsonNullableFilter<"ResearchAnalysis">
    errorMessage?: StringNullableFilter<"ResearchAnalysis"> | string | null
    reviewRequired?: BoolFilter<"ResearchAnalysis"> | boolean
    reviewedById?: StringNullableFilter<"ResearchAnalysis"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ResearchAnalysis"> | Date | string | null
    reviewNotes?: StringNullableFilter<"ResearchAnalysis"> | string | null
    approvedById?: StringNullableFilter<"ResearchAnalysis"> | string | null
    approvedAt?: DateTimeNullableFilter<"ResearchAnalysis"> | Date | string | null
    metadata?: JsonFilter<"ResearchAnalysis">
    createdAt?: DateTimeFilter<"ResearchAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchAnalysis"> | Date | string
    analyst?: XOR<UserRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    image?: XOR<UploadedImageNullableRelationFilter, UploadedImageWhereInput> | null
    project?: XOR<ResearchProjectNullableRelationFilter, ResearchProjectWhereInput> | null
    reviewedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ResearchAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrderInput | SortOrder
    imageId?: SortOrderInput | SortOrder
    analystId?: SortOrder
    analysisType?: SortOrder
    status?: SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    processingTimeSeconds?: SortOrderInput | SortOrder
    algorithmVersion?: SortOrderInput | SortOrder
    modelUsed?: SortOrderInput | SortOrder
    findings?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    differentialDiagnosis?: SortOrderInput | SortOrder
    severityAssessment?: SortOrderInput | SortOrder
    regionsOfInterest?: SortOrderInput | SortOrder
    qualityMetrics?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    reviewRequired?: SortOrder
    reviewedById?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    analyst?: UserOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
    image?: UploadedImageOrderByWithRelationInput
    project?: ResearchProjectOrderByWithRelationInput
    reviewedBy?: UserOrderByWithRelationInput
  }

  export type ResearchAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResearchAnalysisWhereInput | ResearchAnalysisWhereInput[]
    OR?: ResearchAnalysisWhereInput[]
    NOT?: ResearchAnalysisWhereInput | ResearchAnalysisWhereInput[]
    projectId?: StringNullableFilter<"ResearchAnalysis"> | string | null
    imageId?: StringNullableFilter<"ResearchAnalysis"> | string | null
    analystId?: StringFilter<"ResearchAnalysis"> | string
    analysisType?: StringFilter<"ResearchAnalysis"> | string
    status?: EnumAnalysisStatusFilter<"ResearchAnalysis"> | $Enums.AnalysisStatus
    confidenceScore?: DecimalNullableFilter<"ResearchAnalysis"> | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: IntNullableFilter<"ResearchAnalysis"> | number | null
    algorithmVersion?: StringNullableFilter<"ResearchAnalysis"> | string | null
    modelUsed?: StringNullableFilter<"ResearchAnalysis"> | string | null
    findings?: JsonNullableFilter<"ResearchAnalysis">
    recommendations?: JsonNullableFilter<"ResearchAnalysis">
    differentialDiagnosis?: JsonNullableFilter<"ResearchAnalysis">
    severityAssessment?: JsonNullableFilter<"ResearchAnalysis">
    regionsOfInterest?: JsonNullableFilter<"ResearchAnalysis">
    qualityMetrics?: JsonNullableFilter<"ResearchAnalysis">
    errorMessage?: StringNullableFilter<"ResearchAnalysis"> | string | null
    reviewRequired?: BoolFilter<"ResearchAnalysis"> | boolean
    reviewedById?: StringNullableFilter<"ResearchAnalysis"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ResearchAnalysis"> | Date | string | null
    reviewNotes?: StringNullableFilter<"ResearchAnalysis"> | string | null
    approvedById?: StringNullableFilter<"ResearchAnalysis"> | string | null
    approvedAt?: DateTimeNullableFilter<"ResearchAnalysis"> | Date | string | null
    metadata?: JsonFilter<"ResearchAnalysis">
    createdAt?: DateTimeFilter<"ResearchAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchAnalysis"> | Date | string
    analyst?: XOR<UserRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    image?: XOR<UploadedImageNullableRelationFilter, UploadedImageWhereInput> | null
    project?: XOR<ResearchProjectNullableRelationFilter, ResearchProjectWhereInput> | null
    reviewedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ResearchAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrderInput | SortOrder
    imageId?: SortOrderInput | SortOrder
    analystId?: SortOrder
    analysisType?: SortOrder
    status?: SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    processingTimeSeconds?: SortOrderInput | SortOrder
    algorithmVersion?: SortOrderInput | SortOrder
    modelUsed?: SortOrderInput | SortOrder
    findings?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    differentialDiagnosis?: SortOrderInput | SortOrder
    severityAssessment?: SortOrderInput | SortOrder
    regionsOfInterest?: SortOrderInput | SortOrder
    qualityMetrics?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    reviewRequired?: SortOrder
    reviewedById?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResearchAnalysisCountOrderByAggregateInput
    _avg?: ResearchAnalysisAvgOrderByAggregateInput
    _max?: ResearchAnalysisMaxOrderByAggregateInput
    _min?: ResearchAnalysisMinOrderByAggregateInput
    _sum?: ResearchAnalysisSumOrderByAggregateInput
  }

  export type ResearchAnalysisScalarWhereWithAggregatesInput = {
    AND?: ResearchAnalysisScalarWhereWithAggregatesInput | ResearchAnalysisScalarWhereWithAggregatesInput[]
    OR?: ResearchAnalysisScalarWhereWithAggregatesInput[]
    NOT?: ResearchAnalysisScalarWhereWithAggregatesInput | ResearchAnalysisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResearchAnalysis"> | string
    projectId?: StringNullableWithAggregatesFilter<"ResearchAnalysis"> | string | null
    imageId?: StringNullableWithAggregatesFilter<"ResearchAnalysis"> | string | null
    analystId?: StringWithAggregatesFilter<"ResearchAnalysis"> | string
    analysisType?: StringWithAggregatesFilter<"ResearchAnalysis"> | string
    status?: EnumAnalysisStatusWithAggregatesFilter<"ResearchAnalysis"> | $Enums.AnalysisStatus
    confidenceScore?: DecimalNullableWithAggregatesFilter<"ResearchAnalysis"> | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: IntNullableWithAggregatesFilter<"ResearchAnalysis"> | number | null
    algorithmVersion?: StringNullableWithAggregatesFilter<"ResearchAnalysis"> | string | null
    modelUsed?: StringNullableWithAggregatesFilter<"ResearchAnalysis"> | string | null
    findings?: JsonNullableWithAggregatesFilter<"ResearchAnalysis">
    recommendations?: JsonNullableWithAggregatesFilter<"ResearchAnalysis">
    differentialDiagnosis?: JsonNullableWithAggregatesFilter<"ResearchAnalysis">
    severityAssessment?: JsonNullableWithAggregatesFilter<"ResearchAnalysis">
    regionsOfInterest?: JsonNullableWithAggregatesFilter<"ResearchAnalysis">
    qualityMetrics?: JsonNullableWithAggregatesFilter<"ResearchAnalysis">
    errorMessage?: StringNullableWithAggregatesFilter<"ResearchAnalysis"> | string | null
    reviewRequired?: BoolWithAggregatesFilter<"ResearchAnalysis"> | boolean
    reviewedById?: StringNullableWithAggregatesFilter<"ResearchAnalysis"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"ResearchAnalysis"> | Date | string | null
    reviewNotes?: StringNullableWithAggregatesFilter<"ResearchAnalysis"> | string | null
    approvedById?: StringNullableWithAggregatesFilter<"ResearchAnalysis"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"ResearchAnalysis"> | Date | string | null
    metadata?: JsonWithAggregatesFilter<"ResearchAnalysis">
    createdAt?: DateTimeWithAggregatesFilter<"ResearchAnalysis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ResearchAnalysis"> | Date | string
  }

  export type KnowledgeIntegrationWhereInput = {
    AND?: KnowledgeIntegrationWhereInput | KnowledgeIntegrationWhereInput[]
    OR?: KnowledgeIntegrationWhereInput[]
    NOT?: KnowledgeIntegrationWhereInput | KnowledgeIntegrationWhereInput[]
    id?: StringFilter<"KnowledgeIntegration"> | string
    projectId?: StringFilter<"KnowledgeIntegration"> | string
    sourceDisciplineId?: StringFilter<"KnowledgeIntegration"> | string
    targetDisciplineId?: StringFilter<"KnowledgeIntegration"> | string
    integrationType?: EnumKnowledgeIntegrationTypeFilter<"KnowledgeIntegration"> | $Enums.KnowledgeIntegrationType
    title?: StringFilter<"KnowledgeIntegration"> | string
    description?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    sourceKnowledge?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    targetApplication?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    integrationMethod?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    validationStatus?: StringFilter<"KnowledgeIntegration"> | string
    validationNotes?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    noveltyScore?: DecimalNullableFilter<"KnowledgeIntegration"> | Decimal | DecimalJsLike | number | string | null
    impactPotential?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    implementationFeasibility?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    references?: StringNullableListFilter<"KnowledgeIntegration">
    supportingEvidence?: JsonNullableFilter<"KnowledgeIntegration">
    createdById?: StringFilter<"KnowledgeIntegration"> | string
    createdAt?: DateTimeFilter<"KnowledgeIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeIntegration"> | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ResearchProjectRelationFilter, ResearchProjectWhereInput>
    sourceDiscipline?: XOR<AcademicDisciplineRelationFilter, AcademicDisciplineWhereInput>
    targetDiscipline?: XOR<AcademicDisciplineRelationFilter, AcademicDisciplineWhereInput>
  }

  export type KnowledgeIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    sourceDisciplineId?: SortOrder
    targetDisciplineId?: SortOrder
    integrationType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    sourceKnowledge?: SortOrderInput | SortOrder
    targetApplication?: SortOrderInput | SortOrder
    integrationMethod?: SortOrderInput | SortOrder
    validationStatus?: SortOrder
    validationNotes?: SortOrderInput | SortOrder
    noveltyScore?: SortOrderInput | SortOrder
    impactPotential?: SortOrderInput | SortOrder
    implementationFeasibility?: SortOrderInput | SortOrder
    references?: SortOrder
    supportingEvidence?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    project?: ResearchProjectOrderByWithRelationInput
    sourceDiscipline?: AcademicDisciplineOrderByWithRelationInput
    targetDiscipline?: AcademicDisciplineOrderByWithRelationInput
  }

  export type KnowledgeIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeIntegrationWhereInput | KnowledgeIntegrationWhereInput[]
    OR?: KnowledgeIntegrationWhereInput[]
    NOT?: KnowledgeIntegrationWhereInput | KnowledgeIntegrationWhereInput[]
    projectId?: StringFilter<"KnowledgeIntegration"> | string
    sourceDisciplineId?: StringFilter<"KnowledgeIntegration"> | string
    targetDisciplineId?: StringFilter<"KnowledgeIntegration"> | string
    integrationType?: EnumKnowledgeIntegrationTypeFilter<"KnowledgeIntegration"> | $Enums.KnowledgeIntegrationType
    title?: StringFilter<"KnowledgeIntegration"> | string
    description?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    sourceKnowledge?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    targetApplication?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    integrationMethod?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    validationStatus?: StringFilter<"KnowledgeIntegration"> | string
    validationNotes?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    noveltyScore?: DecimalNullableFilter<"KnowledgeIntegration"> | Decimal | DecimalJsLike | number | string | null
    impactPotential?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    implementationFeasibility?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    references?: StringNullableListFilter<"KnowledgeIntegration">
    supportingEvidence?: JsonNullableFilter<"KnowledgeIntegration">
    createdById?: StringFilter<"KnowledgeIntegration"> | string
    createdAt?: DateTimeFilter<"KnowledgeIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeIntegration"> | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ResearchProjectRelationFilter, ResearchProjectWhereInput>
    sourceDiscipline?: XOR<AcademicDisciplineRelationFilter, AcademicDisciplineWhereInput>
    targetDiscipline?: XOR<AcademicDisciplineRelationFilter, AcademicDisciplineWhereInput>
  }, "id">

  export type KnowledgeIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    sourceDisciplineId?: SortOrder
    targetDisciplineId?: SortOrder
    integrationType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    sourceKnowledge?: SortOrderInput | SortOrder
    targetApplication?: SortOrderInput | SortOrder
    integrationMethod?: SortOrderInput | SortOrder
    validationStatus?: SortOrder
    validationNotes?: SortOrderInput | SortOrder
    noveltyScore?: SortOrderInput | SortOrder
    impactPotential?: SortOrderInput | SortOrder
    implementationFeasibility?: SortOrderInput | SortOrder
    references?: SortOrder
    supportingEvidence?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KnowledgeIntegrationCountOrderByAggregateInput
    _avg?: KnowledgeIntegrationAvgOrderByAggregateInput
    _max?: KnowledgeIntegrationMaxOrderByAggregateInput
    _min?: KnowledgeIntegrationMinOrderByAggregateInput
    _sum?: KnowledgeIntegrationSumOrderByAggregateInput
  }

  export type KnowledgeIntegrationScalarWhereWithAggregatesInput = {
    AND?: KnowledgeIntegrationScalarWhereWithAggregatesInput | KnowledgeIntegrationScalarWhereWithAggregatesInput[]
    OR?: KnowledgeIntegrationScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeIntegrationScalarWhereWithAggregatesInput | KnowledgeIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeIntegration"> | string
    projectId?: StringWithAggregatesFilter<"KnowledgeIntegration"> | string
    sourceDisciplineId?: StringWithAggregatesFilter<"KnowledgeIntegration"> | string
    targetDisciplineId?: StringWithAggregatesFilter<"KnowledgeIntegration"> | string
    integrationType?: EnumKnowledgeIntegrationTypeWithAggregatesFilter<"KnowledgeIntegration"> | $Enums.KnowledgeIntegrationType
    title?: StringWithAggregatesFilter<"KnowledgeIntegration"> | string
    description?: StringNullableWithAggregatesFilter<"KnowledgeIntegration"> | string | null
    sourceKnowledge?: StringNullableWithAggregatesFilter<"KnowledgeIntegration"> | string | null
    targetApplication?: StringNullableWithAggregatesFilter<"KnowledgeIntegration"> | string | null
    integrationMethod?: StringNullableWithAggregatesFilter<"KnowledgeIntegration"> | string | null
    validationStatus?: StringWithAggregatesFilter<"KnowledgeIntegration"> | string
    validationNotes?: StringNullableWithAggregatesFilter<"KnowledgeIntegration"> | string | null
    noveltyScore?: DecimalNullableWithAggregatesFilter<"KnowledgeIntegration"> | Decimal | DecimalJsLike | number | string | null
    impactPotential?: StringNullableWithAggregatesFilter<"KnowledgeIntegration"> | string | null
    implementationFeasibility?: StringNullableWithAggregatesFilter<"KnowledgeIntegration"> | string | null
    references?: StringNullableListFilter<"KnowledgeIntegration">
    supportingEvidence?: JsonNullableWithAggregatesFilter<"KnowledgeIntegration">
    createdById?: StringWithAggregatesFilter<"KnowledgeIntegration"> | string
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KnowledgeIntegration"> | Date | string
  }

  export type ProjectCollaboratorWhereInput = {
    AND?: ProjectCollaboratorWhereInput | ProjectCollaboratorWhereInput[]
    OR?: ProjectCollaboratorWhereInput[]
    NOT?: ProjectCollaboratorWhereInput | ProjectCollaboratorWhereInput[]
    id?: StringFilter<"ProjectCollaborator"> | string
    projectId?: StringFilter<"ProjectCollaborator"> | string
    userId?: StringFilter<"ProjectCollaborator"> | string
    role?: StringFilter<"ProjectCollaborator"> | string
    permissions?: JsonFilter<"ProjectCollaborator">
    contributionDescription?: StringNullableFilter<"ProjectCollaborator"> | string | null
    joinedAt?: DateTimeFilter<"ProjectCollaborator"> | Date | string
    status?: StringFilter<"ProjectCollaborator"> | string
    project?: XOR<ResearchProjectRelationFilter, ResearchProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProjectCollaboratorOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    contributionDescription?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    project?: ResearchProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectCollaboratorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_userId?: ProjectCollaboratorProjectIdUserIdCompoundUniqueInput
    AND?: ProjectCollaboratorWhereInput | ProjectCollaboratorWhereInput[]
    OR?: ProjectCollaboratorWhereInput[]
    NOT?: ProjectCollaboratorWhereInput | ProjectCollaboratorWhereInput[]
    projectId?: StringFilter<"ProjectCollaborator"> | string
    userId?: StringFilter<"ProjectCollaborator"> | string
    role?: StringFilter<"ProjectCollaborator"> | string
    permissions?: JsonFilter<"ProjectCollaborator">
    contributionDescription?: StringNullableFilter<"ProjectCollaborator"> | string | null
    joinedAt?: DateTimeFilter<"ProjectCollaborator"> | Date | string
    status?: StringFilter<"ProjectCollaborator"> | string
    project?: XOR<ResearchProjectRelationFilter, ResearchProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "projectId_userId">

  export type ProjectCollaboratorOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    contributionDescription?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    _count?: ProjectCollaboratorCountOrderByAggregateInput
    _max?: ProjectCollaboratorMaxOrderByAggregateInput
    _min?: ProjectCollaboratorMinOrderByAggregateInput
  }

  export type ProjectCollaboratorScalarWhereWithAggregatesInput = {
    AND?: ProjectCollaboratorScalarWhereWithAggregatesInput | ProjectCollaboratorScalarWhereWithAggregatesInput[]
    OR?: ProjectCollaboratorScalarWhereWithAggregatesInput[]
    NOT?: ProjectCollaboratorScalarWhereWithAggregatesInput | ProjectCollaboratorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectCollaborator"> | string
    projectId?: StringWithAggregatesFilter<"ProjectCollaborator"> | string
    userId?: StringWithAggregatesFilter<"ProjectCollaborator"> | string
    role?: StringWithAggregatesFilter<"ProjectCollaborator"> | string
    permissions?: JsonWithAggregatesFilter<"ProjectCollaborator">
    contributionDescription?: StringNullableWithAggregatesFilter<"ProjectCollaborator"> | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"ProjectCollaborator"> | Date | string
    status?: StringWithAggregatesFilter<"ProjectCollaborator"> | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    knowledgeIntegrations?: KnowledgeIntegrationCreateNestedManyWithoutCreatedByInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    assignedMethodologySteps?: ProjectMethodologyStepCreateNestedManyWithoutAssignedToInput
    analyses?: ResearchAnalysisCreateNestedManyWithoutAnalystInput
    approvedAnalyses?: ResearchAnalysisCreateNestedManyWithoutApprovedByInput
    reviewedAnalyses?: ResearchAnalysisCreateNestedManyWithoutReviewedByInput
    projects?: ResearchProjectCreateNestedManyWithoutPrincipalInvestigatorInput
    uploadedImages?: UploadedImageCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutCreatedByInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    assignedMethodologySteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutAssignedToInput
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutAnalystInput
    approvedAnalyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutApprovedByInput
    reviewedAnalyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutReviewedByInput
    projects?: ResearchProjectUncheckedCreateNestedManyWithoutPrincipalInvestigatorInput
    uploadedImages?: UploadedImageUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    knowledgeIntegrations?: KnowledgeIntegrationUpdateManyWithoutCreatedByNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    assignedMethodologySteps?: ProjectMethodologyStepUpdateManyWithoutAssignedToNestedInput
    analyses?: ResearchAnalysisUpdateManyWithoutAnalystNestedInput
    approvedAnalyses?: ResearchAnalysisUpdateManyWithoutApprovedByNestedInput
    reviewedAnalyses?: ResearchAnalysisUpdateManyWithoutReviewedByNestedInput
    projects?: ResearchProjectUpdateManyWithoutPrincipalInvestigatorNestedInput
    uploadedImages?: UploadedImageUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedUpdateManyWithoutCreatedByNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    assignedMethodologySteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutAssignedToNestedInput
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutAnalystNestedInput
    approvedAnalyses?: ResearchAnalysisUncheckedUpdateManyWithoutApprovedByNestedInput
    reviewedAnalyses?: ResearchAnalysisUncheckedUpdateManyWithoutReviewedByNestedInput
    projects?: ResearchProjectUncheckedUpdateManyWithoutPrincipalInvestigatorNestedInput
    uploadedImages?: UploadedImageUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AcademicDisciplineCreateInput = {
    id?: string
    code: string
    name: string
    level?: number
    description?: string | null
    keywords?: AcademicDisciplineCreatekeywordsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    parentDiscipline?: AcademicDisciplineCreateNestedOneWithoutChildDisciplinesInput
    childDisciplines?: AcademicDisciplineCreateNestedManyWithoutParentDisciplineInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationCreateNestedManyWithoutSourceDisciplineInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationCreateNestedManyWithoutTargetDisciplineInput
    projectDisciplines?: ProjectDisciplineCreateNestedManyWithoutDisciplineInput
  }

  export type AcademicDisciplineUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    parentDisciplineId?: string | null
    level?: number
    description?: string | null
    keywords?: AcademicDisciplineCreatekeywordsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    childDisciplines?: AcademicDisciplineUncheckedCreateNestedManyWithoutParentDisciplineInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutSourceDisciplineInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutTargetDisciplineInput
    projectDisciplines?: ProjectDisciplineUncheckedCreateNestedManyWithoutDisciplineInput
  }

  export type AcademicDisciplineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: AcademicDisciplineUpdatekeywordsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentDiscipline?: AcademicDisciplineUpdateOneWithoutChildDisciplinesNestedInput
    childDisciplines?: AcademicDisciplineUpdateManyWithoutParentDisciplineNestedInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationUpdateManyWithoutSourceDisciplineNestedInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationUpdateManyWithoutTargetDisciplineNestedInput
    projectDisciplines?: ProjectDisciplineUpdateManyWithoutDisciplineNestedInput
  }

  export type AcademicDisciplineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentDisciplineId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: AcademicDisciplineUpdatekeywordsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childDisciplines?: AcademicDisciplineUncheckedUpdateManyWithoutParentDisciplineNestedInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationUncheckedUpdateManyWithoutSourceDisciplineNestedInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationUncheckedUpdateManyWithoutTargetDisciplineNestedInput
    projectDisciplines?: ProjectDisciplineUncheckedUpdateManyWithoutDisciplineNestedInput
  }

  export type AcademicDisciplineCreateManyInput = {
    id?: string
    code: string
    name: string
    parentDisciplineId?: string | null
    level?: number
    description?: string | null
    keywords?: AcademicDisciplineCreatekeywordsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AcademicDisciplineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: AcademicDisciplineUpdatekeywordsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicDisciplineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentDisciplineId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: AcademicDisciplineUpdatekeywordsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnetOccupationCreateInput = {
    id?: string
    onetCode: string
    title: string
    description?: string | null
    category?: string | null
    subdomain?: string | null
    tasks?: OnetOccupationCreatetasksInput | string[]
    skills?: OnetOccupationCreateskillsInput | string[]
    knowledgeAreas?: OnetOccupationCreateknowledgeAreasInput | string[]
    abilities?: OnetOccupationCreateabilitiesInput | string[]
    educationLevel?: string | null
    isActive?: boolean
    createdAt?: Date | string
    projectOccupations?: ProjectOccupationCreateNestedManyWithoutOccupationInput
  }

  export type OnetOccupationUncheckedCreateInput = {
    id?: string
    onetCode: string
    title: string
    description?: string | null
    category?: string | null
    subdomain?: string | null
    tasks?: OnetOccupationCreatetasksInput | string[]
    skills?: OnetOccupationCreateskillsInput | string[]
    knowledgeAreas?: OnetOccupationCreateknowledgeAreasInput | string[]
    abilities?: OnetOccupationCreateabilitiesInput | string[]
    educationLevel?: string | null
    isActive?: boolean
    createdAt?: Date | string
    projectOccupations?: ProjectOccupationUncheckedCreateNestedManyWithoutOccupationInput
  }

  export type OnetOccupationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    onetCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: OnetOccupationUpdatetasksInput | string[]
    skills?: OnetOccupationUpdateskillsInput | string[]
    knowledgeAreas?: OnetOccupationUpdateknowledgeAreasInput | string[]
    abilities?: OnetOccupationUpdateabilitiesInput | string[]
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectOccupations?: ProjectOccupationUpdateManyWithoutOccupationNestedInput
  }

  export type OnetOccupationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    onetCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: OnetOccupationUpdatetasksInput | string[]
    skills?: OnetOccupationUpdateskillsInput | string[]
    knowledgeAreas?: OnetOccupationUpdateknowledgeAreasInput | string[]
    abilities?: OnetOccupationUpdateabilitiesInput | string[]
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectOccupations?: ProjectOccupationUncheckedUpdateManyWithoutOccupationNestedInput
  }

  export type OnetOccupationCreateManyInput = {
    id?: string
    onetCode: string
    title: string
    description?: string | null
    category?: string | null
    subdomain?: string | null
    tasks?: OnetOccupationCreatetasksInput | string[]
    skills?: OnetOccupationCreateskillsInput | string[]
    knowledgeAreas?: OnetOccupationCreateknowledgeAreasInput | string[]
    abilities?: OnetOccupationCreateabilitiesInput | string[]
    educationLevel?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type OnetOccupationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    onetCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: OnetOccupationUpdatetasksInput | string[]
    skills?: OnetOccupationUpdateskillsInput | string[]
    knowledgeAreas?: OnetOccupationUpdateknowledgeAreasInput | string[]
    abilities?: OnetOccupationUpdateabilitiesInput | string[]
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnetOccupationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    onetCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: OnetOccupationUpdatetasksInput | string[]
    skills?: OnetOccupationUpdateskillsInput | string[]
    knowledgeAreas?: OnetOccupationUpdateknowledgeAreasInput | string[]
    abilities?: OnetOccupationUpdateabilitiesInput | string[]
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchProjectCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeIntegrations?: KnowledgeIntegrationCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    disciplines?: ProjectDisciplineCreateNestedManyWithoutProjectInput
    methodologySteps?: ProjectMethodologyStepCreateNestedManyWithoutProjectInput
    occupations?: ProjectOccupationCreateNestedManyWithoutProjectInput
    analyses?: ResearchAnalysisCreateNestedManyWithoutProjectInput
    principalInvestigator: UserCreateNestedOneWithoutProjectsInput
    images?: UploadedImageCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    principalInvestigatorId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    disciplines?: ProjectDisciplineUncheckedCreateNestedManyWithoutProjectInput
    methodologySteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutProjectInput
    occupations?: ProjectOccupationUncheckedCreateNestedManyWithoutProjectInput
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutProjectInput
    images?: UploadedImageUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    disciplines?: ProjectDisciplineUpdateManyWithoutProjectNestedInput
    methodologySteps?: ProjectMethodologyStepUpdateManyWithoutProjectNestedInput
    occupations?: ProjectOccupationUpdateManyWithoutProjectNestedInput
    analyses?: ResearchAnalysisUpdateManyWithoutProjectNestedInput
    principalInvestigator?: UserUpdateOneRequiredWithoutProjectsNestedInput
    images?: UploadedImageUpdateManyWithoutProjectNestedInput
  }

  export type ResearchProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    principalInvestigatorId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    disciplines?: ProjectDisciplineUncheckedUpdateManyWithoutProjectNestedInput
    methodologySteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutProjectNestedInput
    occupations?: ProjectOccupationUncheckedUpdateManyWithoutProjectNestedInput
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutProjectNestedInput
    images?: UploadedImageUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ResearchProjectCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    principalInvestigatorId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    principalInvestigatorId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDisciplineCreateInput = {
    id?: string
    primaryDiscipline?: boolean
    contributionLevel?: string
    createdAt?: Date | string
    discipline: AcademicDisciplineCreateNestedOneWithoutProjectDisciplinesInput
    project: ResearchProjectCreateNestedOneWithoutDisciplinesInput
  }

  export type ProjectDisciplineUncheckedCreateInput = {
    id?: string
    projectId: string
    disciplineId: string
    primaryDiscipline?: boolean
    contributionLevel?: string
    createdAt?: Date | string
  }

  export type ProjectDisciplineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryDiscipline?: BoolFieldUpdateOperationsInput | boolean
    contributionLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discipline?: AcademicDisciplineUpdateOneRequiredWithoutProjectDisciplinesNestedInput
    project?: ResearchProjectUpdateOneRequiredWithoutDisciplinesNestedInput
  }

  export type ProjectDisciplineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    disciplineId?: StringFieldUpdateOperationsInput | string
    primaryDiscipline?: BoolFieldUpdateOperationsInput | boolean
    contributionLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDisciplineCreateManyInput = {
    id?: string
    projectId: string
    disciplineId: string
    primaryDiscipline?: boolean
    contributionLevel?: string
    createdAt?: Date | string
  }

  export type ProjectDisciplineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryDiscipline?: BoolFieldUpdateOperationsInput | boolean
    contributionLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDisciplineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    disciplineId?: StringFieldUpdateOperationsInput | string
    primaryDiscipline?: BoolFieldUpdateOperationsInput | boolean
    contributionLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectOccupationCreateInput = {
    id?: string
    relevanceLevel?: string
    roleDescription?: string | null
    createdAt?: Date | string
    occupation: OnetOccupationCreateNestedOneWithoutProjectOccupationsInput
    project: ResearchProjectCreateNestedOneWithoutOccupationsInput
  }

  export type ProjectOccupationUncheckedCreateInput = {
    id?: string
    projectId: string
    occupationId: string
    relevanceLevel?: string
    roleDescription?: string | null
    createdAt?: Date | string
  }

  export type ProjectOccupationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevanceLevel?: StringFieldUpdateOperationsInput | string
    roleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    occupation?: OnetOccupationUpdateOneRequiredWithoutProjectOccupationsNestedInput
    project?: ResearchProjectUpdateOneRequiredWithoutOccupationsNestedInput
  }

  export type ProjectOccupationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    occupationId?: StringFieldUpdateOperationsInput | string
    relevanceLevel?: StringFieldUpdateOperationsInput | string
    roleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectOccupationCreateManyInput = {
    id?: string
    projectId: string
    occupationId: string
    relevanceLevel?: string
    roleDescription?: string | null
    createdAt?: Date | string
  }

  export type ProjectOccupationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevanceLevel?: StringFieldUpdateOperationsInput | string
    roleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectOccupationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    occupationId?: StringFieldUpdateOperationsInput | string
    relevanceLevel?: StringFieldUpdateOperationsInput | string
    roleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MethodologyStepCreateInput = {
    id?: string
    name: string
    description?: string | null
    methodologyType: $Enums.MethodologyType
    stepOrder: number
    estimatedDurationHours?: number | null
    requiredResources?: MethodologyStepCreaterequiredResourcesInput | string[]
    deliverables?: MethodologyStepCreatedeliverablesInput | string[]
    successCriteria?: MethodologyStepCreatesuccessCriteriaInput | string[]
    dependencies?: MethodologyStepCreatedependenciesInput | string[]
    templateData?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    projectSteps?: ProjectMethodologyStepCreateNestedManyWithoutMethodologyStepInput
  }

  export type MethodologyStepUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    methodologyType: $Enums.MethodologyType
    stepOrder: number
    estimatedDurationHours?: number | null
    requiredResources?: MethodologyStepCreaterequiredResourcesInput | string[]
    deliverables?: MethodologyStepCreatedeliverablesInput | string[]
    successCriteria?: MethodologyStepCreatesuccessCriteriaInput | string[]
    dependencies?: MethodologyStepCreatedependenciesInput | string[]
    templateData?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    projectSteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutMethodologyStepInput
  }

  export type MethodologyStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    stepOrder?: IntFieldUpdateOperationsInput | number
    estimatedDurationHours?: NullableIntFieldUpdateOperationsInput | number | null
    requiredResources?: MethodologyStepUpdaterequiredResourcesInput | string[]
    deliverables?: MethodologyStepUpdatedeliverablesInput | string[]
    successCriteria?: MethodologyStepUpdatesuccessCriteriaInput | string[]
    dependencies?: MethodologyStepUpdatedependenciesInput | string[]
    templateData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectSteps?: ProjectMethodologyStepUpdateManyWithoutMethodologyStepNestedInput
  }

  export type MethodologyStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    stepOrder?: IntFieldUpdateOperationsInput | number
    estimatedDurationHours?: NullableIntFieldUpdateOperationsInput | number | null
    requiredResources?: MethodologyStepUpdaterequiredResourcesInput | string[]
    deliverables?: MethodologyStepUpdatedeliverablesInput | string[]
    successCriteria?: MethodologyStepUpdatesuccessCriteriaInput | string[]
    dependencies?: MethodologyStepUpdatedependenciesInput | string[]
    templateData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectSteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutMethodologyStepNestedInput
  }

  export type MethodologyStepCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    methodologyType: $Enums.MethodologyType
    stepOrder: number
    estimatedDurationHours?: number | null
    requiredResources?: MethodologyStepCreaterequiredResourcesInput | string[]
    deliverables?: MethodologyStepCreatedeliverablesInput | string[]
    successCriteria?: MethodologyStepCreatesuccessCriteriaInput | string[]
    dependencies?: MethodologyStepCreatedependenciesInput | string[]
    templateData?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
  }

  export type MethodologyStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    stepOrder?: IntFieldUpdateOperationsInput | number
    estimatedDurationHours?: NullableIntFieldUpdateOperationsInput | number | null
    requiredResources?: MethodologyStepUpdaterequiredResourcesInput | string[]
    deliverables?: MethodologyStepUpdatedeliverablesInput | string[]
    successCriteria?: MethodologyStepUpdatesuccessCriteriaInput | string[]
    dependencies?: MethodologyStepUpdatedependenciesInput | string[]
    templateData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MethodologyStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    stepOrder?: IntFieldUpdateOperationsInput | number
    estimatedDurationHours?: NullableIntFieldUpdateOperationsInput | number | null
    requiredResources?: MethodologyStepUpdaterequiredResourcesInput | string[]
    deliverables?: MethodologyStepUpdatedeliverablesInput | string[]
    successCriteria?: MethodologyStepUpdatesuccessCriteriaInput | string[]
    dependencies?: MethodologyStepUpdatedependenciesInput | string[]
    templateData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMethodologyStepCreateInput = {
    id?: string
    status?: string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    notes?: string | null
    deliverablesUploaded?: ProjectMethodologyStepCreatedeliverablesUploadedInput | string[]
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedMethodologyStepsInput
    methodologyStep: MethodologyStepCreateNestedOneWithoutProjectStepsInput
    project: ResearchProjectCreateNestedOneWithoutMethodologyStepsInput
  }

  export type ProjectMethodologyStepUncheckedCreateInput = {
    id?: string
    projectId: string
    methodologyStepId: string
    assignedToId?: string | null
    status?: string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    notes?: string | null
    deliverablesUploaded?: ProjectMethodologyStepCreatedeliverablesUploadedInput | string[]
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMethodologyStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliverablesUploaded?: ProjectMethodologyStepUpdatedeliverablesUploadedInput | string[]
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedMethodologyStepsNestedInput
    methodologyStep?: MethodologyStepUpdateOneRequiredWithoutProjectStepsNestedInput
    project?: ResearchProjectUpdateOneRequiredWithoutMethodologyStepsNestedInput
  }

  export type ProjectMethodologyStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    methodologyStepId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliverablesUploaded?: ProjectMethodologyStepUpdatedeliverablesUploadedInput | string[]
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMethodologyStepCreateManyInput = {
    id?: string
    projectId: string
    methodologyStepId: string
    assignedToId?: string | null
    status?: string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    notes?: string | null
    deliverablesUploaded?: ProjectMethodologyStepCreatedeliverablesUploadedInput | string[]
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMethodologyStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliverablesUploaded?: ProjectMethodologyStepUpdatedeliverablesUploadedInput | string[]
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMethodologyStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    methodologyStepId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliverablesUploaded?: ProjectMethodologyStepUpdatedeliverablesUploadedInput | string[]
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedImageCreateInput = {
    id?: string
    fileName: string
    originalFileName?: string | null
    filePath: string
    fileSize?: bigint | number | null
    mimeType?: string | null
    imageType?: string | null
    imageConfidence?: Decimal | DecimalJsLike | number | string | null
    width?: number | null
    height?: number | null
    colorDepth?: number | null
    hasMetadata?: boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: $Enums.AnalysisStatus
    tags?: UploadedImageCreatetagsInput | string[]
    description?: string | null
    consentObtained?: boolean
    dataClassification?: string
    anonymized?: boolean
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: ResearchAnalysisCreateNestedManyWithoutImageInput
    project?: ResearchProjectCreateNestedOneWithoutImagesInput
    uploadedBy: UserCreateNestedOneWithoutUploadedImagesInput
  }

  export type UploadedImageUncheckedCreateInput = {
    id?: string
    projectId?: string | null
    uploadedById: string
    fileName: string
    originalFileName?: string | null
    filePath: string
    fileSize?: bigint | number | null
    mimeType?: string | null
    imageType?: string | null
    imageConfidence?: Decimal | DecimalJsLike | number | string | null
    width?: number | null
    height?: number | null
    colorDepth?: number | null
    hasMetadata?: boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: $Enums.AnalysisStatus
    tags?: UploadedImageCreatetagsInput | string[]
    description?: string | null
    consentObtained?: boolean
    dataClassification?: string
    anonymized?: boolean
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutImageInput
  }

  export type UploadedImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    colorDepth?: NullableIntFieldUpdateOperationsInput | number | null
    hasMetadata?: BoolFieldUpdateOperationsInput | boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    tags?: UploadedImageUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    consentObtained?: BoolFieldUpdateOperationsInput | boolean
    dataClassification?: StringFieldUpdateOperationsInput | string
    anonymized?: BoolFieldUpdateOperationsInput | boolean
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: ResearchAnalysisUpdateManyWithoutImageNestedInput
    project?: ResearchProjectUpdateOneWithoutImagesNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedImagesNestedInput
  }

  export type UploadedImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    colorDepth?: NullableIntFieldUpdateOperationsInput | number | null
    hasMetadata?: BoolFieldUpdateOperationsInput | boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    tags?: UploadedImageUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    consentObtained?: BoolFieldUpdateOperationsInput | boolean
    dataClassification?: StringFieldUpdateOperationsInput | string
    anonymized?: BoolFieldUpdateOperationsInput | boolean
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutImageNestedInput
  }

  export type UploadedImageCreateManyInput = {
    id?: string
    projectId?: string | null
    uploadedById: string
    fileName: string
    originalFileName?: string | null
    filePath: string
    fileSize?: bigint | number | null
    mimeType?: string | null
    imageType?: string | null
    imageConfidence?: Decimal | DecimalJsLike | number | string | null
    width?: number | null
    height?: number | null
    colorDepth?: number | null
    hasMetadata?: boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: $Enums.AnalysisStatus
    tags?: UploadedImageCreatetagsInput | string[]
    description?: string | null
    consentObtained?: boolean
    dataClassification?: string
    anonymized?: boolean
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadedImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    colorDepth?: NullableIntFieldUpdateOperationsInput | number | null
    hasMetadata?: BoolFieldUpdateOperationsInput | boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    tags?: UploadedImageUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    consentObtained?: BoolFieldUpdateOperationsInput | boolean
    dataClassification?: StringFieldUpdateOperationsInput | string
    anonymized?: BoolFieldUpdateOperationsInput | boolean
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    colorDepth?: NullableIntFieldUpdateOperationsInput | number | null
    hasMetadata?: BoolFieldUpdateOperationsInput | boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    tags?: UploadedImageUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    consentObtained?: BoolFieldUpdateOperationsInput | boolean
    dataClassification?: StringFieldUpdateOperationsInput | string
    anonymized?: BoolFieldUpdateOperationsInput | boolean
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchAnalysisCreateInput = {
    id?: string
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    analyst: UserCreateNestedOneWithoutAnalysesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedAnalysesInput
    image?: UploadedImageCreateNestedOneWithoutAnalysesInput
    project?: ResearchProjectCreateNestedOneWithoutAnalysesInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedAnalysesInput
  }

  export type ResearchAnalysisUncheckedCreateInput = {
    id?: string
    projectId?: string | null
    imageId?: string | null
    analystId: string
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchAnalysisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyst?: UserUpdateOneRequiredWithoutAnalysesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedAnalysesNestedInput
    image?: UploadedImageUpdateOneWithoutAnalysesNestedInput
    project?: ResearchProjectUpdateOneWithoutAnalysesNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedAnalysesNestedInput
  }

  export type ResearchAnalysisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    analystId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchAnalysisCreateManyInput = {
    id?: string
    projectId?: string | null
    imageId?: string | null
    analystId: string
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchAnalysisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchAnalysisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    analystId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeIntegrationCreateInput = {
    id?: string
    integrationType: $Enums.KnowledgeIntegrationType
    title: string
    description?: string | null
    sourceKnowledge?: string | null
    targetApplication?: string | null
    integrationMethod?: string | null
    validationStatus?: string
    validationNotes?: string | null
    noveltyScore?: Decimal | DecimalJsLike | number | string | null
    impactPotential?: string | null
    implementationFeasibility?: string | null
    references?: KnowledgeIntegrationCreatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutKnowledgeIntegrationsInput
    project: ResearchProjectCreateNestedOneWithoutKnowledgeIntegrationsInput
    sourceDiscipline: AcademicDisciplineCreateNestedOneWithoutKnowledgeIntegrationsSourceInput
    targetDiscipline: AcademicDisciplineCreateNestedOneWithoutKnowledgeIntegrationsTargetInput
  }

  export type KnowledgeIntegrationUncheckedCreateInput = {
    id?: string
    projectId: string
    sourceDisciplineId: string
    targetDisciplineId: string
    integrationType: $Enums.KnowledgeIntegrationType
    title: string
    description?: string | null
    sourceKnowledge?: string | null
    targetApplication?: string | null
    integrationMethod?: string | null
    validationStatus?: string
    validationNotes?: string | null
    noveltyScore?: Decimal | DecimalJsLike | number | string | null
    impactPotential?: string | null
    implementationFeasibility?: string | null
    references?: KnowledgeIntegrationCreatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationType?: EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput | $Enums.KnowledgeIntegrationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceKnowledge?: NullableStringFieldUpdateOperationsInput | string | null
    targetApplication?: NullableStringFieldUpdateOperationsInput | string | null
    integrationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    noveltyScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    impactPotential?: NullableStringFieldUpdateOperationsInput | string | null
    implementationFeasibility?: NullableStringFieldUpdateOperationsInput | string | null
    references?: KnowledgeIntegrationUpdatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutKnowledgeIntegrationsNestedInput
    project?: ResearchProjectUpdateOneRequiredWithoutKnowledgeIntegrationsNestedInput
    sourceDiscipline?: AcademicDisciplineUpdateOneRequiredWithoutKnowledgeIntegrationsSourceNestedInput
    targetDiscipline?: AcademicDisciplineUpdateOneRequiredWithoutKnowledgeIntegrationsTargetNestedInput
  }

  export type KnowledgeIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sourceDisciplineId?: StringFieldUpdateOperationsInput | string
    targetDisciplineId?: StringFieldUpdateOperationsInput | string
    integrationType?: EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput | $Enums.KnowledgeIntegrationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceKnowledge?: NullableStringFieldUpdateOperationsInput | string | null
    targetApplication?: NullableStringFieldUpdateOperationsInput | string | null
    integrationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    noveltyScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    impactPotential?: NullableStringFieldUpdateOperationsInput | string | null
    implementationFeasibility?: NullableStringFieldUpdateOperationsInput | string | null
    references?: KnowledgeIntegrationUpdatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeIntegrationCreateManyInput = {
    id?: string
    projectId: string
    sourceDisciplineId: string
    targetDisciplineId: string
    integrationType: $Enums.KnowledgeIntegrationType
    title: string
    description?: string | null
    sourceKnowledge?: string | null
    targetApplication?: string | null
    integrationMethod?: string | null
    validationStatus?: string
    validationNotes?: string | null
    noveltyScore?: Decimal | DecimalJsLike | number | string | null
    impactPotential?: string | null
    implementationFeasibility?: string | null
    references?: KnowledgeIntegrationCreatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationType?: EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput | $Enums.KnowledgeIntegrationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceKnowledge?: NullableStringFieldUpdateOperationsInput | string | null
    targetApplication?: NullableStringFieldUpdateOperationsInput | string | null
    integrationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    noveltyScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    impactPotential?: NullableStringFieldUpdateOperationsInput | string | null
    implementationFeasibility?: NullableStringFieldUpdateOperationsInput | string | null
    references?: KnowledgeIntegrationUpdatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sourceDisciplineId?: StringFieldUpdateOperationsInput | string
    targetDisciplineId?: StringFieldUpdateOperationsInput | string
    integrationType?: EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput | $Enums.KnowledgeIntegrationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceKnowledge?: NullableStringFieldUpdateOperationsInput | string | null
    targetApplication?: NullableStringFieldUpdateOperationsInput | string | null
    integrationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    noveltyScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    impactPotential?: NullableStringFieldUpdateOperationsInput | string | null
    implementationFeasibility?: NullableStringFieldUpdateOperationsInput | string | null
    references?: KnowledgeIntegrationUpdatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCollaboratorCreateInput = {
    id?: string
    role: string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: string | null
    joinedAt?: Date | string
    status?: string
    project: ResearchProjectCreateNestedOneWithoutCollaboratorsInput
    user: UserCreateNestedOneWithoutProjectCollaborationsInput
  }

  export type ProjectCollaboratorUncheckedCreateInput = {
    id?: string
    projectId: string
    userId: string
    role: string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: string | null
    joinedAt?: Date | string
    status?: string
  }

  export type ProjectCollaboratorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    project?: ResearchProjectUpdateOneRequiredWithoutCollaboratorsNestedInput
    user?: UserUpdateOneRequiredWithoutProjectCollaborationsNestedInput
  }

  export type ProjectCollaboratorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCollaboratorCreateManyInput = {
    id?: string
    projectId: string
    userId: string
    role: string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: string | null
    joinedAt?: Date | string
    status?: string
  }

  export type ProjectCollaboratorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCollaboratorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type KnowledgeIntegrationListRelationFilter = {
    every?: KnowledgeIntegrationWhereInput
    some?: KnowledgeIntegrationWhereInput
    none?: KnowledgeIntegrationWhereInput
  }

  export type ProjectCollaboratorListRelationFilter = {
    every?: ProjectCollaboratorWhereInput
    some?: ProjectCollaboratorWhereInput
    none?: ProjectCollaboratorWhereInput
  }

  export type ProjectMethodologyStepListRelationFilter = {
    every?: ProjectMethodologyStepWhereInput
    some?: ProjectMethodologyStepWhereInput
    none?: ProjectMethodologyStepWhereInput
  }

  export type ResearchAnalysisListRelationFilter = {
    every?: ResearchAnalysisWhereInput
    some?: ResearchAnalysisWhereInput
    none?: ResearchAnalysisWhereInput
  }

  export type ResearchProjectListRelationFilter = {
    every?: ResearchProjectWhereInput
    some?: ResearchProjectWhereInput
    none?: ResearchProjectWhereInput
  }

  export type UploadedImageListRelationFilter = {
    every?: UploadedImageWhereInput
    some?: UploadedImageWhereInput
    none?: UploadedImageWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type KnowledgeIntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCollaboratorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectMethodologyStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResearchAnalysisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResearchProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UploadedImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    institution?: SortOrder
    department?: SortOrder
    specialization?: SortOrder
    orcidId?: SortOrder
    googleScholarId?: SortOrder
    linkedinUrl?: SortOrder
    isVerified?: SortOrder
    preferences?: SortOrder
    memberSince?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokensTotal?: SortOrder
    tokensUsedToday?: SortOrder
    tokenLastResetDate?: SortOrder
    isPro?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    tokensTotal?: SortOrder
    tokensUsedToday?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    institution?: SortOrder
    department?: SortOrder
    orcidId?: SortOrder
    googleScholarId?: SortOrder
    linkedinUrl?: SortOrder
    isVerified?: SortOrder
    memberSince?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokensTotal?: SortOrder
    tokensUsedToday?: SortOrder
    tokenLastResetDate?: SortOrder
    isPro?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    institution?: SortOrder
    department?: SortOrder
    orcidId?: SortOrder
    googleScholarId?: SortOrder
    linkedinUrl?: SortOrder
    isVerified?: SortOrder
    memberSince?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokensTotal?: SortOrder
    tokensUsedToday?: SortOrder
    tokenLastResetDate?: SortOrder
    isPro?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    tokensTotal?: SortOrder
    tokensUsedToday?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type AcademicDisciplineNullableRelationFilter = {
    is?: AcademicDisciplineWhereInput | null
    isNot?: AcademicDisciplineWhereInput | null
  }

  export type AcademicDisciplineListRelationFilter = {
    every?: AcademicDisciplineWhereInput
    some?: AcademicDisciplineWhereInput
    none?: AcademicDisciplineWhereInput
  }

  export type ProjectDisciplineListRelationFilter = {
    every?: ProjectDisciplineWhereInput
    some?: ProjectDisciplineWhereInput
    none?: ProjectDisciplineWhereInput
  }

  export type AcademicDisciplineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectDisciplineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicDisciplineCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    parentDisciplineId?: SortOrder
    level?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AcademicDisciplineAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type AcademicDisciplineMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    parentDisciplineId?: SortOrder
    level?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AcademicDisciplineMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    parentDisciplineId?: SortOrder
    level?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AcademicDisciplineSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type ProjectOccupationListRelationFilter = {
    every?: ProjectOccupationWhereInput
    some?: ProjectOccupationWhereInput
    none?: ProjectOccupationWhereInput
  }

  export type ProjectOccupationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OnetOccupationCountOrderByAggregateInput = {
    id?: SortOrder
    onetCode?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    subdomain?: SortOrder
    tasks?: SortOrder
    skills?: SortOrder
    knowledgeAreas?: SortOrder
    abilities?: SortOrder
    educationLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type OnetOccupationMaxOrderByAggregateInput = {
    id?: SortOrder
    onetCode?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    subdomain?: SortOrder
    educationLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type OnetOccupationMinOrderByAggregateInput = {
    id?: SortOrder
    onetCode?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    subdomain?: SortOrder
    educationLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumMethodologyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MethodologyType | EnumMethodologyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MethodologyType[] | ListEnumMethodologyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MethodologyType[] | ListEnumMethodologyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMethodologyTypeFilter<$PrismaModel> | $Enums.MethodologyType
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ResearchProjectCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    principalInvestigatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    fundingSource?: SortOrder
    fundingAmount?: SortOrder
    institutions?: SortOrder
    methodologyType?: SortOrder
    researchQuestions?: SortOrder
    objectives?: SortOrder
    hypotheses?: SortOrder
    ethicalApprovalRequired?: SortOrder
    ethicalApprovalStatus?: SortOrder
    dataClassification?: SortOrder
    collaborationLevel?: SortOrder
    isPublic?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResearchProjectAvgOrderByAggregateInput = {
    fundingAmount?: SortOrder
  }

  export type ResearchProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    principalInvestigatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    fundingSource?: SortOrder
    fundingAmount?: SortOrder
    methodologyType?: SortOrder
    ethicalApprovalRequired?: SortOrder
    ethicalApprovalStatus?: SortOrder
    dataClassification?: SortOrder
    collaborationLevel?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResearchProjectMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    principalInvestigatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    fundingSource?: SortOrder
    fundingAmount?: SortOrder
    methodologyType?: SortOrder
    ethicalApprovalRequired?: SortOrder
    ethicalApprovalStatus?: SortOrder
    dataClassification?: SortOrder
    collaborationLevel?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResearchProjectSumOrderByAggregateInput = {
    fundingAmount?: SortOrder
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumMethodologyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MethodologyType | EnumMethodologyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MethodologyType[] | ListEnumMethodologyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MethodologyType[] | ListEnumMethodologyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMethodologyTypeWithAggregatesFilter<$PrismaModel> | $Enums.MethodologyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMethodologyTypeFilter<$PrismaModel>
    _max?: NestedEnumMethodologyTypeFilter<$PrismaModel>
  }

  export type AcademicDisciplineRelationFilter = {
    is?: AcademicDisciplineWhereInput
    isNot?: AcademicDisciplineWhereInput
  }

  export type ResearchProjectRelationFilter = {
    is?: ResearchProjectWhereInput
    isNot?: ResearchProjectWhereInput
  }

  export type ProjectDisciplineProjectIdDisciplineIdCompoundUniqueInput = {
    projectId: string
    disciplineId: string
  }

  export type ProjectDisciplineCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    disciplineId?: SortOrder
    primaryDiscipline?: SortOrder
    contributionLevel?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectDisciplineMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    disciplineId?: SortOrder
    primaryDiscipline?: SortOrder
    contributionLevel?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectDisciplineMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    disciplineId?: SortOrder
    primaryDiscipline?: SortOrder
    contributionLevel?: SortOrder
    createdAt?: SortOrder
  }

  export type OnetOccupationRelationFilter = {
    is?: OnetOccupationWhereInput
    isNot?: OnetOccupationWhereInput
  }

  export type ProjectOccupationProjectIdOccupationIdCompoundUniqueInput = {
    projectId: string
    occupationId: string
  }

  export type ProjectOccupationCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    occupationId?: SortOrder
    relevanceLevel?: SortOrder
    roleDescription?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectOccupationMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    occupationId?: SortOrder
    relevanceLevel?: SortOrder
    roleDescription?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectOccupationMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    occupationId?: SortOrder
    relevanceLevel?: SortOrder
    roleDescription?: SortOrder
    createdAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MethodologyStepCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    methodologyType?: SortOrder
    stepOrder?: SortOrder
    estimatedDurationHours?: SortOrder
    requiredResources?: SortOrder
    deliverables?: SortOrder
    successCriteria?: SortOrder
    dependencies?: SortOrder
    templateData?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type MethodologyStepAvgOrderByAggregateInput = {
    stepOrder?: SortOrder
    estimatedDurationHours?: SortOrder
  }

  export type MethodologyStepMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    methodologyType?: SortOrder
    stepOrder?: SortOrder
    estimatedDurationHours?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type MethodologyStepMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    methodologyType?: SortOrder
    stepOrder?: SortOrder
    estimatedDurationHours?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type MethodologyStepSumOrderByAggregateInput = {
    stepOrder?: SortOrder
    estimatedDurationHours?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MethodologyStepRelationFilter = {
    is?: MethodologyStepWhereInput
    isNot?: MethodologyStepWhereInput
  }

  export type ProjectMethodologyStepProjectIdMethodologyStepIdCompoundUniqueInput = {
    projectId: string
    methodologyStepId: string
  }

  export type ProjectMethodologyStepCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    methodologyStepId?: SortOrder
    assignedToId?: SortOrder
    status?: SortOrder
    actualStartDate?: SortOrder
    actualEndDate?: SortOrder
    notes?: SortOrder
    deliverablesUploaded?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMethodologyStepAvgOrderByAggregateInput = {
    completionPercentage?: SortOrder
  }

  export type ProjectMethodologyStepMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    methodologyStepId?: SortOrder
    assignedToId?: SortOrder
    status?: SortOrder
    actualStartDate?: SortOrder
    actualEndDate?: SortOrder
    notes?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMethodologyStepMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    methodologyStepId?: SortOrder
    assignedToId?: SortOrder
    status?: SortOrder
    actualStartDate?: SortOrder
    actualEndDate?: SortOrder
    notes?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMethodologyStepSumOrderByAggregateInput = {
    completionPercentage?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumAnalysisStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisStatus | EnumAnalysisStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisStatus[] | ListEnumAnalysisStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisStatus[] | ListEnumAnalysisStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisStatusFilter<$PrismaModel> | $Enums.AnalysisStatus
  }

  export type ResearchProjectNullableRelationFilter = {
    is?: ResearchProjectWhereInput | null
    isNot?: ResearchProjectWhereInput | null
  }

  export type UploadedImageCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    uploadedById?: SortOrder
    fileName?: SortOrder
    originalFileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    imageType?: SortOrder
    imageConfidence?: SortOrder
    width?: SortOrder
    height?: SortOrder
    colorDepth?: SortOrder
    hasMetadata?: SortOrder
    dicomMetadata?: SortOrder
    analysisStatus?: SortOrder
    tags?: SortOrder
    description?: SortOrder
    consentObtained?: SortOrder
    dataClassification?: SortOrder
    anonymized?: SortOrder
    processingStartedAt?: SortOrder
    processingCompletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UploadedImageAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    imageConfidence?: SortOrder
    width?: SortOrder
    height?: SortOrder
    colorDepth?: SortOrder
  }

  export type UploadedImageMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    uploadedById?: SortOrder
    fileName?: SortOrder
    originalFileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    imageType?: SortOrder
    imageConfidence?: SortOrder
    width?: SortOrder
    height?: SortOrder
    colorDepth?: SortOrder
    hasMetadata?: SortOrder
    analysisStatus?: SortOrder
    description?: SortOrder
    consentObtained?: SortOrder
    dataClassification?: SortOrder
    anonymized?: SortOrder
    processingStartedAt?: SortOrder
    processingCompletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UploadedImageMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    uploadedById?: SortOrder
    fileName?: SortOrder
    originalFileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    imageType?: SortOrder
    imageConfidence?: SortOrder
    width?: SortOrder
    height?: SortOrder
    colorDepth?: SortOrder
    hasMetadata?: SortOrder
    analysisStatus?: SortOrder
    description?: SortOrder
    consentObtained?: SortOrder
    dataClassification?: SortOrder
    anonymized?: SortOrder
    processingStartedAt?: SortOrder
    processingCompletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UploadedImageSumOrderByAggregateInput = {
    fileSize?: SortOrder
    imageConfidence?: SortOrder
    width?: SortOrder
    height?: SortOrder
    colorDepth?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumAnalysisStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisStatus | EnumAnalysisStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisStatus[] | ListEnumAnalysisStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisStatus[] | ListEnumAnalysisStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisStatusWithAggregatesFilter<$PrismaModel> | $Enums.AnalysisStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnalysisStatusFilter<$PrismaModel>
    _max?: NestedEnumAnalysisStatusFilter<$PrismaModel>
  }

  export type UploadedImageNullableRelationFilter = {
    is?: UploadedImageWhereInput | null
    isNot?: UploadedImageWhereInput | null
  }

  export type ResearchAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    imageId?: SortOrder
    analystId?: SortOrder
    analysisType?: SortOrder
    status?: SortOrder
    confidenceScore?: SortOrder
    processingTimeSeconds?: SortOrder
    algorithmVersion?: SortOrder
    modelUsed?: SortOrder
    findings?: SortOrder
    recommendations?: SortOrder
    differentialDiagnosis?: SortOrder
    severityAssessment?: SortOrder
    regionsOfInterest?: SortOrder
    qualityMetrics?: SortOrder
    errorMessage?: SortOrder
    reviewRequired?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    reviewNotes?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResearchAnalysisAvgOrderByAggregateInput = {
    confidenceScore?: SortOrder
    processingTimeSeconds?: SortOrder
  }

  export type ResearchAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    imageId?: SortOrder
    analystId?: SortOrder
    analysisType?: SortOrder
    status?: SortOrder
    confidenceScore?: SortOrder
    processingTimeSeconds?: SortOrder
    algorithmVersion?: SortOrder
    modelUsed?: SortOrder
    errorMessage?: SortOrder
    reviewRequired?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    reviewNotes?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResearchAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    imageId?: SortOrder
    analystId?: SortOrder
    analysisType?: SortOrder
    status?: SortOrder
    confidenceScore?: SortOrder
    processingTimeSeconds?: SortOrder
    algorithmVersion?: SortOrder
    modelUsed?: SortOrder
    errorMessage?: SortOrder
    reviewRequired?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    reviewNotes?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResearchAnalysisSumOrderByAggregateInput = {
    confidenceScore?: SortOrder
    processingTimeSeconds?: SortOrder
  }

  export type EnumKnowledgeIntegrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeIntegrationType | EnumKnowledgeIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeIntegrationType[] | ListEnumKnowledgeIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeIntegrationType[] | ListEnumKnowledgeIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeIntegrationTypeFilter<$PrismaModel> | $Enums.KnowledgeIntegrationType
  }

  export type KnowledgeIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    sourceDisciplineId?: SortOrder
    targetDisciplineId?: SortOrder
    integrationType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sourceKnowledge?: SortOrder
    targetApplication?: SortOrder
    integrationMethod?: SortOrder
    validationStatus?: SortOrder
    validationNotes?: SortOrder
    noveltyScore?: SortOrder
    impactPotential?: SortOrder
    implementationFeasibility?: SortOrder
    references?: SortOrder
    supportingEvidence?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeIntegrationAvgOrderByAggregateInput = {
    noveltyScore?: SortOrder
  }

  export type KnowledgeIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    sourceDisciplineId?: SortOrder
    targetDisciplineId?: SortOrder
    integrationType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sourceKnowledge?: SortOrder
    targetApplication?: SortOrder
    integrationMethod?: SortOrder
    validationStatus?: SortOrder
    validationNotes?: SortOrder
    noveltyScore?: SortOrder
    impactPotential?: SortOrder
    implementationFeasibility?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    sourceDisciplineId?: SortOrder
    targetDisciplineId?: SortOrder
    integrationType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sourceKnowledge?: SortOrder
    targetApplication?: SortOrder
    integrationMethod?: SortOrder
    validationStatus?: SortOrder
    validationNotes?: SortOrder
    noveltyScore?: SortOrder
    impactPotential?: SortOrder
    implementationFeasibility?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeIntegrationSumOrderByAggregateInput = {
    noveltyScore?: SortOrder
  }

  export type EnumKnowledgeIntegrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeIntegrationType | EnumKnowledgeIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeIntegrationType[] | ListEnumKnowledgeIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeIntegrationType[] | ListEnumKnowledgeIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeIntegrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.KnowledgeIntegrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKnowledgeIntegrationTypeFilter<$PrismaModel>
    _max?: NestedEnumKnowledgeIntegrationTypeFilter<$PrismaModel>
  }

  export type ProjectCollaboratorProjectIdUserIdCompoundUniqueInput = {
    projectId: string
    userId: string
  }

  export type ProjectCollaboratorCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    contributionDescription?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
  }

  export type ProjectCollaboratorMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    contributionDescription?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
  }

  export type ProjectCollaboratorMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    contributionDescription?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
  }

  export type UserCreatespecializationInput = {
    set: string[]
  }

  export type KnowledgeIntegrationCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<KnowledgeIntegrationCreateWithoutCreatedByInput, KnowledgeIntegrationUncheckedCreateWithoutCreatedByInput> | KnowledgeIntegrationCreateWithoutCreatedByInput[] | KnowledgeIntegrationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: KnowledgeIntegrationCreateOrConnectWithoutCreatedByInput | KnowledgeIntegrationCreateOrConnectWithoutCreatedByInput[]
    createMany?: KnowledgeIntegrationCreateManyCreatedByInputEnvelope
    connect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
  }

  export type ProjectCollaboratorCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutUserInput, ProjectCollaboratorUncheckedCreateWithoutUserInput> | ProjectCollaboratorCreateWithoutUserInput[] | ProjectCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutUserInput | ProjectCollaboratorCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCollaboratorCreateManyUserInputEnvelope
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
  }

  export type ProjectMethodologyStepCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<ProjectMethodologyStepCreateWithoutAssignedToInput, ProjectMethodologyStepUncheckedCreateWithoutAssignedToInput> | ProjectMethodologyStepCreateWithoutAssignedToInput[] | ProjectMethodologyStepUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ProjectMethodologyStepCreateOrConnectWithoutAssignedToInput | ProjectMethodologyStepCreateOrConnectWithoutAssignedToInput[]
    createMany?: ProjectMethodologyStepCreateManyAssignedToInputEnvelope
    connect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
  }

  export type ResearchAnalysisCreateNestedManyWithoutAnalystInput = {
    create?: XOR<ResearchAnalysisCreateWithoutAnalystInput, ResearchAnalysisUncheckedCreateWithoutAnalystInput> | ResearchAnalysisCreateWithoutAnalystInput[] | ResearchAnalysisUncheckedCreateWithoutAnalystInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutAnalystInput | ResearchAnalysisCreateOrConnectWithoutAnalystInput[]
    createMany?: ResearchAnalysisCreateManyAnalystInputEnvelope
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
  }

  export type ResearchAnalysisCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<ResearchAnalysisCreateWithoutApprovedByInput, ResearchAnalysisUncheckedCreateWithoutApprovedByInput> | ResearchAnalysisCreateWithoutApprovedByInput[] | ResearchAnalysisUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutApprovedByInput | ResearchAnalysisCreateOrConnectWithoutApprovedByInput[]
    createMany?: ResearchAnalysisCreateManyApprovedByInputEnvelope
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
  }

  export type ResearchAnalysisCreateNestedManyWithoutReviewedByInput = {
    create?: XOR<ResearchAnalysisCreateWithoutReviewedByInput, ResearchAnalysisUncheckedCreateWithoutReviewedByInput> | ResearchAnalysisCreateWithoutReviewedByInput[] | ResearchAnalysisUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutReviewedByInput | ResearchAnalysisCreateOrConnectWithoutReviewedByInput[]
    createMany?: ResearchAnalysisCreateManyReviewedByInputEnvelope
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
  }

  export type ResearchProjectCreateNestedManyWithoutPrincipalInvestigatorInput = {
    create?: XOR<ResearchProjectCreateWithoutPrincipalInvestigatorInput, ResearchProjectUncheckedCreateWithoutPrincipalInvestigatorInput> | ResearchProjectCreateWithoutPrincipalInvestigatorInput[] | ResearchProjectUncheckedCreateWithoutPrincipalInvestigatorInput[]
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutPrincipalInvestigatorInput | ResearchProjectCreateOrConnectWithoutPrincipalInvestigatorInput[]
    createMany?: ResearchProjectCreateManyPrincipalInvestigatorInputEnvelope
    connect?: ResearchProjectWhereUniqueInput | ResearchProjectWhereUniqueInput[]
  }

  export type UploadedImageCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<UploadedImageCreateWithoutUploadedByInput, UploadedImageUncheckedCreateWithoutUploadedByInput> | UploadedImageCreateWithoutUploadedByInput[] | UploadedImageUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: UploadedImageCreateOrConnectWithoutUploadedByInput | UploadedImageCreateOrConnectWithoutUploadedByInput[]
    createMany?: UploadedImageCreateManyUploadedByInputEnvelope
    connect?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
  }

  export type KnowledgeIntegrationUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<KnowledgeIntegrationCreateWithoutCreatedByInput, KnowledgeIntegrationUncheckedCreateWithoutCreatedByInput> | KnowledgeIntegrationCreateWithoutCreatedByInput[] | KnowledgeIntegrationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: KnowledgeIntegrationCreateOrConnectWithoutCreatedByInput | KnowledgeIntegrationCreateOrConnectWithoutCreatedByInput[]
    createMany?: KnowledgeIntegrationCreateManyCreatedByInputEnvelope
    connect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
  }

  export type ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutUserInput, ProjectCollaboratorUncheckedCreateWithoutUserInput> | ProjectCollaboratorCreateWithoutUserInput[] | ProjectCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutUserInput | ProjectCollaboratorCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCollaboratorCreateManyUserInputEnvelope
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
  }

  export type ProjectMethodologyStepUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<ProjectMethodologyStepCreateWithoutAssignedToInput, ProjectMethodologyStepUncheckedCreateWithoutAssignedToInput> | ProjectMethodologyStepCreateWithoutAssignedToInput[] | ProjectMethodologyStepUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ProjectMethodologyStepCreateOrConnectWithoutAssignedToInput | ProjectMethodologyStepCreateOrConnectWithoutAssignedToInput[]
    createMany?: ProjectMethodologyStepCreateManyAssignedToInputEnvelope
    connect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
  }

  export type ResearchAnalysisUncheckedCreateNestedManyWithoutAnalystInput = {
    create?: XOR<ResearchAnalysisCreateWithoutAnalystInput, ResearchAnalysisUncheckedCreateWithoutAnalystInput> | ResearchAnalysisCreateWithoutAnalystInput[] | ResearchAnalysisUncheckedCreateWithoutAnalystInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutAnalystInput | ResearchAnalysisCreateOrConnectWithoutAnalystInput[]
    createMany?: ResearchAnalysisCreateManyAnalystInputEnvelope
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
  }

  export type ResearchAnalysisUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<ResearchAnalysisCreateWithoutApprovedByInput, ResearchAnalysisUncheckedCreateWithoutApprovedByInput> | ResearchAnalysisCreateWithoutApprovedByInput[] | ResearchAnalysisUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutApprovedByInput | ResearchAnalysisCreateOrConnectWithoutApprovedByInput[]
    createMany?: ResearchAnalysisCreateManyApprovedByInputEnvelope
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
  }

  export type ResearchAnalysisUncheckedCreateNestedManyWithoutReviewedByInput = {
    create?: XOR<ResearchAnalysisCreateWithoutReviewedByInput, ResearchAnalysisUncheckedCreateWithoutReviewedByInput> | ResearchAnalysisCreateWithoutReviewedByInput[] | ResearchAnalysisUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutReviewedByInput | ResearchAnalysisCreateOrConnectWithoutReviewedByInput[]
    createMany?: ResearchAnalysisCreateManyReviewedByInputEnvelope
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
  }

  export type ResearchProjectUncheckedCreateNestedManyWithoutPrincipalInvestigatorInput = {
    create?: XOR<ResearchProjectCreateWithoutPrincipalInvestigatorInput, ResearchProjectUncheckedCreateWithoutPrincipalInvestigatorInput> | ResearchProjectCreateWithoutPrincipalInvestigatorInput[] | ResearchProjectUncheckedCreateWithoutPrincipalInvestigatorInput[]
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutPrincipalInvestigatorInput | ResearchProjectCreateOrConnectWithoutPrincipalInvestigatorInput[]
    createMany?: ResearchProjectCreateManyPrincipalInvestigatorInputEnvelope
    connect?: ResearchProjectWhereUniqueInput | ResearchProjectWhereUniqueInput[]
  }

  export type UploadedImageUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<UploadedImageCreateWithoutUploadedByInput, UploadedImageUncheckedCreateWithoutUploadedByInput> | UploadedImageCreateWithoutUploadedByInput[] | UploadedImageUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: UploadedImageCreateOrConnectWithoutUploadedByInput | UploadedImageCreateOrConnectWithoutUploadedByInput[]
    createMany?: UploadedImageCreateManyUploadedByInputEnvelope
    connect?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type UserUpdatespecializationInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type KnowledgeIntegrationUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<KnowledgeIntegrationCreateWithoutCreatedByInput, KnowledgeIntegrationUncheckedCreateWithoutCreatedByInput> | KnowledgeIntegrationCreateWithoutCreatedByInput[] | KnowledgeIntegrationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: KnowledgeIntegrationCreateOrConnectWithoutCreatedByInput | KnowledgeIntegrationCreateOrConnectWithoutCreatedByInput[]
    upsert?: KnowledgeIntegrationUpsertWithWhereUniqueWithoutCreatedByInput | KnowledgeIntegrationUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: KnowledgeIntegrationCreateManyCreatedByInputEnvelope
    set?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    disconnect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    delete?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    connect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    update?: KnowledgeIntegrationUpdateWithWhereUniqueWithoutCreatedByInput | KnowledgeIntegrationUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: KnowledgeIntegrationUpdateManyWithWhereWithoutCreatedByInput | KnowledgeIntegrationUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: KnowledgeIntegrationScalarWhereInput | KnowledgeIntegrationScalarWhereInput[]
  }

  export type ProjectCollaboratorUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutUserInput, ProjectCollaboratorUncheckedCreateWithoutUserInput> | ProjectCollaboratorCreateWithoutUserInput[] | ProjectCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutUserInput | ProjectCollaboratorCreateOrConnectWithoutUserInput[]
    upsert?: ProjectCollaboratorUpsertWithWhereUniqueWithoutUserInput | ProjectCollaboratorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCollaboratorCreateManyUserInputEnvelope
    set?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    disconnect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    delete?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    update?: ProjectCollaboratorUpdateWithWhereUniqueWithoutUserInput | ProjectCollaboratorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectCollaboratorUpdateManyWithWhereWithoutUserInput | ProjectCollaboratorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectCollaboratorScalarWhereInput | ProjectCollaboratorScalarWhereInput[]
  }

  export type ProjectMethodologyStepUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<ProjectMethodologyStepCreateWithoutAssignedToInput, ProjectMethodologyStepUncheckedCreateWithoutAssignedToInput> | ProjectMethodologyStepCreateWithoutAssignedToInput[] | ProjectMethodologyStepUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ProjectMethodologyStepCreateOrConnectWithoutAssignedToInput | ProjectMethodologyStepCreateOrConnectWithoutAssignedToInput[]
    upsert?: ProjectMethodologyStepUpsertWithWhereUniqueWithoutAssignedToInput | ProjectMethodologyStepUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: ProjectMethodologyStepCreateManyAssignedToInputEnvelope
    set?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    disconnect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    delete?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    connect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    update?: ProjectMethodologyStepUpdateWithWhereUniqueWithoutAssignedToInput | ProjectMethodologyStepUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: ProjectMethodologyStepUpdateManyWithWhereWithoutAssignedToInput | ProjectMethodologyStepUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: ProjectMethodologyStepScalarWhereInput | ProjectMethodologyStepScalarWhereInput[]
  }

  export type ResearchAnalysisUpdateManyWithoutAnalystNestedInput = {
    create?: XOR<ResearchAnalysisCreateWithoutAnalystInput, ResearchAnalysisUncheckedCreateWithoutAnalystInput> | ResearchAnalysisCreateWithoutAnalystInput[] | ResearchAnalysisUncheckedCreateWithoutAnalystInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutAnalystInput | ResearchAnalysisCreateOrConnectWithoutAnalystInput[]
    upsert?: ResearchAnalysisUpsertWithWhereUniqueWithoutAnalystInput | ResearchAnalysisUpsertWithWhereUniqueWithoutAnalystInput[]
    createMany?: ResearchAnalysisCreateManyAnalystInputEnvelope
    set?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    disconnect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    delete?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    update?: ResearchAnalysisUpdateWithWhereUniqueWithoutAnalystInput | ResearchAnalysisUpdateWithWhereUniqueWithoutAnalystInput[]
    updateMany?: ResearchAnalysisUpdateManyWithWhereWithoutAnalystInput | ResearchAnalysisUpdateManyWithWhereWithoutAnalystInput[]
    deleteMany?: ResearchAnalysisScalarWhereInput | ResearchAnalysisScalarWhereInput[]
  }

  export type ResearchAnalysisUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<ResearchAnalysisCreateWithoutApprovedByInput, ResearchAnalysisUncheckedCreateWithoutApprovedByInput> | ResearchAnalysisCreateWithoutApprovedByInput[] | ResearchAnalysisUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutApprovedByInput | ResearchAnalysisCreateOrConnectWithoutApprovedByInput[]
    upsert?: ResearchAnalysisUpsertWithWhereUniqueWithoutApprovedByInput | ResearchAnalysisUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: ResearchAnalysisCreateManyApprovedByInputEnvelope
    set?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    disconnect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    delete?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    update?: ResearchAnalysisUpdateWithWhereUniqueWithoutApprovedByInput | ResearchAnalysisUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: ResearchAnalysisUpdateManyWithWhereWithoutApprovedByInput | ResearchAnalysisUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: ResearchAnalysisScalarWhereInput | ResearchAnalysisScalarWhereInput[]
  }

  export type ResearchAnalysisUpdateManyWithoutReviewedByNestedInput = {
    create?: XOR<ResearchAnalysisCreateWithoutReviewedByInput, ResearchAnalysisUncheckedCreateWithoutReviewedByInput> | ResearchAnalysisCreateWithoutReviewedByInput[] | ResearchAnalysisUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutReviewedByInput | ResearchAnalysisCreateOrConnectWithoutReviewedByInput[]
    upsert?: ResearchAnalysisUpsertWithWhereUniqueWithoutReviewedByInput | ResearchAnalysisUpsertWithWhereUniqueWithoutReviewedByInput[]
    createMany?: ResearchAnalysisCreateManyReviewedByInputEnvelope
    set?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    disconnect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    delete?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    update?: ResearchAnalysisUpdateWithWhereUniqueWithoutReviewedByInput | ResearchAnalysisUpdateWithWhereUniqueWithoutReviewedByInput[]
    updateMany?: ResearchAnalysisUpdateManyWithWhereWithoutReviewedByInput | ResearchAnalysisUpdateManyWithWhereWithoutReviewedByInput[]
    deleteMany?: ResearchAnalysisScalarWhereInput | ResearchAnalysisScalarWhereInput[]
  }

  export type ResearchProjectUpdateManyWithoutPrincipalInvestigatorNestedInput = {
    create?: XOR<ResearchProjectCreateWithoutPrincipalInvestigatorInput, ResearchProjectUncheckedCreateWithoutPrincipalInvestigatorInput> | ResearchProjectCreateWithoutPrincipalInvestigatorInput[] | ResearchProjectUncheckedCreateWithoutPrincipalInvestigatorInput[]
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutPrincipalInvestigatorInput | ResearchProjectCreateOrConnectWithoutPrincipalInvestigatorInput[]
    upsert?: ResearchProjectUpsertWithWhereUniqueWithoutPrincipalInvestigatorInput | ResearchProjectUpsertWithWhereUniqueWithoutPrincipalInvestigatorInput[]
    createMany?: ResearchProjectCreateManyPrincipalInvestigatorInputEnvelope
    set?: ResearchProjectWhereUniqueInput | ResearchProjectWhereUniqueInput[]
    disconnect?: ResearchProjectWhereUniqueInput | ResearchProjectWhereUniqueInput[]
    delete?: ResearchProjectWhereUniqueInput | ResearchProjectWhereUniqueInput[]
    connect?: ResearchProjectWhereUniqueInput | ResearchProjectWhereUniqueInput[]
    update?: ResearchProjectUpdateWithWhereUniqueWithoutPrincipalInvestigatorInput | ResearchProjectUpdateWithWhereUniqueWithoutPrincipalInvestigatorInput[]
    updateMany?: ResearchProjectUpdateManyWithWhereWithoutPrincipalInvestigatorInput | ResearchProjectUpdateManyWithWhereWithoutPrincipalInvestigatorInput[]
    deleteMany?: ResearchProjectScalarWhereInput | ResearchProjectScalarWhereInput[]
  }

  export type UploadedImageUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<UploadedImageCreateWithoutUploadedByInput, UploadedImageUncheckedCreateWithoutUploadedByInput> | UploadedImageCreateWithoutUploadedByInput[] | UploadedImageUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: UploadedImageCreateOrConnectWithoutUploadedByInput | UploadedImageCreateOrConnectWithoutUploadedByInput[]
    upsert?: UploadedImageUpsertWithWhereUniqueWithoutUploadedByInput | UploadedImageUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: UploadedImageCreateManyUploadedByInputEnvelope
    set?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
    disconnect?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
    delete?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
    connect?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
    update?: UploadedImageUpdateWithWhereUniqueWithoutUploadedByInput | UploadedImageUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: UploadedImageUpdateManyWithWhereWithoutUploadedByInput | UploadedImageUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: UploadedImageScalarWhereInput | UploadedImageScalarWhereInput[]
  }

  export type KnowledgeIntegrationUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<KnowledgeIntegrationCreateWithoutCreatedByInput, KnowledgeIntegrationUncheckedCreateWithoutCreatedByInput> | KnowledgeIntegrationCreateWithoutCreatedByInput[] | KnowledgeIntegrationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: KnowledgeIntegrationCreateOrConnectWithoutCreatedByInput | KnowledgeIntegrationCreateOrConnectWithoutCreatedByInput[]
    upsert?: KnowledgeIntegrationUpsertWithWhereUniqueWithoutCreatedByInput | KnowledgeIntegrationUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: KnowledgeIntegrationCreateManyCreatedByInputEnvelope
    set?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    disconnect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    delete?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    connect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    update?: KnowledgeIntegrationUpdateWithWhereUniqueWithoutCreatedByInput | KnowledgeIntegrationUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: KnowledgeIntegrationUpdateManyWithWhereWithoutCreatedByInput | KnowledgeIntegrationUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: KnowledgeIntegrationScalarWhereInput | KnowledgeIntegrationScalarWhereInput[]
  }

  export type ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutUserInput, ProjectCollaboratorUncheckedCreateWithoutUserInput> | ProjectCollaboratorCreateWithoutUserInput[] | ProjectCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutUserInput | ProjectCollaboratorCreateOrConnectWithoutUserInput[]
    upsert?: ProjectCollaboratorUpsertWithWhereUniqueWithoutUserInput | ProjectCollaboratorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCollaboratorCreateManyUserInputEnvelope
    set?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    disconnect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    delete?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    update?: ProjectCollaboratorUpdateWithWhereUniqueWithoutUserInput | ProjectCollaboratorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectCollaboratorUpdateManyWithWhereWithoutUserInput | ProjectCollaboratorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectCollaboratorScalarWhereInput | ProjectCollaboratorScalarWhereInput[]
  }

  export type ProjectMethodologyStepUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<ProjectMethodologyStepCreateWithoutAssignedToInput, ProjectMethodologyStepUncheckedCreateWithoutAssignedToInput> | ProjectMethodologyStepCreateWithoutAssignedToInput[] | ProjectMethodologyStepUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ProjectMethodologyStepCreateOrConnectWithoutAssignedToInput | ProjectMethodologyStepCreateOrConnectWithoutAssignedToInput[]
    upsert?: ProjectMethodologyStepUpsertWithWhereUniqueWithoutAssignedToInput | ProjectMethodologyStepUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: ProjectMethodologyStepCreateManyAssignedToInputEnvelope
    set?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    disconnect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    delete?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    connect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    update?: ProjectMethodologyStepUpdateWithWhereUniqueWithoutAssignedToInput | ProjectMethodologyStepUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: ProjectMethodologyStepUpdateManyWithWhereWithoutAssignedToInput | ProjectMethodologyStepUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: ProjectMethodologyStepScalarWhereInput | ProjectMethodologyStepScalarWhereInput[]
  }

  export type ResearchAnalysisUncheckedUpdateManyWithoutAnalystNestedInput = {
    create?: XOR<ResearchAnalysisCreateWithoutAnalystInput, ResearchAnalysisUncheckedCreateWithoutAnalystInput> | ResearchAnalysisCreateWithoutAnalystInput[] | ResearchAnalysisUncheckedCreateWithoutAnalystInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutAnalystInput | ResearchAnalysisCreateOrConnectWithoutAnalystInput[]
    upsert?: ResearchAnalysisUpsertWithWhereUniqueWithoutAnalystInput | ResearchAnalysisUpsertWithWhereUniqueWithoutAnalystInput[]
    createMany?: ResearchAnalysisCreateManyAnalystInputEnvelope
    set?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    disconnect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    delete?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    update?: ResearchAnalysisUpdateWithWhereUniqueWithoutAnalystInput | ResearchAnalysisUpdateWithWhereUniqueWithoutAnalystInput[]
    updateMany?: ResearchAnalysisUpdateManyWithWhereWithoutAnalystInput | ResearchAnalysisUpdateManyWithWhereWithoutAnalystInput[]
    deleteMany?: ResearchAnalysisScalarWhereInput | ResearchAnalysisScalarWhereInput[]
  }

  export type ResearchAnalysisUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<ResearchAnalysisCreateWithoutApprovedByInput, ResearchAnalysisUncheckedCreateWithoutApprovedByInput> | ResearchAnalysisCreateWithoutApprovedByInput[] | ResearchAnalysisUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutApprovedByInput | ResearchAnalysisCreateOrConnectWithoutApprovedByInput[]
    upsert?: ResearchAnalysisUpsertWithWhereUniqueWithoutApprovedByInput | ResearchAnalysisUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: ResearchAnalysisCreateManyApprovedByInputEnvelope
    set?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    disconnect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    delete?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    update?: ResearchAnalysisUpdateWithWhereUniqueWithoutApprovedByInput | ResearchAnalysisUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: ResearchAnalysisUpdateManyWithWhereWithoutApprovedByInput | ResearchAnalysisUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: ResearchAnalysisScalarWhereInput | ResearchAnalysisScalarWhereInput[]
  }

  export type ResearchAnalysisUncheckedUpdateManyWithoutReviewedByNestedInput = {
    create?: XOR<ResearchAnalysisCreateWithoutReviewedByInput, ResearchAnalysisUncheckedCreateWithoutReviewedByInput> | ResearchAnalysisCreateWithoutReviewedByInput[] | ResearchAnalysisUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutReviewedByInput | ResearchAnalysisCreateOrConnectWithoutReviewedByInput[]
    upsert?: ResearchAnalysisUpsertWithWhereUniqueWithoutReviewedByInput | ResearchAnalysisUpsertWithWhereUniqueWithoutReviewedByInput[]
    createMany?: ResearchAnalysisCreateManyReviewedByInputEnvelope
    set?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    disconnect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    delete?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    update?: ResearchAnalysisUpdateWithWhereUniqueWithoutReviewedByInput | ResearchAnalysisUpdateWithWhereUniqueWithoutReviewedByInput[]
    updateMany?: ResearchAnalysisUpdateManyWithWhereWithoutReviewedByInput | ResearchAnalysisUpdateManyWithWhereWithoutReviewedByInput[]
    deleteMany?: ResearchAnalysisScalarWhereInput | ResearchAnalysisScalarWhereInput[]
  }

  export type ResearchProjectUncheckedUpdateManyWithoutPrincipalInvestigatorNestedInput = {
    create?: XOR<ResearchProjectCreateWithoutPrincipalInvestigatorInput, ResearchProjectUncheckedCreateWithoutPrincipalInvestigatorInput> | ResearchProjectCreateWithoutPrincipalInvestigatorInput[] | ResearchProjectUncheckedCreateWithoutPrincipalInvestigatorInput[]
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutPrincipalInvestigatorInput | ResearchProjectCreateOrConnectWithoutPrincipalInvestigatorInput[]
    upsert?: ResearchProjectUpsertWithWhereUniqueWithoutPrincipalInvestigatorInput | ResearchProjectUpsertWithWhereUniqueWithoutPrincipalInvestigatorInput[]
    createMany?: ResearchProjectCreateManyPrincipalInvestigatorInputEnvelope
    set?: ResearchProjectWhereUniqueInput | ResearchProjectWhereUniqueInput[]
    disconnect?: ResearchProjectWhereUniqueInput | ResearchProjectWhereUniqueInput[]
    delete?: ResearchProjectWhereUniqueInput | ResearchProjectWhereUniqueInput[]
    connect?: ResearchProjectWhereUniqueInput | ResearchProjectWhereUniqueInput[]
    update?: ResearchProjectUpdateWithWhereUniqueWithoutPrincipalInvestigatorInput | ResearchProjectUpdateWithWhereUniqueWithoutPrincipalInvestigatorInput[]
    updateMany?: ResearchProjectUpdateManyWithWhereWithoutPrincipalInvestigatorInput | ResearchProjectUpdateManyWithWhereWithoutPrincipalInvestigatorInput[]
    deleteMany?: ResearchProjectScalarWhereInput | ResearchProjectScalarWhereInput[]
  }

  export type UploadedImageUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<UploadedImageCreateWithoutUploadedByInput, UploadedImageUncheckedCreateWithoutUploadedByInput> | UploadedImageCreateWithoutUploadedByInput[] | UploadedImageUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: UploadedImageCreateOrConnectWithoutUploadedByInput | UploadedImageCreateOrConnectWithoutUploadedByInput[]
    upsert?: UploadedImageUpsertWithWhereUniqueWithoutUploadedByInput | UploadedImageUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: UploadedImageCreateManyUploadedByInputEnvelope
    set?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
    disconnect?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
    delete?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
    connect?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
    update?: UploadedImageUpdateWithWhereUniqueWithoutUploadedByInput | UploadedImageUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: UploadedImageUpdateManyWithWhereWithoutUploadedByInput | UploadedImageUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: UploadedImageScalarWhereInput | UploadedImageScalarWhereInput[]
  }

  export type AcademicDisciplineCreatekeywordsInput = {
    set: string[]
  }

  export type AcademicDisciplineCreateNestedOneWithoutChildDisciplinesInput = {
    create?: XOR<AcademicDisciplineCreateWithoutChildDisciplinesInput, AcademicDisciplineUncheckedCreateWithoutChildDisciplinesInput>
    connectOrCreate?: AcademicDisciplineCreateOrConnectWithoutChildDisciplinesInput
    connect?: AcademicDisciplineWhereUniqueInput
  }

  export type AcademicDisciplineCreateNestedManyWithoutParentDisciplineInput = {
    create?: XOR<AcademicDisciplineCreateWithoutParentDisciplineInput, AcademicDisciplineUncheckedCreateWithoutParentDisciplineInput> | AcademicDisciplineCreateWithoutParentDisciplineInput[] | AcademicDisciplineUncheckedCreateWithoutParentDisciplineInput[]
    connectOrCreate?: AcademicDisciplineCreateOrConnectWithoutParentDisciplineInput | AcademicDisciplineCreateOrConnectWithoutParentDisciplineInput[]
    createMany?: AcademicDisciplineCreateManyParentDisciplineInputEnvelope
    connect?: AcademicDisciplineWhereUniqueInput | AcademicDisciplineWhereUniqueInput[]
  }

  export type KnowledgeIntegrationCreateNestedManyWithoutSourceDisciplineInput = {
    create?: XOR<KnowledgeIntegrationCreateWithoutSourceDisciplineInput, KnowledgeIntegrationUncheckedCreateWithoutSourceDisciplineInput> | KnowledgeIntegrationCreateWithoutSourceDisciplineInput[] | KnowledgeIntegrationUncheckedCreateWithoutSourceDisciplineInput[]
    connectOrCreate?: KnowledgeIntegrationCreateOrConnectWithoutSourceDisciplineInput | KnowledgeIntegrationCreateOrConnectWithoutSourceDisciplineInput[]
    createMany?: KnowledgeIntegrationCreateManySourceDisciplineInputEnvelope
    connect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
  }

  export type KnowledgeIntegrationCreateNestedManyWithoutTargetDisciplineInput = {
    create?: XOR<KnowledgeIntegrationCreateWithoutTargetDisciplineInput, KnowledgeIntegrationUncheckedCreateWithoutTargetDisciplineInput> | KnowledgeIntegrationCreateWithoutTargetDisciplineInput[] | KnowledgeIntegrationUncheckedCreateWithoutTargetDisciplineInput[]
    connectOrCreate?: KnowledgeIntegrationCreateOrConnectWithoutTargetDisciplineInput | KnowledgeIntegrationCreateOrConnectWithoutTargetDisciplineInput[]
    createMany?: KnowledgeIntegrationCreateManyTargetDisciplineInputEnvelope
    connect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
  }

  export type ProjectDisciplineCreateNestedManyWithoutDisciplineInput = {
    create?: XOR<ProjectDisciplineCreateWithoutDisciplineInput, ProjectDisciplineUncheckedCreateWithoutDisciplineInput> | ProjectDisciplineCreateWithoutDisciplineInput[] | ProjectDisciplineUncheckedCreateWithoutDisciplineInput[]
    connectOrCreate?: ProjectDisciplineCreateOrConnectWithoutDisciplineInput | ProjectDisciplineCreateOrConnectWithoutDisciplineInput[]
    createMany?: ProjectDisciplineCreateManyDisciplineInputEnvelope
    connect?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
  }

  export type AcademicDisciplineUncheckedCreateNestedManyWithoutParentDisciplineInput = {
    create?: XOR<AcademicDisciplineCreateWithoutParentDisciplineInput, AcademicDisciplineUncheckedCreateWithoutParentDisciplineInput> | AcademicDisciplineCreateWithoutParentDisciplineInput[] | AcademicDisciplineUncheckedCreateWithoutParentDisciplineInput[]
    connectOrCreate?: AcademicDisciplineCreateOrConnectWithoutParentDisciplineInput | AcademicDisciplineCreateOrConnectWithoutParentDisciplineInput[]
    createMany?: AcademicDisciplineCreateManyParentDisciplineInputEnvelope
    connect?: AcademicDisciplineWhereUniqueInput | AcademicDisciplineWhereUniqueInput[]
  }

  export type KnowledgeIntegrationUncheckedCreateNestedManyWithoutSourceDisciplineInput = {
    create?: XOR<KnowledgeIntegrationCreateWithoutSourceDisciplineInput, KnowledgeIntegrationUncheckedCreateWithoutSourceDisciplineInput> | KnowledgeIntegrationCreateWithoutSourceDisciplineInput[] | KnowledgeIntegrationUncheckedCreateWithoutSourceDisciplineInput[]
    connectOrCreate?: KnowledgeIntegrationCreateOrConnectWithoutSourceDisciplineInput | KnowledgeIntegrationCreateOrConnectWithoutSourceDisciplineInput[]
    createMany?: KnowledgeIntegrationCreateManySourceDisciplineInputEnvelope
    connect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
  }

  export type KnowledgeIntegrationUncheckedCreateNestedManyWithoutTargetDisciplineInput = {
    create?: XOR<KnowledgeIntegrationCreateWithoutTargetDisciplineInput, KnowledgeIntegrationUncheckedCreateWithoutTargetDisciplineInput> | KnowledgeIntegrationCreateWithoutTargetDisciplineInput[] | KnowledgeIntegrationUncheckedCreateWithoutTargetDisciplineInput[]
    connectOrCreate?: KnowledgeIntegrationCreateOrConnectWithoutTargetDisciplineInput | KnowledgeIntegrationCreateOrConnectWithoutTargetDisciplineInput[]
    createMany?: KnowledgeIntegrationCreateManyTargetDisciplineInputEnvelope
    connect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
  }

  export type ProjectDisciplineUncheckedCreateNestedManyWithoutDisciplineInput = {
    create?: XOR<ProjectDisciplineCreateWithoutDisciplineInput, ProjectDisciplineUncheckedCreateWithoutDisciplineInput> | ProjectDisciplineCreateWithoutDisciplineInput[] | ProjectDisciplineUncheckedCreateWithoutDisciplineInput[]
    connectOrCreate?: ProjectDisciplineCreateOrConnectWithoutDisciplineInput | ProjectDisciplineCreateOrConnectWithoutDisciplineInput[]
    createMany?: ProjectDisciplineCreateManyDisciplineInputEnvelope
    connect?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
  }

  export type AcademicDisciplineUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AcademicDisciplineUpdateOneWithoutChildDisciplinesNestedInput = {
    create?: XOR<AcademicDisciplineCreateWithoutChildDisciplinesInput, AcademicDisciplineUncheckedCreateWithoutChildDisciplinesInput>
    connectOrCreate?: AcademicDisciplineCreateOrConnectWithoutChildDisciplinesInput
    upsert?: AcademicDisciplineUpsertWithoutChildDisciplinesInput
    disconnect?: AcademicDisciplineWhereInput | boolean
    delete?: AcademicDisciplineWhereInput | boolean
    connect?: AcademicDisciplineWhereUniqueInput
    update?: XOR<XOR<AcademicDisciplineUpdateToOneWithWhereWithoutChildDisciplinesInput, AcademicDisciplineUpdateWithoutChildDisciplinesInput>, AcademicDisciplineUncheckedUpdateWithoutChildDisciplinesInput>
  }

  export type AcademicDisciplineUpdateManyWithoutParentDisciplineNestedInput = {
    create?: XOR<AcademicDisciplineCreateWithoutParentDisciplineInput, AcademicDisciplineUncheckedCreateWithoutParentDisciplineInput> | AcademicDisciplineCreateWithoutParentDisciplineInput[] | AcademicDisciplineUncheckedCreateWithoutParentDisciplineInput[]
    connectOrCreate?: AcademicDisciplineCreateOrConnectWithoutParentDisciplineInput | AcademicDisciplineCreateOrConnectWithoutParentDisciplineInput[]
    upsert?: AcademicDisciplineUpsertWithWhereUniqueWithoutParentDisciplineInput | AcademicDisciplineUpsertWithWhereUniqueWithoutParentDisciplineInput[]
    createMany?: AcademicDisciplineCreateManyParentDisciplineInputEnvelope
    set?: AcademicDisciplineWhereUniqueInput | AcademicDisciplineWhereUniqueInput[]
    disconnect?: AcademicDisciplineWhereUniqueInput | AcademicDisciplineWhereUniqueInput[]
    delete?: AcademicDisciplineWhereUniqueInput | AcademicDisciplineWhereUniqueInput[]
    connect?: AcademicDisciplineWhereUniqueInput | AcademicDisciplineWhereUniqueInput[]
    update?: AcademicDisciplineUpdateWithWhereUniqueWithoutParentDisciplineInput | AcademicDisciplineUpdateWithWhereUniqueWithoutParentDisciplineInput[]
    updateMany?: AcademicDisciplineUpdateManyWithWhereWithoutParentDisciplineInput | AcademicDisciplineUpdateManyWithWhereWithoutParentDisciplineInput[]
    deleteMany?: AcademicDisciplineScalarWhereInput | AcademicDisciplineScalarWhereInput[]
  }

  export type KnowledgeIntegrationUpdateManyWithoutSourceDisciplineNestedInput = {
    create?: XOR<KnowledgeIntegrationCreateWithoutSourceDisciplineInput, KnowledgeIntegrationUncheckedCreateWithoutSourceDisciplineInput> | KnowledgeIntegrationCreateWithoutSourceDisciplineInput[] | KnowledgeIntegrationUncheckedCreateWithoutSourceDisciplineInput[]
    connectOrCreate?: KnowledgeIntegrationCreateOrConnectWithoutSourceDisciplineInput | KnowledgeIntegrationCreateOrConnectWithoutSourceDisciplineInput[]
    upsert?: KnowledgeIntegrationUpsertWithWhereUniqueWithoutSourceDisciplineInput | KnowledgeIntegrationUpsertWithWhereUniqueWithoutSourceDisciplineInput[]
    createMany?: KnowledgeIntegrationCreateManySourceDisciplineInputEnvelope
    set?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    disconnect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    delete?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    connect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    update?: KnowledgeIntegrationUpdateWithWhereUniqueWithoutSourceDisciplineInput | KnowledgeIntegrationUpdateWithWhereUniqueWithoutSourceDisciplineInput[]
    updateMany?: KnowledgeIntegrationUpdateManyWithWhereWithoutSourceDisciplineInput | KnowledgeIntegrationUpdateManyWithWhereWithoutSourceDisciplineInput[]
    deleteMany?: KnowledgeIntegrationScalarWhereInput | KnowledgeIntegrationScalarWhereInput[]
  }

  export type KnowledgeIntegrationUpdateManyWithoutTargetDisciplineNestedInput = {
    create?: XOR<KnowledgeIntegrationCreateWithoutTargetDisciplineInput, KnowledgeIntegrationUncheckedCreateWithoutTargetDisciplineInput> | KnowledgeIntegrationCreateWithoutTargetDisciplineInput[] | KnowledgeIntegrationUncheckedCreateWithoutTargetDisciplineInput[]
    connectOrCreate?: KnowledgeIntegrationCreateOrConnectWithoutTargetDisciplineInput | KnowledgeIntegrationCreateOrConnectWithoutTargetDisciplineInput[]
    upsert?: KnowledgeIntegrationUpsertWithWhereUniqueWithoutTargetDisciplineInput | KnowledgeIntegrationUpsertWithWhereUniqueWithoutTargetDisciplineInput[]
    createMany?: KnowledgeIntegrationCreateManyTargetDisciplineInputEnvelope
    set?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    disconnect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    delete?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    connect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    update?: KnowledgeIntegrationUpdateWithWhereUniqueWithoutTargetDisciplineInput | KnowledgeIntegrationUpdateWithWhereUniqueWithoutTargetDisciplineInput[]
    updateMany?: KnowledgeIntegrationUpdateManyWithWhereWithoutTargetDisciplineInput | KnowledgeIntegrationUpdateManyWithWhereWithoutTargetDisciplineInput[]
    deleteMany?: KnowledgeIntegrationScalarWhereInput | KnowledgeIntegrationScalarWhereInput[]
  }

  export type ProjectDisciplineUpdateManyWithoutDisciplineNestedInput = {
    create?: XOR<ProjectDisciplineCreateWithoutDisciplineInput, ProjectDisciplineUncheckedCreateWithoutDisciplineInput> | ProjectDisciplineCreateWithoutDisciplineInput[] | ProjectDisciplineUncheckedCreateWithoutDisciplineInput[]
    connectOrCreate?: ProjectDisciplineCreateOrConnectWithoutDisciplineInput | ProjectDisciplineCreateOrConnectWithoutDisciplineInput[]
    upsert?: ProjectDisciplineUpsertWithWhereUniqueWithoutDisciplineInput | ProjectDisciplineUpsertWithWhereUniqueWithoutDisciplineInput[]
    createMany?: ProjectDisciplineCreateManyDisciplineInputEnvelope
    set?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
    disconnect?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
    delete?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
    connect?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
    update?: ProjectDisciplineUpdateWithWhereUniqueWithoutDisciplineInput | ProjectDisciplineUpdateWithWhereUniqueWithoutDisciplineInput[]
    updateMany?: ProjectDisciplineUpdateManyWithWhereWithoutDisciplineInput | ProjectDisciplineUpdateManyWithWhereWithoutDisciplineInput[]
    deleteMany?: ProjectDisciplineScalarWhereInput | ProjectDisciplineScalarWhereInput[]
  }

  export type AcademicDisciplineUncheckedUpdateManyWithoutParentDisciplineNestedInput = {
    create?: XOR<AcademicDisciplineCreateWithoutParentDisciplineInput, AcademicDisciplineUncheckedCreateWithoutParentDisciplineInput> | AcademicDisciplineCreateWithoutParentDisciplineInput[] | AcademicDisciplineUncheckedCreateWithoutParentDisciplineInput[]
    connectOrCreate?: AcademicDisciplineCreateOrConnectWithoutParentDisciplineInput | AcademicDisciplineCreateOrConnectWithoutParentDisciplineInput[]
    upsert?: AcademicDisciplineUpsertWithWhereUniqueWithoutParentDisciplineInput | AcademicDisciplineUpsertWithWhereUniqueWithoutParentDisciplineInput[]
    createMany?: AcademicDisciplineCreateManyParentDisciplineInputEnvelope
    set?: AcademicDisciplineWhereUniqueInput | AcademicDisciplineWhereUniqueInput[]
    disconnect?: AcademicDisciplineWhereUniqueInput | AcademicDisciplineWhereUniqueInput[]
    delete?: AcademicDisciplineWhereUniqueInput | AcademicDisciplineWhereUniqueInput[]
    connect?: AcademicDisciplineWhereUniqueInput | AcademicDisciplineWhereUniqueInput[]
    update?: AcademicDisciplineUpdateWithWhereUniqueWithoutParentDisciplineInput | AcademicDisciplineUpdateWithWhereUniqueWithoutParentDisciplineInput[]
    updateMany?: AcademicDisciplineUpdateManyWithWhereWithoutParentDisciplineInput | AcademicDisciplineUpdateManyWithWhereWithoutParentDisciplineInput[]
    deleteMany?: AcademicDisciplineScalarWhereInput | AcademicDisciplineScalarWhereInput[]
  }

  export type KnowledgeIntegrationUncheckedUpdateManyWithoutSourceDisciplineNestedInput = {
    create?: XOR<KnowledgeIntegrationCreateWithoutSourceDisciplineInput, KnowledgeIntegrationUncheckedCreateWithoutSourceDisciplineInput> | KnowledgeIntegrationCreateWithoutSourceDisciplineInput[] | KnowledgeIntegrationUncheckedCreateWithoutSourceDisciplineInput[]
    connectOrCreate?: KnowledgeIntegrationCreateOrConnectWithoutSourceDisciplineInput | KnowledgeIntegrationCreateOrConnectWithoutSourceDisciplineInput[]
    upsert?: KnowledgeIntegrationUpsertWithWhereUniqueWithoutSourceDisciplineInput | KnowledgeIntegrationUpsertWithWhereUniqueWithoutSourceDisciplineInput[]
    createMany?: KnowledgeIntegrationCreateManySourceDisciplineInputEnvelope
    set?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    disconnect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    delete?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    connect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    update?: KnowledgeIntegrationUpdateWithWhereUniqueWithoutSourceDisciplineInput | KnowledgeIntegrationUpdateWithWhereUniqueWithoutSourceDisciplineInput[]
    updateMany?: KnowledgeIntegrationUpdateManyWithWhereWithoutSourceDisciplineInput | KnowledgeIntegrationUpdateManyWithWhereWithoutSourceDisciplineInput[]
    deleteMany?: KnowledgeIntegrationScalarWhereInput | KnowledgeIntegrationScalarWhereInput[]
  }

  export type KnowledgeIntegrationUncheckedUpdateManyWithoutTargetDisciplineNestedInput = {
    create?: XOR<KnowledgeIntegrationCreateWithoutTargetDisciplineInput, KnowledgeIntegrationUncheckedCreateWithoutTargetDisciplineInput> | KnowledgeIntegrationCreateWithoutTargetDisciplineInput[] | KnowledgeIntegrationUncheckedCreateWithoutTargetDisciplineInput[]
    connectOrCreate?: KnowledgeIntegrationCreateOrConnectWithoutTargetDisciplineInput | KnowledgeIntegrationCreateOrConnectWithoutTargetDisciplineInput[]
    upsert?: KnowledgeIntegrationUpsertWithWhereUniqueWithoutTargetDisciplineInput | KnowledgeIntegrationUpsertWithWhereUniqueWithoutTargetDisciplineInput[]
    createMany?: KnowledgeIntegrationCreateManyTargetDisciplineInputEnvelope
    set?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    disconnect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    delete?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    connect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    update?: KnowledgeIntegrationUpdateWithWhereUniqueWithoutTargetDisciplineInput | KnowledgeIntegrationUpdateWithWhereUniqueWithoutTargetDisciplineInput[]
    updateMany?: KnowledgeIntegrationUpdateManyWithWhereWithoutTargetDisciplineInput | KnowledgeIntegrationUpdateManyWithWhereWithoutTargetDisciplineInput[]
    deleteMany?: KnowledgeIntegrationScalarWhereInput | KnowledgeIntegrationScalarWhereInput[]
  }

  export type ProjectDisciplineUncheckedUpdateManyWithoutDisciplineNestedInput = {
    create?: XOR<ProjectDisciplineCreateWithoutDisciplineInput, ProjectDisciplineUncheckedCreateWithoutDisciplineInput> | ProjectDisciplineCreateWithoutDisciplineInput[] | ProjectDisciplineUncheckedCreateWithoutDisciplineInput[]
    connectOrCreate?: ProjectDisciplineCreateOrConnectWithoutDisciplineInput | ProjectDisciplineCreateOrConnectWithoutDisciplineInput[]
    upsert?: ProjectDisciplineUpsertWithWhereUniqueWithoutDisciplineInput | ProjectDisciplineUpsertWithWhereUniqueWithoutDisciplineInput[]
    createMany?: ProjectDisciplineCreateManyDisciplineInputEnvelope
    set?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
    disconnect?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
    delete?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
    connect?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
    update?: ProjectDisciplineUpdateWithWhereUniqueWithoutDisciplineInput | ProjectDisciplineUpdateWithWhereUniqueWithoutDisciplineInput[]
    updateMany?: ProjectDisciplineUpdateManyWithWhereWithoutDisciplineInput | ProjectDisciplineUpdateManyWithWhereWithoutDisciplineInput[]
    deleteMany?: ProjectDisciplineScalarWhereInput | ProjectDisciplineScalarWhereInput[]
  }

  export type OnetOccupationCreatetasksInput = {
    set: string[]
  }

  export type OnetOccupationCreateskillsInput = {
    set: string[]
  }

  export type OnetOccupationCreateknowledgeAreasInput = {
    set: string[]
  }

  export type OnetOccupationCreateabilitiesInput = {
    set: string[]
  }

  export type ProjectOccupationCreateNestedManyWithoutOccupationInput = {
    create?: XOR<ProjectOccupationCreateWithoutOccupationInput, ProjectOccupationUncheckedCreateWithoutOccupationInput> | ProjectOccupationCreateWithoutOccupationInput[] | ProjectOccupationUncheckedCreateWithoutOccupationInput[]
    connectOrCreate?: ProjectOccupationCreateOrConnectWithoutOccupationInput | ProjectOccupationCreateOrConnectWithoutOccupationInput[]
    createMany?: ProjectOccupationCreateManyOccupationInputEnvelope
    connect?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
  }

  export type ProjectOccupationUncheckedCreateNestedManyWithoutOccupationInput = {
    create?: XOR<ProjectOccupationCreateWithoutOccupationInput, ProjectOccupationUncheckedCreateWithoutOccupationInput> | ProjectOccupationCreateWithoutOccupationInput[] | ProjectOccupationUncheckedCreateWithoutOccupationInput[]
    connectOrCreate?: ProjectOccupationCreateOrConnectWithoutOccupationInput | ProjectOccupationCreateOrConnectWithoutOccupationInput[]
    createMany?: ProjectOccupationCreateManyOccupationInputEnvelope
    connect?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
  }

  export type OnetOccupationUpdatetasksInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OnetOccupationUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OnetOccupationUpdateknowledgeAreasInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OnetOccupationUpdateabilitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectOccupationUpdateManyWithoutOccupationNestedInput = {
    create?: XOR<ProjectOccupationCreateWithoutOccupationInput, ProjectOccupationUncheckedCreateWithoutOccupationInput> | ProjectOccupationCreateWithoutOccupationInput[] | ProjectOccupationUncheckedCreateWithoutOccupationInput[]
    connectOrCreate?: ProjectOccupationCreateOrConnectWithoutOccupationInput | ProjectOccupationCreateOrConnectWithoutOccupationInput[]
    upsert?: ProjectOccupationUpsertWithWhereUniqueWithoutOccupationInput | ProjectOccupationUpsertWithWhereUniqueWithoutOccupationInput[]
    createMany?: ProjectOccupationCreateManyOccupationInputEnvelope
    set?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
    disconnect?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
    delete?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
    connect?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
    update?: ProjectOccupationUpdateWithWhereUniqueWithoutOccupationInput | ProjectOccupationUpdateWithWhereUniqueWithoutOccupationInput[]
    updateMany?: ProjectOccupationUpdateManyWithWhereWithoutOccupationInput | ProjectOccupationUpdateManyWithWhereWithoutOccupationInput[]
    deleteMany?: ProjectOccupationScalarWhereInput | ProjectOccupationScalarWhereInput[]
  }

  export type ProjectOccupationUncheckedUpdateManyWithoutOccupationNestedInput = {
    create?: XOR<ProjectOccupationCreateWithoutOccupationInput, ProjectOccupationUncheckedCreateWithoutOccupationInput> | ProjectOccupationCreateWithoutOccupationInput[] | ProjectOccupationUncheckedCreateWithoutOccupationInput[]
    connectOrCreate?: ProjectOccupationCreateOrConnectWithoutOccupationInput | ProjectOccupationCreateOrConnectWithoutOccupationInput[]
    upsert?: ProjectOccupationUpsertWithWhereUniqueWithoutOccupationInput | ProjectOccupationUpsertWithWhereUniqueWithoutOccupationInput[]
    createMany?: ProjectOccupationCreateManyOccupationInputEnvelope
    set?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
    disconnect?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
    delete?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
    connect?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
    update?: ProjectOccupationUpdateWithWhereUniqueWithoutOccupationInput | ProjectOccupationUpdateWithWhereUniqueWithoutOccupationInput[]
    updateMany?: ProjectOccupationUpdateManyWithWhereWithoutOccupationInput | ProjectOccupationUpdateManyWithWhereWithoutOccupationInput[]
    deleteMany?: ProjectOccupationScalarWhereInput | ProjectOccupationScalarWhereInput[]
  }

  export type ResearchProjectCreateinstitutionsInput = {
    set: string[]
  }

  export type ResearchProjectCreateresearchQuestionsInput = {
    set: string[]
  }

  export type ResearchProjectCreateobjectivesInput = {
    set: string[]
  }

  export type ResearchProjectCreatehypothesesInput = {
    set: string[]
  }

  export type ResearchProjectCreatetagsInput = {
    set: string[]
  }

  export type KnowledgeIntegrationCreateNestedManyWithoutProjectInput = {
    create?: XOR<KnowledgeIntegrationCreateWithoutProjectInput, KnowledgeIntegrationUncheckedCreateWithoutProjectInput> | KnowledgeIntegrationCreateWithoutProjectInput[] | KnowledgeIntegrationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: KnowledgeIntegrationCreateOrConnectWithoutProjectInput | KnowledgeIntegrationCreateOrConnectWithoutProjectInput[]
    createMany?: KnowledgeIntegrationCreateManyProjectInputEnvelope
    connect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
  }

  export type ProjectCollaboratorCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput> | ProjectCollaboratorCreateWithoutProjectInput[] | ProjectCollaboratorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutProjectInput | ProjectCollaboratorCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectCollaboratorCreateManyProjectInputEnvelope
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
  }

  export type ProjectDisciplineCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectDisciplineCreateWithoutProjectInput, ProjectDisciplineUncheckedCreateWithoutProjectInput> | ProjectDisciplineCreateWithoutProjectInput[] | ProjectDisciplineUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDisciplineCreateOrConnectWithoutProjectInput | ProjectDisciplineCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectDisciplineCreateManyProjectInputEnvelope
    connect?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
  }

  export type ProjectMethodologyStepCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMethodologyStepCreateWithoutProjectInput, ProjectMethodologyStepUncheckedCreateWithoutProjectInput> | ProjectMethodologyStepCreateWithoutProjectInput[] | ProjectMethodologyStepUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMethodologyStepCreateOrConnectWithoutProjectInput | ProjectMethodologyStepCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMethodologyStepCreateManyProjectInputEnvelope
    connect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
  }

  export type ProjectOccupationCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectOccupationCreateWithoutProjectInput, ProjectOccupationUncheckedCreateWithoutProjectInput> | ProjectOccupationCreateWithoutProjectInput[] | ProjectOccupationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectOccupationCreateOrConnectWithoutProjectInput | ProjectOccupationCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectOccupationCreateManyProjectInputEnvelope
    connect?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
  }

  export type ResearchAnalysisCreateNestedManyWithoutProjectInput = {
    create?: XOR<ResearchAnalysisCreateWithoutProjectInput, ResearchAnalysisUncheckedCreateWithoutProjectInput> | ResearchAnalysisCreateWithoutProjectInput[] | ResearchAnalysisUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutProjectInput | ResearchAnalysisCreateOrConnectWithoutProjectInput[]
    createMany?: ResearchAnalysisCreateManyProjectInputEnvelope
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type UploadedImageCreateNestedManyWithoutProjectInput = {
    create?: XOR<UploadedImageCreateWithoutProjectInput, UploadedImageUncheckedCreateWithoutProjectInput> | UploadedImageCreateWithoutProjectInput[] | UploadedImageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UploadedImageCreateOrConnectWithoutProjectInput | UploadedImageCreateOrConnectWithoutProjectInput[]
    createMany?: UploadedImageCreateManyProjectInputEnvelope
    connect?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
  }

  export type KnowledgeIntegrationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<KnowledgeIntegrationCreateWithoutProjectInput, KnowledgeIntegrationUncheckedCreateWithoutProjectInput> | KnowledgeIntegrationCreateWithoutProjectInput[] | KnowledgeIntegrationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: KnowledgeIntegrationCreateOrConnectWithoutProjectInput | KnowledgeIntegrationCreateOrConnectWithoutProjectInput[]
    createMany?: KnowledgeIntegrationCreateManyProjectInputEnvelope
    connect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
  }

  export type ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput> | ProjectCollaboratorCreateWithoutProjectInput[] | ProjectCollaboratorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutProjectInput | ProjectCollaboratorCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectCollaboratorCreateManyProjectInputEnvelope
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
  }

  export type ProjectDisciplineUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectDisciplineCreateWithoutProjectInput, ProjectDisciplineUncheckedCreateWithoutProjectInput> | ProjectDisciplineCreateWithoutProjectInput[] | ProjectDisciplineUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDisciplineCreateOrConnectWithoutProjectInput | ProjectDisciplineCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectDisciplineCreateManyProjectInputEnvelope
    connect?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
  }

  export type ProjectMethodologyStepUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMethodologyStepCreateWithoutProjectInput, ProjectMethodologyStepUncheckedCreateWithoutProjectInput> | ProjectMethodologyStepCreateWithoutProjectInput[] | ProjectMethodologyStepUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMethodologyStepCreateOrConnectWithoutProjectInput | ProjectMethodologyStepCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMethodologyStepCreateManyProjectInputEnvelope
    connect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
  }

  export type ProjectOccupationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectOccupationCreateWithoutProjectInput, ProjectOccupationUncheckedCreateWithoutProjectInput> | ProjectOccupationCreateWithoutProjectInput[] | ProjectOccupationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectOccupationCreateOrConnectWithoutProjectInput | ProjectOccupationCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectOccupationCreateManyProjectInputEnvelope
    connect?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
  }

  export type ResearchAnalysisUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ResearchAnalysisCreateWithoutProjectInput, ResearchAnalysisUncheckedCreateWithoutProjectInput> | ResearchAnalysisCreateWithoutProjectInput[] | ResearchAnalysisUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutProjectInput | ResearchAnalysisCreateOrConnectWithoutProjectInput[]
    createMany?: ResearchAnalysisCreateManyProjectInputEnvelope
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
  }

  export type UploadedImageUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<UploadedImageCreateWithoutProjectInput, UploadedImageUncheckedCreateWithoutProjectInput> | UploadedImageCreateWithoutProjectInput[] | UploadedImageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UploadedImageCreateOrConnectWithoutProjectInput | UploadedImageCreateOrConnectWithoutProjectInput[]
    createMany?: UploadedImageCreateManyProjectInputEnvelope
    connect?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ResearchProjectUpdateinstitutionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumMethodologyTypeFieldUpdateOperationsInput = {
    set?: $Enums.MethodologyType
  }

  export type ResearchProjectUpdateresearchQuestionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ResearchProjectUpdateobjectivesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ResearchProjectUpdatehypothesesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ResearchProjectUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type KnowledgeIntegrationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<KnowledgeIntegrationCreateWithoutProjectInput, KnowledgeIntegrationUncheckedCreateWithoutProjectInput> | KnowledgeIntegrationCreateWithoutProjectInput[] | KnowledgeIntegrationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: KnowledgeIntegrationCreateOrConnectWithoutProjectInput | KnowledgeIntegrationCreateOrConnectWithoutProjectInput[]
    upsert?: KnowledgeIntegrationUpsertWithWhereUniqueWithoutProjectInput | KnowledgeIntegrationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: KnowledgeIntegrationCreateManyProjectInputEnvelope
    set?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    disconnect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    delete?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    connect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    update?: KnowledgeIntegrationUpdateWithWhereUniqueWithoutProjectInput | KnowledgeIntegrationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: KnowledgeIntegrationUpdateManyWithWhereWithoutProjectInput | KnowledgeIntegrationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: KnowledgeIntegrationScalarWhereInput | KnowledgeIntegrationScalarWhereInput[]
  }

  export type ProjectCollaboratorUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput> | ProjectCollaboratorCreateWithoutProjectInput[] | ProjectCollaboratorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutProjectInput | ProjectCollaboratorCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectCollaboratorUpsertWithWhereUniqueWithoutProjectInput | ProjectCollaboratorUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectCollaboratorCreateManyProjectInputEnvelope
    set?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    disconnect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    delete?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    update?: ProjectCollaboratorUpdateWithWhereUniqueWithoutProjectInput | ProjectCollaboratorUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectCollaboratorUpdateManyWithWhereWithoutProjectInput | ProjectCollaboratorUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectCollaboratorScalarWhereInput | ProjectCollaboratorScalarWhereInput[]
  }

  export type ProjectDisciplineUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectDisciplineCreateWithoutProjectInput, ProjectDisciplineUncheckedCreateWithoutProjectInput> | ProjectDisciplineCreateWithoutProjectInput[] | ProjectDisciplineUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDisciplineCreateOrConnectWithoutProjectInput | ProjectDisciplineCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectDisciplineUpsertWithWhereUniqueWithoutProjectInput | ProjectDisciplineUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectDisciplineCreateManyProjectInputEnvelope
    set?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
    disconnect?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
    delete?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
    connect?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
    update?: ProjectDisciplineUpdateWithWhereUniqueWithoutProjectInput | ProjectDisciplineUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectDisciplineUpdateManyWithWhereWithoutProjectInput | ProjectDisciplineUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectDisciplineScalarWhereInput | ProjectDisciplineScalarWhereInput[]
  }

  export type ProjectMethodologyStepUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMethodologyStepCreateWithoutProjectInput, ProjectMethodologyStepUncheckedCreateWithoutProjectInput> | ProjectMethodologyStepCreateWithoutProjectInput[] | ProjectMethodologyStepUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMethodologyStepCreateOrConnectWithoutProjectInput | ProjectMethodologyStepCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMethodologyStepUpsertWithWhereUniqueWithoutProjectInput | ProjectMethodologyStepUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMethodologyStepCreateManyProjectInputEnvelope
    set?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    disconnect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    delete?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    connect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    update?: ProjectMethodologyStepUpdateWithWhereUniqueWithoutProjectInput | ProjectMethodologyStepUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMethodologyStepUpdateManyWithWhereWithoutProjectInput | ProjectMethodologyStepUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMethodologyStepScalarWhereInput | ProjectMethodologyStepScalarWhereInput[]
  }

  export type ProjectOccupationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectOccupationCreateWithoutProjectInput, ProjectOccupationUncheckedCreateWithoutProjectInput> | ProjectOccupationCreateWithoutProjectInput[] | ProjectOccupationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectOccupationCreateOrConnectWithoutProjectInput | ProjectOccupationCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectOccupationUpsertWithWhereUniqueWithoutProjectInput | ProjectOccupationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectOccupationCreateManyProjectInputEnvelope
    set?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
    disconnect?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
    delete?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
    connect?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
    update?: ProjectOccupationUpdateWithWhereUniqueWithoutProjectInput | ProjectOccupationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectOccupationUpdateManyWithWhereWithoutProjectInput | ProjectOccupationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectOccupationScalarWhereInput | ProjectOccupationScalarWhereInput[]
  }

  export type ResearchAnalysisUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ResearchAnalysisCreateWithoutProjectInput, ResearchAnalysisUncheckedCreateWithoutProjectInput> | ResearchAnalysisCreateWithoutProjectInput[] | ResearchAnalysisUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutProjectInput | ResearchAnalysisCreateOrConnectWithoutProjectInput[]
    upsert?: ResearchAnalysisUpsertWithWhereUniqueWithoutProjectInput | ResearchAnalysisUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ResearchAnalysisCreateManyProjectInputEnvelope
    set?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    disconnect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    delete?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    update?: ResearchAnalysisUpdateWithWhereUniqueWithoutProjectInput | ResearchAnalysisUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ResearchAnalysisUpdateManyWithWhereWithoutProjectInput | ResearchAnalysisUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ResearchAnalysisScalarWhereInput | ResearchAnalysisScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UploadedImageUpdateManyWithoutProjectNestedInput = {
    create?: XOR<UploadedImageCreateWithoutProjectInput, UploadedImageUncheckedCreateWithoutProjectInput> | UploadedImageCreateWithoutProjectInput[] | UploadedImageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UploadedImageCreateOrConnectWithoutProjectInput | UploadedImageCreateOrConnectWithoutProjectInput[]
    upsert?: UploadedImageUpsertWithWhereUniqueWithoutProjectInput | UploadedImageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: UploadedImageCreateManyProjectInputEnvelope
    set?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
    disconnect?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
    delete?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
    connect?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
    update?: UploadedImageUpdateWithWhereUniqueWithoutProjectInput | UploadedImageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: UploadedImageUpdateManyWithWhereWithoutProjectInput | UploadedImageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: UploadedImageScalarWhereInput | UploadedImageScalarWhereInput[]
  }

  export type KnowledgeIntegrationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<KnowledgeIntegrationCreateWithoutProjectInput, KnowledgeIntegrationUncheckedCreateWithoutProjectInput> | KnowledgeIntegrationCreateWithoutProjectInput[] | KnowledgeIntegrationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: KnowledgeIntegrationCreateOrConnectWithoutProjectInput | KnowledgeIntegrationCreateOrConnectWithoutProjectInput[]
    upsert?: KnowledgeIntegrationUpsertWithWhereUniqueWithoutProjectInput | KnowledgeIntegrationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: KnowledgeIntegrationCreateManyProjectInputEnvelope
    set?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    disconnect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    delete?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    connect?: KnowledgeIntegrationWhereUniqueInput | KnowledgeIntegrationWhereUniqueInput[]
    update?: KnowledgeIntegrationUpdateWithWhereUniqueWithoutProjectInput | KnowledgeIntegrationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: KnowledgeIntegrationUpdateManyWithWhereWithoutProjectInput | KnowledgeIntegrationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: KnowledgeIntegrationScalarWhereInput | KnowledgeIntegrationScalarWhereInput[]
  }

  export type ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput> | ProjectCollaboratorCreateWithoutProjectInput[] | ProjectCollaboratorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectCollaboratorCreateOrConnectWithoutProjectInput | ProjectCollaboratorCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectCollaboratorUpsertWithWhereUniqueWithoutProjectInput | ProjectCollaboratorUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectCollaboratorCreateManyProjectInputEnvelope
    set?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    disconnect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    delete?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    connect?: ProjectCollaboratorWhereUniqueInput | ProjectCollaboratorWhereUniqueInput[]
    update?: ProjectCollaboratorUpdateWithWhereUniqueWithoutProjectInput | ProjectCollaboratorUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectCollaboratorUpdateManyWithWhereWithoutProjectInput | ProjectCollaboratorUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectCollaboratorScalarWhereInput | ProjectCollaboratorScalarWhereInput[]
  }

  export type ProjectDisciplineUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectDisciplineCreateWithoutProjectInput, ProjectDisciplineUncheckedCreateWithoutProjectInput> | ProjectDisciplineCreateWithoutProjectInput[] | ProjectDisciplineUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDisciplineCreateOrConnectWithoutProjectInput | ProjectDisciplineCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectDisciplineUpsertWithWhereUniqueWithoutProjectInput | ProjectDisciplineUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectDisciplineCreateManyProjectInputEnvelope
    set?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
    disconnect?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
    delete?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
    connect?: ProjectDisciplineWhereUniqueInput | ProjectDisciplineWhereUniqueInput[]
    update?: ProjectDisciplineUpdateWithWhereUniqueWithoutProjectInput | ProjectDisciplineUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectDisciplineUpdateManyWithWhereWithoutProjectInput | ProjectDisciplineUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectDisciplineScalarWhereInput | ProjectDisciplineScalarWhereInput[]
  }

  export type ProjectMethodologyStepUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMethodologyStepCreateWithoutProjectInput, ProjectMethodologyStepUncheckedCreateWithoutProjectInput> | ProjectMethodologyStepCreateWithoutProjectInput[] | ProjectMethodologyStepUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMethodologyStepCreateOrConnectWithoutProjectInput | ProjectMethodologyStepCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMethodologyStepUpsertWithWhereUniqueWithoutProjectInput | ProjectMethodologyStepUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMethodologyStepCreateManyProjectInputEnvelope
    set?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    disconnect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    delete?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    connect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    update?: ProjectMethodologyStepUpdateWithWhereUniqueWithoutProjectInput | ProjectMethodologyStepUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMethodologyStepUpdateManyWithWhereWithoutProjectInput | ProjectMethodologyStepUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMethodologyStepScalarWhereInput | ProjectMethodologyStepScalarWhereInput[]
  }

  export type ProjectOccupationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectOccupationCreateWithoutProjectInput, ProjectOccupationUncheckedCreateWithoutProjectInput> | ProjectOccupationCreateWithoutProjectInput[] | ProjectOccupationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectOccupationCreateOrConnectWithoutProjectInput | ProjectOccupationCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectOccupationUpsertWithWhereUniqueWithoutProjectInput | ProjectOccupationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectOccupationCreateManyProjectInputEnvelope
    set?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
    disconnect?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
    delete?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
    connect?: ProjectOccupationWhereUniqueInput | ProjectOccupationWhereUniqueInput[]
    update?: ProjectOccupationUpdateWithWhereUniqueWithoutProjectInput | ProjectOccupationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectOccupationUpdateManyWithWhereWithoutProjectInput | ProjectOccupationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectOccupationScalarWhereInput | ProjectOccupationScalarWhereInput[]
  }

  export type ResearchAnalysisUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ResearchAnalysisCreateWithoutProjectInput, ResearchAnalysisUncheckedCreateWithoutProjectInput> | ResearchAnalysisCreateWithoutProjectInput[] | ResearchAnalysisUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutProjectInput | ResearchAnalysisCreateOrConnectWithoutProjectInput[]
    upsert?: ResearchAnalysisUpsertWithWhereUniqueWithoutProjectInput | ResearchAnalysisUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ResearchAnalysisCreateManyProjectInputEnvelope
    set?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    disconnect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    delete?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    update?: ResearchAnalysisUpdateWithWhereUniqueWithoutProjectInput | ResearchAnalysisUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ResearchAnalysisUpdateManyWithWhereWithoutProjectInput | ResearchAnalysisUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ResearchAnalysisScalarWhereInput | ResearchAnalysisScalarWhereInput[]
  }

  export type UploadedImageUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<UploadedImageCreateWithoutProjectInput, UploadedImageUncheckedCreateWithoutProjectInput> | UploadedImageCreateWithoutProjectInput[] | UploadedImageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UploadedImageCreateOrConnectWithoutProjectInput | UploadedImageCreateOrConnectWithoutProjectInput[]
    upsert?: UploadedImageUpsertWithWhereUniqueWithoutProjectInput | UploadedImageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: UploadedImageCreateManyProjectInputEnvelope
    set?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
    disconnect?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
    delete?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
    connect?: UploadedImageWhereUniqueInput | UploadedImageWhereUniqueInput[]
    update?: UploadedImageUpdateWithWhereUniqueWithoutProjectInput | UploadedImageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: UploadedImageUpdateManyWithWhereWithoutProjectInput | UploadedImageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: UploadedImageScalarWhereInput | UploadedImageScalarWhereInput[]
  }

  export type AcademicDisciplineCreateNestedOneWithoutProjectDisciplinesInput = {
    create?: XOR<AcademicDisciplineCreateWithoutProjectDisciplinesInput, AcademicDisciplineUncheckedCreateWithoutProjectDisciplinesInput>
    connectOrCreate?: AcademicDisciplineCreateOrConnectWithoutProjectDisciplinesInput
    connect?: AcademicDisciplineWhereUniqueInput
  }

  export type ResearchProjectCreateNestedOneWithoutDisciplinesInput = {
    create?: XOR<ResearchProjectCreateWithoutDisciplinesInput, ResearchProjectUncheckedCreateWithoutDisciplinesInput>
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutDisciplinesInput
    connect?: ResearchProjectWhereUniqueInput
  }

  export type AcademicDisciplineUpdateOneRequiredWithoutProjectDisciplinesNestedInput = {
    create?: XOR<AcademicDisciplineCreateWithoutProjectDisciplinesInput, AcademicDisciplineUncheckedCreateWithoutProjectDisciplinesInput>
    connectOrCreate?: AcademicDisciplineCreateOrConnectWithoutProjectDisciplinesInput
    upsert?: AcademicDisciplineUpsertWithoutProjectDisciplinesInput
    connect?: AcademicDisciplineWhereUniqueInput
    update?: XOR<XOR<AcademicDisciplineUpdateToOneWithWhereWithoutProjectDisciplinesInput, AcademicDisciplineUpdateWithoutProjectDisciplinesInput>, AcademicDisciplineUncheckedUpdateWithoutProjectDisciplinesInput>
  }

  export type ResearchProjectUpdateOneRequiredWithoutDisciplinesNestedInput = {
    create?: XOR<ResearchProjectCreateWithoutDisciplinesInput, ResearchProjectUncheckedCreateWithoutDisciplinesInput>
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutDisciplinesInput
    upsert?: ResearchProjectUpsertWithoutDisciplinesInput
    connect?: ResearchProjectWhereUniqueInput
    update?: XOR<XOR<ResearchProjectUpdateToOneWithWhereWithoutDisciplinesInput, ResearchProjectUpdateWithoutDisciplinesInput>, ResearchProjectUncheckedUpdateWithoutDisciplinesInput>
  }

  export type OnetOccupationCreateNestedOneWithoutProjectOccupationsInput = {
    create?: XOR<OnetOccupationCreateWithoutProjectOccupationsInput, OnetOccupationUncheckedCreateWithoutProjectOccupationsInput>
    connectOrCreate?: OnetOccupationCreateOrConnectWithoutProjectOccupationsInput
    connect?: OnetOccupationWhereUniqueInput
  }

  export type ResearchProjectCreateNestedOneWithoutOccupationsInput = {
    create?: XOR<ResearchProjectCreateWithoutOccupationsInput, ResearchProjectUncheckedCreateWithoutOccupationsInput>
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutOccupationsInput
    connect?: ResearchProjectWhereUniqueInput
  }

  export type OnetOccupationUpdateOneRequiredWithoutProjectOccupationsNestedInput = {
    create?: XOR<OnetOccupationCreateWithoutProjectOccupationsInput, OnetOccupationUncheckedCreateWithoutProjectOccupationsInput>
    connectOrCreate?: OnetOccupationCreateOrConnectWithoutProjectOccupationsInput
    upsert?: OnetOccupationUpsertWithoutProjectOccupationsInput
    connect?: OnetOccupationWhereUniqueInput
    update?: XOR<XOR<OnetOccupationUpdateToOneWithWhereWithoutProjectOccupationsInput, OnetOccupationUpdateWithoutProjectOccupationsInput>, OnetOccupationUncheckedUpdateWithoutProjectOccupationsInput>
  }

  export type ResearchProjectUpdateOneRequiredWithoutOccupationsNestedInput = {
    create?: XOR<ResearchProjectCreateWithoutOccupationsInput, ResearchProjectUncheckedCreateWithoutOccupationsInput>
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutOccupationsInput
    upsert?: ResearchProjectUpsertWithoutOccupationsInput
    connect?: ResearchProjectWhereUniqueInput
    update?: XOR<XOR<ResearchProjectUpdateToOneWithWhereWithoutOccupationsInput, ResearchProjectUpdateWithoutOccupationsInput>, ResearchProjectUncheckedUpdateWithoutOccupationsInput>
  }

  export type MethodologyStepCreaterequiredResourcesInput = {
    set: string[]
  }

  export type MethodologyStepCreatedeliverablesInput = {
    set: string[]
  }

  export type MethodologyStepCreatesuccessCriteriaInput = {
    set: string[]
  }

  export type MethodologyStepCreatedependenciesInput = {
    set: string[]
  }

  export type ProjectMethodologyStepCreateNestedManyWithoutMethodologyStepInput = {
    create?: XOR<ProjectMethodologyStepCreateWithoutMethodologyStepInput, ProjectMethodologyStepUncheckedCreateWithoutMethodologyStepInput> | ProjectMethodologyStepCreateWithoutMethodologyStepInput[] | ProjectMethodologyStepUncheckedCreateWithoutMethodologyStepInput[]
    connectOrCreate?: ProjectMethodologyStepCreateOrConnectWithoutMethodologyStepInput | ProjectMethodologyStepCreateOrConnectWithoutMethodologyStepInput[]
    createMany?: ProjectMethodologyStepCreateManyMethodologyStepInputEnvelope
    connect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
  }

  export type ProjectMethodologyStepUncheckedCreateNestedManyWithoutMethodologyStepInput = {
    create?: XOR<ProjectMethodologyStepCreateWithoutMethodologyStepInput, ProjectMethodologyStepUncheckedCreateWithoutMethodologyStepInput> | ProjectMethodologyStepCreateWithoutMethodologyStepInput[] | ProjectMethodologyStepUncheckedCreateWithoutMethodologyStepInput[]
    connectOrCreate?: ProjectMethodologyStepCreateOrConnectWithoutMethodologyStepInput | ProjectMethodologyStepCreateOrConnectWithoutMethodologyStepInput[]
    createMany?: ProjectMethodologyStepCreateManyMethodologyStepInputEnvelope
    connect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MethodologyStepUpdaterequiredResourcesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MethodologyStepUpdatedeliverablesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MethodologyStepUpdatesuccessCriteriaInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MethodologyStepUpdatedependenciesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectMethodologyStepUpdateManyWithoutMethodologyStepNestedInput = {
    create?: XOR<ProjectMethodologyStepCreateWithoutMethodologyStepInput, ProjectMethodologyStepUncheckedCreateWithoutMethodologyStepInput> | ProjectMethodologyStepCreateWithoutMethodologyStepInput[] | ProjectMethodologyStepUncheckedCreateWithoutMethodologyStepInput[]
    connectOrCreate?: ProjectMethodologyStepCreateOrConnectWithoutMethodologyStepInput | ProjectMethodologyStepCreateOrConnectWithoutMethodologyStepInput[]
    upsert?: ProjectMethodologyStepUpsertWithWhereUniqueWithoutMethodologyStepInput | ProjectMethodologyStepUpsertWithWhereUniqueWithoutMethodologyStepInput[]
    createMany?: ProjectMethodologyStepCreateManyMethodologyStepInputEnvelope
    set?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    disconnect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    delete?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    connect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    update?: ProjectMethodologyStepUpdateWithWhereUniqueWithoutMethodologyStepInput | ProjectMethodologyStepUpdateWithWhereUniqueWithoutMethodologyStepInput[]
    updateMany?: ProjectMethodologyStepUpdateManyWithWhereWithoutMethodologyStepInput | ProjectMethodologyStepUpdateManyWithWhereWithoutMethodologyStepInput[]
    deleteMany?: ProjectMethodologyStepScalarWhereInput | ProjectMethodologyStepScalarWhereInput[]
  }

  export type ProjectMethodologyStepUncheckedUpdateManyWithoutMethodologyStepNestedInput = {
    create?: XOR<ProjectMethodologyStepCreateWithoutMethodologyStepInput, ProjectMethodologyStepUncheckedCreateWithoutMethodologyStepInput> | ProjectMethodologyStepCreateWithoutMethodologyStepInput[] | ProjectMethodologyStepUncheckedCreateWithoutMethodologyStepInput[]
    connectOrCreate?: ProjectMethodologyStepCreateOrConnectWithoutMethodologyStepInput | ProjectMethodologyStepCreateOrConnectWithoutMethodologyStepInput[]
    upsert?: ProjectMethodologyStepUpsertWithWhereUniqueWithoutMethodologyStepInput | ProjectMethodologyStepUpsertWithWhereUniqueWithoutMethodologyStepInput[]
    createMany?: ProjectMethodologyStepCreateManyMethodologyStepInputEnvelope
    set?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    disconnect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    delete?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    connect?: ProjectMethodologyStepWhereUniqueInput | ProjectMethodologyStepWhereUniqueInput[]
    update?: ProjectMethodologyStepUpdateWithWhereUniqueWithoutMethodologyStepInput | ProjectMethodologyStepUpdateWithWhereUniqueWithoutMethodologyStepInput[]
    updateMany?: ProjectMethodologyStepUpdateManyWithWhereWithoutMethodologyStepInput | ProjectMethodologyStepUpdateManyWithWhereWithoutMethodologyStepInput[]
    deleteMany?: ProjectMethodologyStepScalarWhereInput | ProjectMethodologyStepScalarWhereInput[]
  }

  export type ProjectMethodologyStepCreatedeliverablesUploadedInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAssignedMethodologyStepsInput = {
    create?: XOR<UserCreateWithoutAssignedMethodologyStepsInput, UserUncheckedCreateWithoutAssignedMethodologyStepsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedMethodologyStepsInput
    connect?: UserWhereUniqueInput
  }

  export type MethodologyStepCreateNestedOneWithoutProjectStepsInput = {
    create?: XOR<MethodologyStepCreateWithoutProjectStepsInput, MethodologyStepUncheckedCreateWithoutProjectStepsInput>
    connectOrCreate?: MethodologyStepCreateOrConnectWithoutProjectStepsInput
    connect?: MethodologyStepWhereUniqueInput
  }

  export type ResearchProjectCreateNestedOneWithoutMethodologyStepsInput = {
    create?: XOR<ResearchProjectCreateWithoutMethodologyStepsInput, ResearchProjectUncheckedCreateWithoutMethodologyStepsInput>
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutMethodologyStepsInput
    connect?: ResearchProjectWhereUniqueInput
  }

  export type ProjectMethodologyStepUpdatedeliverablesUploadedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutAssignedMethodologyStepsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedMethodologyStepsInput, UserUncheckedCreateWithoutAssignedMethodologyStepsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedMethodologyStepsInput
    upsert?: UserUpsertWithoutAssignedMethodologyStepsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedMethodologyStepsInput, UserUpdateWithoutAssignedMethodologyStepsInput>, UserUncheckedUpdateWithoutAssignedMethodologyStepsInput>
  }

  export type MethodologyStepUpdateOneRequiredWithoutProjectStepsNestedInput = {
    create?: XOR<MethodologyStepCreateWithoutProjectStepsInput, MethodologyStepUncheckedCreateWithoutProjectStepsInput>
    connectOrCreate?: MethodologyStepCreateOrConnectWithoutProjectStepsInput
    upsert?: MethodologyStepUpsertWithoutProjectStepsInput
    connect?: MethodologyStepWhereUniqueInput
    update?: XOR<XOR<MethodologyStepUpdateToOneWithWhereWithoutProjectStepsInput, MethodologyStepUpdateWithoutProjectStepsInput>, MethodologyStepUncheckedUpdateWithoutProjectStepsInput>
  }

  export type ResearchProjectUpdateOneRequiredWithoutMethodologyStepsNestedInput = {
    create?: XOR<ResearchProjectCreateWithoutMethodologyStepsInput, ResearchProjectUncheckedCreateWithoutMethodologyStepsInput>
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutMethodologyStepsInput
    upsert?: ResearchProjectUpsertWithoutMethodologyStepsInput
    connect?: ResearchProjectWhereUniqueInput
    update?: XOR<XOR<ResearchProjectUpdateToOneWithWhereWithoutMethodologyStepsInput, ResearchProjectUpdateWithoutMethodologyStepsInput>, ResearchProjectUncheckedUpdateWithoutMethodologyStepsInput>
  }

  export type UploadedImageCreatetagsInput = {
    set: string[]
  }

  export type ResearchAnalysisCreateNestedManyWithoutImageInput = {
    create?: XOR<ResearchAnalysisCreateWithoutImageInput, ResearchAnalysisUncheckedCreateWithoutImageInput> | ResearchAnalysisCreateWithoutImageInput[] | ResearchAnalysisUncheckedCreateWithoutImageInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutImageInput | ResearchAnalysisCreateOrConnectWithoutImageInput[]
    createMany?: ResearchAnalysisCreateManyImageInputEnvelope
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
  }

  export type ResearchProjectCreateNestedOneWithoutImagesInput = {
    create?: XOR<ResearchProjectCreateWithoutImagesInput, ResearchProjectUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutImagesInput
    connect?: ResearchProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedImagesInput = {
    create?: XOR<UserCreateWithoutUploadedImagesInput, UserUncheckedCreateWithoutUploadedImagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedImagesInput
    connect?: UserWhereUniqueInput
  }

  export type ResearchAnalysisUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<ResearchAnalysisCreateWithoutImageInput, ResearchAnalysisUncheckedCreateWithoutImageInput> | ResearchAnalysisCreateWithoutImageInput[] | ResearchAnalysisUncheckedCreateWithoutImageInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutImageInput | ResearchAnalysisCreateOrConnectWithoutImageInput[]
    createMany?: ResearchAnalysisCreateManyImageInputEnvelope
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumAnalysisStatusFieldUpdateOperationsInput = {
    set?: $Enums.AnalysisStatus
  }

  export type UploadedImageUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ResearchAnalysisUpdateManyWithoutImageNestedInput = {
    create?: XOR<ResearchAnalysisCreateWithoutImageInput, ResearchAnalysisUncheckedCreateWithoutImageInput> | ResearchAnalysisCreateWithoutImageInput[] | ResearchAnalysisUncheckedCreateWithoutImageInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutImageInput | ResearchAnalysisCreateOrConnectWithoutImageInput[]
    upsert?: ResearchAnalysisUpsertWithWhereUniqueWithoutImageInput | ResearchAnalysisUpsertWithWhereUniqueWithoutImageInput[]
    createMany?: ResearchAnalysisCreateManyImageInputEnvelope
    set?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    disconnect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    delete?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    update?: ResearchAnalysisUpdateWithWhereUniqueWithoutImageInput | ResearchAnalysisUpdateWithWhereUniqueWithoutImageInput[]
    updateMany?: ResearchAnalysisUpdateManyWithWhereWithoutImageInput | ResearchAnalysisUpdateManyWithWhereWithoutImageInput[]
    deleteMany?: ResearchAnalysisScalarWhereInput | ResearchAnalysisScalarWhereInput[]
  }

  export type ResearchProjectUpdateOneWithoutImagesNestedInput = {
    create?: XOR<ResearchProjectCreateWithoutImagesInput, ResearchProjectUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutImagesInput
    upsert?: ResearchProjectUpsertWithoutImagesInput
    disconnect?: ResearchProjectWhereInput | boolean
    delete?: ResearchProjectWhereInput | boolean
    connect?: ResearchProjectWhereUniqueInput
    update?: XOR<XOR<ResearchProjectUpdateToOneWithWhereWithoutImagesInput, ResearchProjectUpdateWithoutImagesInput>, ResearchProjectUncheckedUpdateWithoutImagesInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedImagesNestedInput = {
    create?: XOR<UserCreateWithoutUploadedImagesInput, UserUncheckedCreateWithoutUploadedImagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedImagesInput
    upsert?: UserUpsertWithoutUploadedImagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedImagesInput, UserUpdateWithoutUploadedImagesInput>, UserUncheckedUpdateWithoutUploadedImagesInput>
  }

  export type ResearchAnalysisUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<ResearchAnalysisCreateWithoutImageInput, ResearchAnalysisUncheckedCreateWithoutImageInput> | ResearchAnalysisCreateWithoutImageInput[] | ResearchAnalysisUncheckedCreateWithoutImageInput[]
    connectOrCreate?: ResearchAnalysisCreateOrConnectWithoutImageInput | ResearchAnalysisCreateOrConnectWithoutImageInput[]
    upsert?: ResearchAnalysisUpsertWithWhereUniqueWithoutImageInput | ResearchAnalysisUpsertWithWhereUniqueWithoutImageInput[]
    createMany?: ResearchAnalysisCreateManyImageInputEnvelope
    set?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    disconnect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    delete?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    connect?: ResearchAnalysisWhereUniqueInput | ResearchAnalysisWhereUniqueInput[]
    update?: ResearchAnalysisUpdateWithWhereUniqueWithoutImageInput | ResearchAnalysisUpdateWithWhereUniqueWithoutImageInput[]
    updateMany?: ResearchAnalysisUpdateManyWithWhereWithoutImageInput | ResearchAnalysisUpdateManyWithWhereWithoutImageInput[]
    deleteMany?: ResearchAnalysisScalarWhereInput | ResearchAnalysisScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAnalysesInput = {
    create?: XOR<UserCreateWithoutAnalysesInput, UserUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalysesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedAnalysesInput = {
    create?: XOR<UserCreateWithoutApprovedAnalysesInput, UserUncheckedCreateWithoutApprovedAnalysesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedAnalysesInput
    connect?: UserWhereUniqueInput
  }

  export type UploadedImageCreateNestedOneWithoutAnalysesInput = {
    create?: XOR<UploadedImageCreateWithoutAnalysesInput, UploadedImageUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: UploadedImageCreateOrConnectWithoutAnalysesInput
    connect?: UploadedImageWhereUniqueInput
  }

  export type ResearchProjectCreateNestedOneWithoutAnalysesInput = {
    create?: XOR<ResearchProjectCreateWithoutAnalysesInput, ResearchProjectUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutAnalysesInput
    connect?: ResearchProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewedAnalysesInput = {
    create?: XOR<UserCreateWithoutReviewedAnalysesInput, UserUncheckedCreateWithoutReviewedAnalysesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedAnalysesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAnalysesNestedInput = {
    create?: XOR<UserCreateWithoutAnalysesInput, UserUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalysesInput
    upsert?: UserUpsertWithoutAnalysesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnalysesInput, UserUpdateWithoutAnalysesInput>, UserUncheckedUpdateWithoutAnalysesInput>
  }

  export type UserUpdateOneWithoutApprovedAnalysesNestedInput = {
    create?: XOR<UserCreateWithoutApprovedAnalysesInput, UserUncheckedCreateWithoutApprovedAnalysesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedAnalysesInput
    upsert?: UserUpsertWithoutApprovedAnalysesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedAnalysesInput, UserUpdateWithoutApprovedAnalysesInput>, UserUncheckedUpdateWithoutApprovedAnalysesInput>
  }

  export type UploadedImageUpdateOneWithoutAnalysesNestedInput = {
    create?: XOR<UploadedImageCreateWithoutAnalysesInput, UploadedImageUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: UploadedImageCreateOrConnectWithoutAnalysesInput
    upsert?: UploadedImageUpsertWithoutAnalysesInput
    disconnect?: UploadedImageWhereInput | boolean
    delete?: UploadedImageWhereInput | boolean
    connect?: UploadedImageWhereUniqueInput
    update?: XOR<XOR<UploadedImageUpdateToOneWithWhereWithoutAnalysesInput, UploadedImageUpdateWithoutAnalysesInput>, UploadedImageUncheckedUpdateWithoutAnalysesInput>
  }

  export type ResearchProjectUpdateOneWithoutAnalysesNestedInput = {
    create?: XOR<ResearchProjectCreateWithoutAnalysesInput, ResearchProjectUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutAnalysesInput
    upsert?: ResearchProjectUpsertWithoutAnalysesInput
    disconnect?: ResearchProjectWhereInput | boolean
    delete?: ResearchProjectWhereInput | boolean
    connect?: ResearchProjectWhereUniqueInput
    update?: XOR<XOR<ResearchProjectUpdateToOneWithWhereWithoutAnalysesInput, ResearchProjectUpdateWithoutAnalysesInput>, ResearchProjectUncheckedUpdateWithoutAnalysesInput>
  }

  export type UserUpdateOneWithoutReviewedAnalysesNestedInput = {
    create?: XOR<UserCreateWithoutReviewedAnalysesInput, UserUncheckedCreateWithoutReviewedAnalysesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedAnalysesInput
    upsert?: UserUpsertWithoutReviewedAnalysesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewedAnalysesInput, UserUpdateWithoutReviewedAnalysesInput>, UserUncheckedUpdateWithoutReviewedAnalysesInput>
  }

  export type KnowledgeIntegrationCreatereferencesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutKnowledgeIntegrationsInput = {
    create?: XOR<UserCreateWithoutKnowledgeIntegrationsInput, UserUncheckedCreateWithoutKnowledgeIntegrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutKnowledgeIntegrationsInput
    connect?: UserWhereUniqueInput
  }

  export type ResearchProjectCreateNestedOneWithoutKnowledgeIntegrationsInput = {
    create?: XOR<ResearchProjectCreateWithoutKnowledgeIntegrationsInput, ResearchProjectUncheckedCreateWithoutKnowledgeIntegrationsInput>
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutKnowledgeIntegrationsInput
    connect?: ResearchProjectWhereUniqueInput
  }

  export type AcademicDisciplineCreateNestedOneWithoutKnowledgeIntegrationsSourceInput = {
    create?: XOR<AcademicDisciplineCreateWithoutKnowledgeIntegrationsSourceInput, AcademicDisciplineUncheckedCreateWithoutKnowledgeIntegrationsSourceInput>
    connectOrCreate?: AcademicDisciplineCreateOrConnectWithoutKnowledgeIntegrationsSourceInput
    connect?: AcademicDisciplineWhereUniqueInput
  }

  export type AcademicDisciplineCreateNestedOneWithoutKnowledgeIntegrationsTargetInput = {
    create?: XOR<AcademicDisciplineCreateWithoutKnowledgeIntegrationsTargetInput, AcademicDisciplineUncheckedCreateWithoutKnowledgeIntegrationsTargetInput>
    connectOrCreate?: AcademicDisciplineCreateOrConnectWithoutKnowledgeIntegrationsTargetInput
    connect?: AcademicDisciplineWhereUniqueInput
  }

  export type EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput = {
    set?: $Enums.KnowledgeIntegrationType
  }

  export type KnowledgeIntegrationUpdatereferencesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutKnowledgeIntegrationsNestedInput = {
    create?: XOR<UserCreateWithoutKnowledgeIntegrationsInput, UserUncheckedCreateWithoutKnowledgeIntegrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutKnowledgeIntegrationsInput
    upsert?: UserUpsertWithoutKnowledgeIntegrationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKnowledgeIntegrationsInput, UserUpdateWithoutKnowledgeIntegrationsInput>, UserUncheckedUpdateWithoutKnowledgeIntegrationsInput>
  }

  export type ResearchProjectUpdateOneRequiredWithoutKnowledgeIntegrationsNestedInput = {
    create?: XOR<ResearchProjectCreateWithoutKnowledgeIntegrationsInput, ResearchProjectUncheckedCreateWithoutKnowledgeIntegrationsInput>
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutKnowledgeIntegrationsInput
    upsert?: ResearchProjectUpsertWithoutKnowledgeIntegrationsInput
    connect?: ResearchProjectWhereUniqueInput
    update?: XOR<XOR<ResearchProjectUpdateToOneWithWhereWithoutKnowledgeIntegrationsInput, ResearchProjectUpdateWithoutKnowledgeIntegrationsInput>, ResearchProjectUncheckedUpdateWithoutKnowledgeIntegrationsInput>
  }

  export type AcademicDisciplineUpdateOneRequiredWithoutKnowledgeIntegrationsSourceNestedInput = {
    create?: XOR<AcademicDisciplineCreateWithoutKnowledgeIntegrationsSourceInput, AcademicDisciplineUncheckedCreateWithoutKnowledgeIntegrationsSourceInput>
    connectOrCreate?: AcademicDisciplineCreateOrConnectWithoutKnowledgeIntegrationsSourceInput
    upsert?: AcademicDisciplineUpsertWithoutKnowledgeIntegrationsSourceInput
    connect?: AcademicDisciplineWhereUniqueInput
    update?: XOR<XOR<AcademicDisciplineUpdateToOneWithWhereWithoutKnowledgeIntegrationsSourceInput, AcademicDisciplineUpdateWithoutKnowledgeIntegrationsSourceInput>, AcademicDisciplineUncheckedUpdateWithoutKnowledgeIntegrationsSourceInput>
  }

  export type AcademicDisciplineUpdateOneRequiredWithoutKnowledgeIntegrationsTargetNestedInput = {
    create?: XOR<AcademicDisciplineCreateWithoutKnowledgeIntegrationsTargetInput, AcademicDisciplineUncheckedCreateWithoutKnowledgeIntegrationsTargetInput>
    connectOrCreate?: AcademicDisciplineCreateOrConnectWithoutKnowledgeIntegrationsTargetInput
    upsert?: AcademicDisciplineUpsertWithoutKnowledgeIntegrationsTargetInput
    connect?: AcademicDisciplineWhereUniqueInput
    update?: XOR<XOR<AcademicDisciplineUpdateToOneWithWhereWithoutKnowledgeIntegrationsTargetInput, AcademicDisciplineUpdateWithoutKnowledgeIntegrationsTargetInput>, AcademicDisciplineUncheckedUpdateWithoutKnowledgeIntegrationsTargetInput>
  }

  export type ResearchProjectCreateNestedOneWithoutCollaboratorsInput = {
    create?: XOR<ResearchProjectCreateWithoutCollaboratorsInput, ResearchProjectUncheckedCreateWithoutCollaboratorsInput>
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutCollaboratorsInput
    connect?: ResearchProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectCollaborationsInput = {
    create?: XOR<UserCreateWithoutProjectCollaborationsInput, UserUncheckedCreateWithoutProjectCollaborationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectCollaborationsInput
    connect?: UserWhereUniqueInput
  }

  export type ResearchProjectUpdateOneRequiredWithoutCollaboratorsNestedInput = {
    create?: XOR<ResearchProjectCreateWithoutCollaboratorsInput, ResearchProjectUncheckedCreateWithoutCollaboratorsInput>
    connectOrCreate?: ResearchProjectCreateOrConnectWithoutCollaboratorsInput
    upsert?: ResearchProjectUpsertWithoutCollaboratorsInput
    connect?: ResearchProjectWhereUniqueInput
    update?: XOR<XOR<ResearchProjectUpdateToOneWithWhereWithoutCollaboratorsInput, ResearchProjectUpdateWithoutCollaboratorsInput>, ResearchProjectUncheckedUpdateWithoutCollaboratorsInput>
  }

  export type UserUpdateOneRequiredWithoutProjectCollaborationsNestedInput = {
    create?: XOR<UserCreateWithoutProjectCollaborationsInput, UserUncheckedCreateWithoutProjectCollaborationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectCollaborationsInput
    upsert?: UserUpsertWithoutProjectCollaborationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectCollaborationsInput, UserUpdateWithoutProjectCollaborationsInput>, UserUncheckedUpdateWithoutProjectCollaborationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumMethodologyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MethodologyType | EnumMethodologyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MethodologyType[] | ListEnumMethodologyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MethodologyType[] | ListEnumMethodologyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMethodologyTypeFilter<$PrismaModel> | $Enums.MethodologyType
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumMethodologyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MethodologyType | EnumMethodologyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MethodologyType[] | ListEnumMethodologyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MethodologyType[] | ListEnumMethodologyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMethodologyTypeWithAggregatesFilter<$PrismaModel> | $Enums.MethodologyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMethodologyTypeFilter<$PrismaModel>
    _max?: NestedEnumMethodologyTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedEnumAnalysisStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisStatus | EnumAnalysisStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisStatus[] | ListEnumAnalysisStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisStatus[] | ListEnumAnalysisStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisStatusFilter<$PrismaModel> | $Enums.AnalysisStatus
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAnalysisStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisStatus | EnumAnalysisStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisStatus[] | ListEnumAnalysisStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisStatus[] | ListEnumAnalysisStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisStatusWithAggregatesFilter<$PrismaModel> | $Enums.AnalysisStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnalysisStatusFilter<$PrismaModel>
    _max?: NestedEnumAnalysisStatusFilter<$PrismaModel>
  }

  export type NestedEnumKnowledgeIntegrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeIntegrationType | EnumKnowledgeIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeIntegrationType[] | ListEnumKnowledgeIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeIntegrationType[] | ListEnumKnowledgeIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeIntegrationTypeFilter<$PrismaModel> | $Enums.KnowledgeIntegrationType
  }

  export type NestedEnumKnowledgeIntegrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeIntegrationType | EnumKnowledgeIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeIntegrationType[] | ListEnumKnowledgeIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeIntegrationType[] | ListEnumKnowledgeIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeIntegrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.KnowledgeIntegrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKnowledgeIntegrationTypeFilter<$PrismaModel>
    _max?: NestedEnumKnowledgeIntegrationTypeFilter<$PrismaModel>
  }

  export type KnowledgeIntegrationCreateWithoutCreatedByInput = {
    id?: string
    integrationType: $Enums.KnowledgeIntegrationType
    title: string
    description?: string | null
    sourceKnowledge?: string | null
    targetApplication?: string | null
    integrationMethod?: string | null
    validationStatus?: string
    validationNotes?: string | null
    noveltyScore?: Decimal | DecimalJsLike | number | string | null
    impactPotential?: string | null
    implementationFeasibility?: string | null
    references?: KnowledgeIntegrationCreatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ResearchProjectCreateNestedOneWithoutKnowledgeIntegrationsInput
    sourceDiscipline: AcademicDisciplineCreateNestedOneWithoutKnowledgeIntegrationsSourceInput
    targetDiscipline: AcademicDisciplineCreateNestedOneWithoutKnowledgeIntegrationsTargetInput
  }

  export type KnowledgeIntegrationUncheckedCreateWithoutCreatedByInput = {
    id?: string
    projectId: string
    sourceDisciplineId: string
    targetDisciplineId: string
    integrationType: $Enums.KnowledgeIntegrationType
    title: string
    description?: string | null
    sourceKnowledge?: string | null
    targetApplication?: string | null
    integrationMethod?: string | null
    validationStatus?: string
    validationNotes?: string | null
    noveltyScore?: Decimal | DecimalJsLike | number | string | null
    impactPotential?: string | null
    implementationFeasibility?: string | null
    references?: KnowledgeIntegrationCreatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeIntegrationCreateOrConnectWithoutCreatedByInput = {
    where: KnowledgeIntegrationWhereUniqueInput
    create: XOR<KnowledgeIntegrationCreateWithoutCreatedByInput, KnowledgeIntegrationUncheckedCreateWithoutCreatedByInput>
  }

  export type KnowledgeIntegrationCreateManyCreatedByInputEnvelope = {
    data: KnowledgeIntegrationCreateManyCreatedByInput | KnowledgeIntegrationCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCollaboratorCreateWithoutUserInput = {
    id?: string
    role: string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: string | null
    joinedAt?: Date | string
    status?: string
    project: ResearchProjectCreateNestedOneWithoutCollaboratorsInput
  }

  export type ProjectCollaboratorUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    role: string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: string | null
    joinedAt?: Date | string
    status?: string
  }

  export type ProjectCollaboratorCreateOrConnectWithoutUserInput = {
    where: ProjectCollaboratorWhereUniqueInput
    create: XOR<ProjectCollaboratorCreateWithoutUserInput, ProjectCollaboratorUncheckedCreateWithoutUserInput>
  }

  export type ProjectCollaboratorCreateManyUserInputEnvelope = {
    data: ProjectCollaboratorCreateManyUserInput | ProjectCollaboratorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMethodologyStepCreateWithoutAssignedToInput = {
    id?: string
    status?: string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    notes?: string | null
    deliverablesUploaded?: ProjectMethodologyStepCreatedeliverablesUploadedInput | string[]
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    methodologyStep: MethodologyStepCreateNestedOneWithoutProjectStepsInput
    project: ResearchProjectCreateNestedOneWithoutMethodologyStepsInput
  }

  export type ProjectMethodologyStepUncheckedCreateWithoutAssignedToInput = {
    id?: string
    projectId: string
    methodologyStepId: string
    status?: string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    notes?: string | null
    deliverablesUploaded?: ProjectMethodologyStepCreatedeliverablesUploadedInput | string[]
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMethodologyStepCreateOrConnectWithoutAssignedToInput = {
    where: ProjectMethodologyStepWhereUniqueInput
    create: XOR<ProjectMethodologyStepCreateWithoutAssignedToInput, ProjectMethodologyStepUncheckedCreateWithoutAssignedToInput>
  }

  export type ProjectMethodologyStepCreateManyAssignedToInputEnvelope = {
    data: ProjectMethodologyStepCreateManyAssignedToInput | ProjectMethodologyStepCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type ResearchAnalysisCreateWithoutAnalystInput = {
    id?: string
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: UserCreateNestedOneWithoutApprovedAnalysesInput
    image?: UploadedImageCreateNestedOneWithoutAnalysesInput
    project?: ResearchProjectCreateNestedOneWithoutAnalysesInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedAnalysesInput
  }

  export type ResearchAnalysisUncheckedCreateWithoutAnalystInput = {
    id?: string
    projectId?: string | null
    imageId?: string | null
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchAnalysisCreateOrConnectWithoutAnalystInput = {
    where: ResearchAnalysisWhereUniqueInput
    create: XOR<ResearchAnalysisCreateWithoutAnalystInput, ResearchAnalysisUncheckedCreateWithoutAnalystInput>
  }

  export type ResearchAnalysisCreateManyAnalystInputEnvelope = {
    data: ResearchAnalysisCreateManyAnalystInput | ResearchAnalysisCreateManyAnalystInput[]
    skipDuplicates?: boolean
  }

  export type ResearchAnalysisCreateWithoutApprovedByInput = {
    id?: string
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    analyst: UserCreateNestedOneWithoutAnalysesInput
    image?: UploadedImageCreateNestedOneWithoutAnalysesInput
    project?: ResearchProjectCreateNestedOneWithoutAnalysesInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedAnalysesInput
  }

  export type ResearchAnalysisUncheckedCreateWithoutApprovedByInput = {
    id?: string
    projectId?: string | null
    imageId?: string | null
    analystId: string
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchAnalysisCreateOrConnectWithoutApprovedByInput = {
    where: ResearchAnalysisWhereUniqueInput
    create: XOR<ResearchAnalysisCreateWithoutApprovedByInput, ResearchAnalysisUncheckedCreateWithoutApprovedByInput>
  }

  export type ResearchAnalysisCreateManyApprovedByInputEnvelope = {
    data: ResearchAnalysisCreateManyApprovedByInput | ResearchAnalysisCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type ResearchAnalysisCreateWithoutReviewedByInput = {
    id?: string
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    analyst: UserCreateNestedOneWithoutAnalysesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedAnalysesInput
    image?: UploadedImageCreateNestedOneWithoutAnalysesInput
    project?: ResearchProjectCreateNestedOneWithoutAnalysesInput
  }

  export type ResearchAnalysisUncheckedCreateWithoutReviewedByInput = {
    id?: string
    projectId?: string | null
    imageId?: string | null
    analystId: string
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchAnalysisCreateOrConnectWithoutReviewedByInput = {
    where: ResearchAnalysisWhereUniqueInput
    create: XOR<ResearchAnalysisCreateWithoutReviewedByInput, ResearchAnalysisUncheckedCreateWithoutReviewedByInput>
  }

  export type ResearchAnalysisCreateManyReviewedByInputEnvelope = {
    data: ResearchAnalysisCreateManyReviewedByInput | ResearchAnalysisCreateManyReviewedByInput[]
    skipDuplicates?: boolean
  }

  export type ResearchProjectCreateWithoutPrincipalInvestigatorInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeIntegrations?: KnowledgeIntegrationCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    disciplines?: ProjectDisciplineCreateNestedManyWithoutProjectInput
    methodologySteps?: ProjectMethodologyStepCreateNestedManyWithoutProjectInput
    occupations?: ProjectOccupationCreateNestedManyWithoutProjectInput
    analyses?: ResearchAnalysisCreateNestedManyWithoutProjectInput
    images?: UploadedImageCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectUncheckedCreateWithoutPrincipalInvestigatorInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    disciplines?: ProjectDisciplineUncheckedCreateNestedManyWithoutProjectInput
    methodologySteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutProjectInput
    occupations?: ProjectOccupationUncheckedCreateNestedManyWithoutProjectInput
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutProjectInput
    images?: UploadedImageUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectCreateOrConnectWithoutPrincipalInvestigatorInput = {
    where: ResearchProjectWhereUniqueInput
    create: XOR<ResearchProjectCreateWithoutPrincipalInvestigatorInput, ResearchProjectUncheckedCreateWithoutPrincipalInvestigatorInput>
  }

  export type ResearchProjectCreateManyPrincipalInvestigatorInputEnvelope = {
    data: ResearchProjectCreateManyPrincipalInvestigatorInput | ResearchProjectCreateManyPrincipalInvestigatorInput[]
    skipDuplicates?: boolean
  }

  export type UploadedImageCreateWithoutUploadedByInput = {
    id?: string
    fileName: string
    originalFileName?: string | null
    filePath: string
    fileSize?: bigint | number | null
    mimeType?: string | null
    imageType?: string | null
    imageConfidence?: Decimal | DecimalJsLike | number | string | null
    width?: number | null
    height?: number | null
    colorDepth?: number | null
    hasMetadata?: boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: $Enums.AnalysisStatus
    tags?: UploadedImageCreatetagsInput | string[]
    description?: string | null
    consentObtained?: boolean
    dataClassification?: string
    anonymized?: boolean
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: ResearchAnalysisCreateNestedManyWithoutImageInput
    project?: ResearchProjectCreateNestedOneWithoutImagesInput
  }

  export type UploadedImageUncheckedCreateWithoutUploadedByInput = {
    id?: string
    projectId?: string | null
    fileName: string
    originalFileName?: string | null
    filePath: string
    fileSize?: bigint | number | null
    mimeType?: string | null
    imageType?: string | null
    imageConfidence?: Decimal | DecimalJsLike | number | string | null
    width?: number | null
    height?: number | null
    colorDepth?: number | null
    hasMetadata?: boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: $Enums.AnalysisStatus
    tags?: UploadedImageCreatetagsInput | string[]
    description?: string | null
    consentObtained?: boolean
    dataClassification?: string
    anonymized?: boolean
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutImageInput
  }

  export type UploadedImageCreateOrConnectWithoutUploadedByInput = {
    where: UploadedImageWhereUniqueInput
    create: XOR<UploadedImageCreateWithoutUploadedByInput, UploadedImageUncheckedCreateWithoutUploadedByInput>
  }

  export type UploadedImageCreateManyUploadedByInputEnvelope = {
    data: UploadedImageCreateManyUploadedByInput | UploadedImageCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeIntegrationUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: KnowledgeIntegrationWhereUniqueInput
    update: XOR<KnowledgeIntegrationUpdateWithoutCreatedByInput, KnowledgeIntegrationUncheckedUpdateWithoutCreatedByInput>
    create: XOR<KnowledgeIntegrationCreateWithoutCreatedByInput, KnowledgeIntegrationUncheckedCreateWithoutCreatedByInput>
  }

  export type KnowledgeIntegrationUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: KnowledgeIntegrationWhereUniqueInput
    data: XOR<KnowledgeIntegrationUpdateWithoutCreatedByInput, KnowledgeIntegrationUncheckedUpdateWithoutCreatedByInput>
  }

  export type KnowledgeIntegrationUpdateManyWithWhereWithoutCreatedByInput = {
    where: KnowledgeIntegrationScalarWhereInput
    data: XOR<KnowledgeIntegrationUpdateManyMutationInput, KnowledgeIntegrationUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type KnowledgeIntegrationScalarWhereInput = {
    AND?: KnowledgeIntegrationScalarWhereInput | KnowledgeIntegrationScalarWhereInput[]
    OR?: KnowledgeIntegrationScalarWhereInput[]
    NOT?: KnowledgeIntegrationScalarWhereInput | KnowledgeIntegrationScalarWhereInput[]
    id?: StringFilter<"KnowledgeIntegration"> | string
    projectId?: StringFilter<"KnowledgeIntegration"> | string
    sourceDisciplineId?: StringFilter<"KnowledgeIntegration"> | string
    targetDisciplineId?: StringFilter<"KnowledgeIntegration"> | string
    integrationType?: EnumKnowledgeIntegrationTypeFilter<"KnowledgeIntegration"> | $Enums.KnowledgeIntegrationType
    title?: StringFilter<"KnowledgeIntegration"> | string
    description?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    sourceKnowledge?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    targetApplication?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    integrationMethod?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    validationStatus?: StringFilter<"KnowledgeIntegration"> | string
    validationNotes?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    noveltyScore?: DecimalNullableFilter<"KnowledgeIntegration"> | Decimal | DecimalJsLike | number | string | null
    impactPotential?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    implementationFeasibility?: StringNullableFilter<"KnowledgeIntegration"> | string | null
    references?: StringNullableListFilter<"KnowledgeIntegration">
    supportingEvidence?: JsonNullableFilter<"KnowledgeIntegration">
    createdById?: StringFilter<"KnowledgeIntegration"> | string
    createdAt?: DateTimeFilter<"KnowledgeIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeIntegration"> | Date | string
  }

  export type ProjectCollaboratorUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectCollaboratorWhereUniqueInput
    update: XOR<ProjectCollaboratorUpdateWithoutUserInput, ProjectCollaboratorUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectCollaboratorCreateWithoutUserInput, ProjectCollaboratorUncheckedCreateWithoutUserInput>
  }

  export type ProjectCollaboratorUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectCollaboratorWhereUniqueInput
    data: XOR<ProjectCollaboratorUpdateWithoutUserInput, ProjectCollaboratorUncheckedUpdateWithoutUserInput>
  }

  export type ProjectCollaboratorUpdateManyWithWhereWithoutUserInput = {
    where: ProjectCollaboratorScalarWhereInput
    data: XOR<ProjectCollaboratorUpdateManyMutationInput, ProjectCollaboratorUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectCollaboratorScalarWhereInput = {
    AND?: ProjectCollaboratorScalarWhereInput | ProjectCollaboratorScalarWhereInput[]
    OR?: ProjectCollaboratorScalarWhereInput[]
    NOT?: ProjectCollaboratorScalarWhereInput | ProjectCollaboratorScalarWhereInput[]
    id?: StringFilter<"ProjectCollaborator"> | string
    projectId?: StringFilter<"ProjectCollaborator"> | string
    userId?: StringFilter<"ProjectCollaborator"> | string
    role?: StringFilter<"ProjectCollaborator"> | string
    permissions?: JsonFilter<"ProjectCollaborator">
    contributionDescription?: StringNullableFilter<"ProjectCollaborator"> | string | null
    joinedAt?: DateTimeFilter<"ProjectCollaborator"> | Date | string
    status?: StringFilter<"ProjectCollaborator"> | string
  }

  export type ProjectMethodologyStepUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: ProjectMethodologyStepWhereUniqueInput
    update: XOR<ProjectMethodologyStepUpdateWithoutAssignedToInput, ProjectMethodologyStepUncheckedUpdateWithoutAssignedToInput>
    create: XOR<ProjectMethodologyStepCreateWithoutAssignedToInput, ProjectMethodologyStepUncheckedCreateWithoutAssignedToInput>
  }

  export type ProjectMethodologyStepUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: ProjectMethodologyStepWhereUniqueInput
    data: XOR<ProjectMethodologyStepUpdateWithoutAssignedToInput, ProjectMethodologyStepUncheckedUpdateWithoutAssignedToInput>
  }

  export type ProjectMethodologyStepUpdateManyWithWhereWithoutAssignedToInput = {
    where: ProjectMethodologyStepScalarWhereInput
    data: XOR<ProjectMethodologyStepUpdateManyMutationInput, ProjectMethodologyStepUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type ProjectMethodologyStepScalarWhereInput = {
    AND?: ProjectMethodologyStepScalarWhereInput | ProjectMethodologyStepScalarWhereInput[]
    OR?: ProjectMethodologyStepScalarWhereInput[]
    NOT?: ProjectMethodologyStepScalarWhereInput | ProjectMethodologyStepScalarWhereInput[]
    id?: StringFilter<"ProjectMethodologyStep"> | string
    projectId?: StringFilter<"ProjectMethodologyStep"> | string
    methodologyStepId?: StringFilter<"ProjectMethodologyStep"> | string
    assignedToId?: StringNullableFilter<"ProjectMethodologyStep"> | string | null
    status?: StringFilter<"ProjectMethodologyStep"> | string
    actualStartDate?: DateTimeNullableFilter<"ProjectMethodologyStep"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"ProjectMethodologyStep"> | Date | string | null
    notes?: StringNullableFilter<"ProjectMethodologyStep"> | string | null
    deliverablesUploaded?: StringNullableListFilter<"ProjectMethodologyStep">
    completionPercentage?: IntFilter<"ProjectMethodologyStep"> | number
    createdAt?: DateTimeFilter<"ProjectMethodologyStep"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMethodologyStep"> | Date | string
  }

  export type ResearchAnalysisUpsertWithWhereUniqueWithoutAnalystInput = {
    where: ResearchAnalysisWhereUniqueInput
    update: XOR<ResearchAnalysisUpdateWithoutAnalystInput, ResearchAnalysisUncheckedUpdateWithoutAnalystInput>
    create: XOR<ResearchAnalysisCreateWithoutAnalystInput, ResearchAnalysisUncheckedCreateWithoutAnalystInput>
  }

  export type ResearchAnalysisUpdateWithWhereUniqueWithoutAnalystInput = {
    where: ResearchAnalysisWhereUniqueInput
    data: XOR<ResearchAnalysisUpdateWithoutAnalystInput, ResearchAnalysisUncheckedUpdateWithoutAnalystInput>
  }

  export type ResearchAnalysisUpdateManyWithWhereWithoutAnalystInput = {
    where: ResearchAnalysisScalarWhereInput
    data: XOR<ResearchAnalysisUpdateManyMutationInput, ResearchAnalysisUncheckedUpdateManyWithoutAnalystInput>
  }

  export type ResearchAnalysisScalarWhereInput = {
    AND?: ResearchAnalysisScalarWhereInput | ResearchAnalysisScalarWhereInput[]
    OR?: ResearchAnalysisScalarWhereInput[]
    NOT?: ResearchAnalysisScalarWhereInput | ResearchAnalysisScalarWhereInput[]
    id?: StringFilter<"ResearchAnalysis"> | string
    projectId?: StringNullableFilter<"ResearchAnalysis"> | string | null
    imageId?: StringNullableFilter<"ResearchAnalysis"> | string | null
    analystId?: StringFilter<"ResearchAnalysis"> | string
    analysisType?: StringFilter<"ResearchAnalysis"> | string
    status?: EnumAnalysisStatusFilter<"ResearchAnalysis"> | $Enums.AnalysisStatus
    confidenceScore?: DecimalNullableFilter<"ResearchAnalysis"> | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: IntNullableFilter<"ResearchAnalysis"> | number | null
    algorithmVersion?: StringNullableFilter<"ResearchAnalysis"> | string | null
    modelUsed?: StringNullableFilter<"ResearchAnalysis"> | string | null
    findings?: JsonNullableFilter<"ResearchAnalysis">
    recommendations?: JsonNullableFilter<"ResearchAnalysis">
    differentialDiagnosis?: JsonNullableFilter<"ResearchAnalysis">
    severityAssessment?: JsonNullableFilter<"ResearchAnalysis">
    regionsOfInterest?: JsonNullableFilter<"ResearchAnalysis">
    qualityMetrics?: JsonNullableFilter<"ResearchAnalysis">
    errorMessage?: StringNullableFilter<"ResearchAnalysis"> | string | null
    reviewRequired?: BoolFilter<"ResearchAnalysis"> | boolean
    reviewedById?: StringNullableFilter<"ResearchAnalysis"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ResearchAnalysis"> | Date | string | null
    reviewNotes?: StringNullableFilter<"ResearchAnalysis"> | string | null
    approvedById?: StringNullableFilter<"ResearchAnalysis"> | string | null
    approvedAt?: DateTimeNullableFilter<"ResearchAnalysis"> | Date | string | null
    metadata?: JsonFilter<"ResearchAnalysis">
    createdAt?: DateTimeFilter<"ResearchAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchAnalysis"> | Date | string
  }

  export type ResearchAnalysisUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: ResearchAnalysisWhereUniqueInput
    update: XOR<ResearchAnalysisUpdateWithoutApprovedByInput, ResearchAnalysisUncheckedUpdateWithoutApprovedByInput>
    create: XOR<ResearchAnalysisCreateWithoutApprovedByInput, ResearchAnalysisUncheckedCreateWithoutApprovedByInput>
  }

  export type ResearchAnalysisUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: ResearchAnalysisWhereUniqueInput
    data: XOR<ResearchAnalysisUpdateWithoutApprovedByInput, ResearchAnalysisUncheckedUpdateWithoutApprovedByInput>
  }

  export type ResearchAnalysisUpdateManyWithWhereWithoutApprovedByInput = {
    where: ResearchAnalysisScalarWhereInput
    data: XOR<ResearchAnalysisUpdateManyMutationInput, ResearchAnalysisUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type ResearchAnalysisUpsertWithWhereUniqueWithoutReviewedByInput = {
    where: ResearchAnalysisWhereUniqueInput
    update: XOR<ResearchAnalysisUpdateWithoutReviewedByInput, ResearchAnalysisUncheckedUpdateWithoutReviewedByInput>
    create: XOR<ResearchAnalysisCreateWithoutReviewedByInput, ResearchAnalysisUncheckedCreateWithoutReviewedByInput>
  }

  export type ResearchAnalysisUpdateWithWhereUniqueWithoutReviewedByInput = {
    where: ResearchAnalysisWhereUniqueInput
    data: XOR<ResearchAnalysisUpdateWithoutReviewedByInput, ResearchAnalysisUncheckedUpdateWithoutReviewedByInput>
  }

  export type ResearchAnalysisUpdateManyWithWhereWithoutReviewedByInput = {
    where: ResearchAnalysisScalarWhereInput
    data: XOR<ResearchAnalysisUpdateManyMutationInput, ResearchAnalysisUncheckedUpdateManyWithoutReviewedByInput>
  }

  export type ResearchProjectUpsertWithWhereUniqueWithoutPrincipalInvestigatorInput = {
    where: ResearchProjectWhereUniqueInput
    update: XOR<ResearchProjectUpdateWithoutPrincipalInvestigatorInput, ResearchProjectUncheckedUpdateWithoutPrincipalInvestigatorInput>
    create: XOR<ResearchProjectCreateWithoutPrincipalInvestigatorInput, ResearchProjectUncheckedCreateWithoutPrincipalInvestigatorInput>
  }

  export type ResearchProjectUpdateWithWhereUniqueWithoutPrincipalInvestigatorInput = {
    where: ResearchProjectWhereUniqueInput
    data: XOR<ResearchProjectUpdateWithoutPrincipalInvestigatorInput, ResearchProjectUncheckedUpdateWithoutPrincipalInvestigatorInput>
  }

  export type ResearchProjectUpdateManyWithWhereWithoutPrincipalInvestigatorInput = {
    where: ResearchProjectScalarWhereInput
    data: XOR<ResearchProjectUpdateManyMutationInput, ResearchProjectUncheckedUpdateManyWithoutPrincipalInvestigatorInput>
  }

  export type ResearchProjectScalarWhereInput = {
    AND?: ResearchProjectScalarWhereInput | ResearchProjectScalarWhereInput[]
    OR?: ResearchProjectScalarWhereInput[]
    NOT?: ResearchProjectScalarWhereInput | ResearchProjectScalarWhereInput[]
    id?: StringFilter<"ResearchProject"> | string
    title?: StringFilter<"ResearchProject"> | string
    description?: StringNullableFilter<"ResearchProject"> | string | null
    status?: EnumProjectStatusFilter<"ResearchProject"> | $Enums.ProjectStatus
    principalInvestigatorId?: StringFilter<"ResearchProject"> | string
    startDate?: DateTimeNullableFilter<"ResearchProject"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ResearchProject"> | Date | string | null
    fundingSource?: StringNullableFilter<"ResearchProject"> | string | null
    fundingAmount?: DecimalNullableFilter<"ResearchProject"> | Decimal | DecimalJsLike | number | string | null
    institutions?: StringNullableListFilter<"ResearchProject">
    methodologyType?: EnumMethodologyTypeFilter<"ResearchProject"> | $Enums.MethodologyType
    researchQuestions?: StringNullableListFilter<"ResearchProject">
    objectives?: StringNullableListFilter<"ResearchProject">
    hypotheses?: StringNullableListFilter<"ResearchProject">
    ethicalApprovalRequired?: BoolFilter<"ResearchProject"> | boolean
    ethicalApprovalStatus?: StringNullableFilter<"ResearchProject"> | string | null
    dataClassification?: StringFilter<"ResearchProject"> | string
    collaborationLevel?: StringFilter<"ResearchProject"> | string
    isPublic?: BoolFilter<"ResearchProject"> | boolean
    tags?: StringNullableListFilter<"ResearchProject">
    metadata?: JsonFilter<"ResearchProject">
    createdAt?: DateTimeFilter<"ResearchProject"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchProject"> | Date | string
  }

  export type UploadedImageUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: UploadedImageWhereUniqueInput
    update: XOR<UploadedImageUpdateWithoutUploadedByInput, UploadedImageUncheckedUpdateWithoutUploadedByInput>
    create: XOR<UploadedImageCreateWithoutUploadedByInput, UploadedImageUncheckedCreateWithoutUploadedByInput>
  }

  export type UploadedImageUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: UploadedImageWhereUniqueInput
    data: XOR<UploadedImageUpdateWithoutUploadedByInput, UploadedImageUncheckedUpdateWithoutUploadedByInput>
  }

  export type UploadedImageUpdateManyWithWhereWithoutUploadedByInput = {
    where: UploadedImageScalarWhereInput
    data: XOR<UploadedImageUpdateManyMutationInput, UploadedImageUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type UploadedImageScalarWhereInput = {
    AND?: UploadedImageScalarWhereInput | UploadedImageScalarWhereInput[]
    OR?: UploadedImageScalarWhereInput[]
    NOT?: UploadedImageScalarWhereInput | UploadedImageScalarWhereInput[]
    id?: StringFilter<"UploadedImage"> | string
    projectId?: StringNullableFilter<"UploadedImage"> | string | null
    uploadedById?: StringFilter<"UploadedImage"> | string
    fileName?: StringFilter<"UploadedImage"> | string
    originalFileName?: StringNullableFilter<"UploadedImage"> | string | null
    filePath?: StringFilter<"UploadedImage"> | string
    fileSize?: BigIntNullableFilter<"UploadedImage"> | bigint | number | null
    mimeType?: StringNullableFilter<"UploadedImage"> | string | null
    imageType?: StringNullableFilter<"UploadedImage"> | string | null
    imageConfidence?: DecimalNullableFilter<"UploadedImage"> | Decimal | DecimalJsLike | number | string | null
    width?: IntNullableFilter<"UploadedImage"> | number | null
    height?: IntNullableFilter<"UploadedImage"> | number | null
    colorDepth?: IntNullableFilter<"UploadedImage"> | number | null
    hasMetadata?: BoolFilter<"UploadedImage"> | boolean
    dicomMetadata?: JsonNullableFilter<"UploadedImage">
    analysisStatus?: EnumAnalysisStatusFilter<"UploadedImage"> | $Enums.AnalysisStatus
    tags?: StringNullableListFilter<"UploadedImage">
    description?: StringNullableFilter<"UploadedImage"> | string | null
    consentObtained?: BoolFilter<"UploadedImage"> | boolean
    dataClassification?: StringFilter<"UploadedImage"> | string
    anonymized?: BoolFilter<"UploadedImage"> | boolean
    processingStartedAt?: DateTimeNullableFilter<"UploadedImage"> | Date | string | null
    processingCompletedAt?: DateTimeNullableFilter<"UploadedImage"> | Date | string | null
    createdAt?: DateTimeFilter<"UploadedImage"> | Date | string
    updatedAt?: DateTimeFilter<"UploadedImage"> | Date | string
  }

  export type AcademicDisciplineCreateWithoutChildDisciplinesInput = {
    id?: string
    code: string
    name: string
    level?: number
    description?: string | null
    keywords?: AcademicDisciplineCreatekeywordsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    parentDiscipline?: AcademicDisciplineCreateNestedOneWithoutChildDisciplinesInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationCreateNestedManyWithoutSourceDisciplineInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationCreateNestedManyWithoutTargetDisciplineInput
    projectDisciplines?: ProjectDisciplineCreateNestedManyWithoutDisciplineInput
  }

  export type AcademicDisciplineUncheckedCreateWithoutChildDisciplinesInput = {
    id?: string
    code: string
    name: string
    parentDisciplineId?: string | null
    level?: number
    description?: string | null
    keywords?: AcademicDisciplineCreatekeywordsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    knowledgeIntegrationsSource?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutSourceDisciplineInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutTargetDisciplineInput
    projectDisciplines?: ProjectDisciplineUncheckedCreateNestedManyWithoutDisciplineInput
  }

  export type AcademicDisciplineCreateOrConnectWithoutChildDisciplinesInput = {
    where: AcademicDisciplineWhereUniqueInput
    create: XOR<AcademicDisciplineCreateWithoutChildDisciplinesInput, AcademicDisciplineUncheckedCreateWithoutChildDisciplinesInput>
  }

  export type AcademicDisciplineCreateWithoutParentDisciplineInput = {
    id?: string
    code: string
    name: string
    level?: number
    description?: string | null
    keywords?: AcademicDisciplineCreatekeywordsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    childDisciplines?: AcademicDisciplineCreateNestedManyWithoutParentDisciplineInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationCreateNestedManyWithoutSourceDisciplineInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationCreateNestedManyWithoutTargetDisciplineInput
    projectDisciplines?: ProjectDisciplineCreateNestedManyWithoutDisciplineInput
  }

  export type AcademicDisciplineUncheckedCreateWithoutParentDisciplineInput = {
    id?: string
    code: string
    name: string
    level?: number
    description?: string | null
    keywords?: AcademicDisciplineCreatekeywordsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    childDisciplines?: AcademicDisciplineUncheckedCreateNestedManyWithoutParentDisciplineInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutSourceDisciplineInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutTargetDisciplineInput
    projectDisciplines?: ProjectDisciplineUncheckedCreateNestedManyWithoutDisciplineInput
  }

  export type AcademicDisciplineCreateOrConnectWithoutParentDisciplineInput = {
    where: AcademicDisciplineWhereUniqueInput
    create: XOR<AcademicDisciplineCreateWithoutParentDisciplineInput, AcademicDisciplineUncheckedCreateWithoutParentDisciplineInput>
  }

  export type AcademicDisciplineCreateManyParentDisciplineInputEnvelope = {
    data: AcademicDisciplineCreateManyParentDisciplineInput | AcademicDisciplineCreateManyParentDisciplineInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeIntegrationCreateWithoutSourceDisciplineInput = {
    id?: string
    integrationType: $Enums.KnowledgeIntegrationType
    title: string
    description?: string | null
    sourceKnowledge?: string | null
    targetApplication?: string | null
    integrationMethod?: string | null
    validationStatus?: string
    validationNotes?: string | null
    noveltyScore?: Decimal | DecimalJsLike | number | string | null
    impactPotential?: string | null
    implementationFeasibility?: string | null
    references?: KnowledgeIntegrationCreatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutKnowledgeIntegrationsInput
    project: ResearchProjectCreateNestedOneWithoutKnowledgeIntegrationsInput
    targetDiscipline: AcademicDisciplineCreateNestedOneWithoutKnowledgeIntegrationsTargetInput
  }

  export type KnowledgeIntegrationUncheckedCreateWithoutSourceDisciplineInput = {
    id?: string
    projectId: string
    targetDisciplineId: string
    integrationType: $Enums.KnowledgeIntegrationType
    title: string
    description?: string | null
    sourceKnowledge?: string | null
    targetApplication?: string | null
    integrationMethod?: string | null
    validationStatus?: string
    validationNotes?: string | null
    noveltyScore?: Decimal | DecimalJsLike | number | string | null
    impactPotential?: string | null
    implementationFeasibility?: string | null
    references?: KnowledgeIntegrationCreatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeIntegrationCreateOrConnectWithoutSourceDisciplineInput = {
    where: KnowledgeIntegrationWhereUniqueInput
    create: XOR<KnowledgeIntegrationCreateWithoutSourceDisciplineInput, KnowledgeIntegrationUncheckedCreateWithoutSourceDisciplineInput>
  }

  export type KnowledgeIntegrationCreateManySourceDisciplineInputEnvelope = {
    data: KnowledgeIntegrationCreateManySourceDisciplineInput | KnowledgeIntegrationCreateManySourceDisciplineInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeIntegrationCreateWithoutTargetDisciplineInput = {
    id?: string
    integrationType: $Enums.KnowledgeIntegrationType
    title: string
    description?: string | null
    sourceKnowledge?: string | null
    targetApplication?: string | null
    integrationMethod?: string | null
    validationStatus?: string
    validationNotes?: string | null
    noveltyScore?: Decimal | DecimalJsLike | number | string | null
    impactPotential?: string | null
    implementationFeasibility?: string | null
    references?: KnowledgeIntegrationCreatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutKnowledgeIntegrationsInput
    project: ResearchProjectCreateNestedOneWithoutKnowledgeIntegrationsInput
    sourceDiscipline: AcademicDisciplineCreateNestedOneWithoutKnowledgeIntegrationsSourceInput
  }

  export type KnowledgeIntegrationUncheckedCreateWithoutTargetDisciplineInput = {
    id?: string
    projectId: string
    sourceDisciplineId: string
    integrationType: $Enums.KnowledgeIntegrationType
    title: string
    description?: string | null
    sourceKnowledge?: string | null
    targetApplication?: string | null
    integrationMethod?: string | null
    validationStatus?: string
    validationNotes?: string | null
    noveltyScore?: Decimal | DecimalJsLike | number | string | null
    impactPotential?: string | null
    implementationFeasibility?: string | null
    references?: KnowledgeIntegrationCreatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeIntegrationCreateOrConnectWithoutTargetDisciplineInput = {
    where: KnowledgeIntegrationWhereUniqueInput
    create: XOR<KnowledgeIntegrationCreateWithoutTargetDisciplineInput, KnowledgeIntegrationUncheckedCreateWithoutTargetDisciplineInput>
  }

  export type KnowledgeIntegrationCreateManyTargetDisciplineInputEnvelope = {
    data: KnowledgeIntegrationCreateManyTargetDisciplineInput | KnowledgeIntegrationCreateManyTargetDisciplineInput[]
    skipDuplicates?: boolean
  }

  export type ProjectDisciplineCreateWithoutDisciplineInput = {
    id?: string
    primaryDiscipline?: boolean
    contributionLevel?: string
    createdAt?: Date | string
    project: ResearchProjectCreateNestedOneWithoutDisciplinesInput
  }

  export type ProjectDisciplineUncheckedCreateWithoutDisciplineInput = {
    id?: string
    projectId: string
    primaryDiscipline?: boolean
    contributionLevel?: string
    createdAt?: Date | string
  }

  export type ProjectDisciplineCreateOrConnectWithoutDisciplineInput = {
    where: ProjectDisciplineWhereUniqueInput
    create: XOR<ProjectDisciplineCreateWithoutDisciplineInput, ProjectDisciplineUncheckedCreateWithoutDisciplineInput>
  }

  export type ProjectDisciplineCreateManyDisciplineInputEnvelope = {
    data: ProjectDisciplineCreateManyDisciplineInput | ProjectDisciplineCreateManyDisciplineInput[]
    skipDuplicates?: boolean
  }

  export type AcademicDisciplineUpsertWithoutChildDisciplinesInput = {
    update: XOR<AcademicDisciplineUpdateWithoutChildDisciplinesInput, AcademicDisciplineUncheckedUpdateWithoutChildDisciplinesInput>
    create: XOR<AcademicDisciplineCreateWithoutChildDisciplinesInput, AcademicDisciplineUncheckedCreateWithoutChildDisciplinesInput>
    where?: AcademicDisciplineWhereInput
  }

  export type AcademicDisciplineUpdateToOneWithWhereWithoutChildDisciplinesInput = {
    where?: AcademicDisciplineWhereInput
    data: XOR<AcademicDisciplineUpdateWithoutChildDisciplinesInput, AcademicDisciplineUncheckedUpdateWithoutChildDisciplinesInput>
  }

  export type AcademicDisciplineUpdateWithoutChildDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: AcademicDisciplineUpdatekeywordsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentDiscipline?: AcademicDisciplineUpdateOneWithoutChildDisciplinesNestedInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationUpdateManyWithoutSourceDisciplineNestedInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationUpdateManyWithoutTargetDisciplineNestedInput
    projectDisciplines?: ProjectDisciplineUpdateManyWithoutDisciplineNestedInput
  }

  export type AcademicDisciplineUncheckedUpdateWithoutChildDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentDisciplineId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: AcademicDisciplineUpdatekeywordsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrationsSource?: KnowledgeIntegrationUncheckedUpdateManyWithoutSourceDisciplineNestedInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationUncheckedUpdateManyWithoutTargetDisciplineNestedInput
    projectDisciplines?: ProjectDisciplineUncheckedUpdateManyWithoutDisciplineNestedInput
  }

  export type AcademicDisciplineUpsertWithWhereUniqueWithoutParentDisciplineInput = {
    where: AcademicDisciplineWhereUniqueInput
    update: XOR<AcademicDisciplineUpdateWithoutParentDisciplineInput, AcademicDisciplineUncheckedUpdateWithoutParentDisciplineInput>
    create: XOR<AcademicDisciplineCreateWithoutParentDisciplineInput, AcademicDisciplineUncheckedCreateWithoutParentDisciplineInput>
  }

  export type AcademicDisciplineUpdateWithWhereUniqueWithoutParentDisciplineInput = {
    where: AcademicDisciplineWhereUniqueInput
    data: XOR<AcademicDisciplineUpdateWithoutParentDisciplineInput, AcademicDisciplineUncheckedUpdateWithoutParentDisciplineInput>
  }

  export type AcademicDisciplineUpdateManyWithWhereWithoutParentDisciplineInput = {
    where: AcademicDisciplineScalarWhereInput
    data: XOR<AcademicDisciplineUpdateManyMutationInput, AcademicDisciplineUncheckedUpdateManyWithoutParentDisciplineInput>
  }

  export type AcademicDisciplineScalarWhereInput = {
    AND?: AcademicDisciplineScalarWhereInput | AcademicDisciplineScalarWhereInput[]
    OR?: AcademicDisciplineScalarWhereInput[]
    NOT?: AcademicDisciplineScalarWhereInput | AcademicDisciplineScalarWhereInput[]
    id?: StringFilter<"AcademicDiscipline"> | string
    code?: StringFilter<"AcademicDiscipline"> | string
    name?: StringFilter<"AcademicDiscipline"> | string
    parentDisciplineId?: StringNullableFilter<"AcademicDiscipline"> | string | null
    level?: IntFilter<"AcademicDiscipline"> | number
    description?: StringNullableFilter<"AcademicDiscipline"> | string | null
    keywords?: StringNullableListFilter<"AcademicDiscipline">
    isActive?: BoolFilter<"AcademicDiscipline"> | boolean
    createdAt?: DateTimeFilter<"AcademicDiscipline"> | Date | string
  }

  export type KnowledgeIntegrationUpsertWithWhereUniqueWithoutSourceDisciplineInput = {
    where: KnowledgeIntegrationWhereUniqueInput
    update: XOR<KnowledgeIntegrationUpdateWithoutSourceDisciplineInput, KnowledgeIntegrationUncheckedUpdateWithoutSourceDisciplineInput>
    create: XOR<KnowledgeIntegrationCreateWithoutSourceDisciplineInput, KnowledgeIntegrationUncheckedCreateWithoutSourceDisciplineInput>
  }

  export type KnowledgeIntegrationUpdateWithWhereUniqueWithoutSourceDisciplineInput = {
    where: KnowledgeIntegrationWhereUniqueInput
    data: XOR<KnowledgeIntegrationUpdateWithoutSourceDisciplineInput, KnowledgeIntegrationUncheckedUpdateWithoutSourceDisciplineInput>
  }

  export type KnowledgeIntegrationUpdateManyWithWhereWithoutSourceDisciplineInput = {
    where: KnowledgeIntegrationScalarWhereInput
    data: XOR<KnowledgeIntegrationUpdateManyMutationInput, KnowledgeIntegrationUncheckedUpdateManyWithoutSourceDisciplineInput>
  }

  export type KnowledgeIntegrationUpsertWithWhereUniqueWithoutTargetDisciplineInput = {
    where: KnowledgeIntegrationWhereUniqueInput
    update: XOR<KnowledgeIntegrationUpdateWithoutTargetDisciplineInput, KnowledgeIntegrationUncheckedUpdateWithoutTargetDisciplineInput>
    create: XOR<KnowledgeIntegrationCreateWithoutTargetDisciplineInput, KnowledgeIntegrationUncheckedCreateWithoutTargetDisciplineInput>
  }

  export type KnowledgeIntegrationUpdateWithWhereUniqueWithoutTargetDisciplineInput = {
    where: KnowledgeIntegrationWhereUniqueInput
    data: XOR<KnowledgeIntegrationUpdateWithoutTargetDisciplineInput, KnowledgeIntegrationUncheckedUpdateWithoutTargetDisciplineInput>
  }

  export type KnowledgeIntegrationUpdateManyWithWhereWithoutTargetDisciplineInput = {
    where: KnowledgeIntegrationScalarWhereInput
    data: XOR<KnowledgeIntegrationUpdateManyMutationInput, KnowledgeIntegrationUncheckedUpdateManyWithoutTargetDisciplineInput>
  }

  export type ProjectDisciplineUpsertWithWhereUniqueWithoutDisciplineInput = {
    where: ProjectDisciplineWhereUniqueInput
    update: XOR<ProjectDisciplineUpdateWithoutDisciplineInput, ProjectDisciplineUncheckedUpdateWithoutDisciplineInput>
    create: XOR<ProjectDisciplineCreateWithoutDisciplineInput, ProjectDisciplineUncheckedCreateWithoutDisciplineInput>
  }

  export type ProjectDisciplineUpdateWithWhereUniqueWithoutDisciplineInput = {
    where: ProjectDisciplineWhereUniqueInput
    data: XOR<ProjectDisciplineUpdateWithoutDisciplineInput, ProjectDisciplineUncheckedUpdateWithoutDisciplineInput>
  }

  export type ProjectDisciplineUpdateManyWithWhereWithoutDisciplineInput = {
    where: ProjectDisciplineScalarWhereInput
    data: XOR<ProjectDisciplineUpdateManyMutationInput, ProjectDisciplineUncheckedUpdateManyWithoutDisciplineInput>
  }

  export type ProjectDisciplineScalarWhereInput = {
    AND?: ProjectDisciplineScalarWhereInput | ProjectDisciplineScalarWhereInput[]
    OR?: ProjectDisciplineScalarWhereInput[]
    NOT?: ProjectDisciplineScalarWhereInput | ProjectDisciplineScalarWhereInput[]
    id?: StringFilter<"ProjectDiscipline"> | string
    projectId?: StringFilter<"ProjectDiscipline"> | string
    disciplineId?: StringFilter<"ProjectDiscipline"> | string
    primaryDiscipline?: BoolFilter<"ProjectDiscipline"> | boolean
    contributionLevel?: StringFilter<"ProjectDiscipline"> | string
    createdAt?: DateTimeFilter<"ProjectDiscipline"> | Date | string
  }

  export type ProjectOccupationCreateWithoutOccupationInput = {
    id?: string
    relevanceLevel?: string
    roleDescription?: string | null
    createdAt?: Date | string
    project: ResearchProjectCreateNestedOneWithoutOccupationsInput
  }

  export type ProjectOccupationUncheckedCreateWithoutOccupationInput = {
    id?: string
    projectId: string
    relevanceLevel?: string
    roleDescription?: string | null
    createdAt?: Date | string
  }

  export type ProjectOccupationCreateOrConnectWithoutOccupationInput = {
    where: ProjectOccupationWhereUniqueInput
    create: XOR<ProjectOccupationCreateWithoutOccupationInput, ProjectOccupationUncheckedCreateWithoutOccupationInput>
  }

  export type ProjectOccupationCreateManyOccupationInputEnvelope = {
    data: ProjectOccupationCreateManyOccupationInput | ProjectOccupationCreateManyOccupationInput[]
    skipDuplicates?: boolean
  }

  export type ProjectOccupationUpsertWithWhereUniqueWithoutOccupationInput = {
    where: ProjectOccupationWhereUniqueInput
    update: XOR<ProjectOccupationUpdateWithoutOccupationInput, ProjectOccupationUncheckedUpdateWithoutOccupationInput>
    create: XOR<ProjectOccupationCreateWithoutOccupationInput, ProjectOccupationUncheckedCreateWithoutOccupationInput>
  }

  export type ProjectOccupationUpdateWithWhereUniqueWithoutOccupationInput = {
    where: ProjectOccupationWhereUniqueInput
    data: XOR<ProjectOccupationUpdateWithoutOccupationInput, ProjectOccupationUncheckedUpdateWithoutOccupationInput>
  }

  export type ProjectOccupationUpdateManyWithWhereWithoutOccupationInput = {
    where: ProjectOccupationScalarWhereInput
    data: XOR<ProjectOccupationUpdateManyMutationInput, ProjectOccupationUncheckedUpdateManyWithoutOccupationInput>
  }

  export type ProjectOccupationScalarWhereInput = {
    AND?: ProjectOccupationScalarWhereInput | ProjectOccupationScalarWhereInput[]
    OR?: ProjectOccupationScalarWhereInput[]
    NOT?: ProjectOccupationScalarWhereInput | ProjectOccupationScalarWhereInput[]
    id?: StringFilter<"ProjectOccupation"> | string
    projectId?: StringFilter<"ProjectOccupation"> | string
    occupationId?: StringFilter<"ProjectOccupation"> | string
    relevanceLevel?: StringFilter<"ProjectOccupation"> | string
    roleDescription?: StringNullableFilter<"ProjectOccupation"> | string | null
    createdAt?: DateTimeFilter<"ProjectOccupation"> | Date | string
  }

  export type KnowledgeIntegrationCreateWithoutProjectInput = {
    id?: string
    integrationType: $Enums.KnowledgeIntegrationType
    title: string
    description?: string | null
    sourceKnowledge?: string | null
    targetApplication?: string | null
    integrationMethod?: string | null
    validationStatus?: string
    validationNotes?: string | null
    noveltyScore?: Decimal | DecimalJsLike | number | string | null
    impactPotential?: string | null
    implementationFeasibility?: string | null
    references?: KnowledgeIntegrationCreatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutKnowledgeIntegrationsInput
    sourceDiscipline: AcademicDisciplineCreateNestedOneWithoutKnowledgeIntegrationsSourceInput
    targetDiscipline: AcademicDisciplineCreateNestedOneWithoutKnowledgeIntegrationsTargetInput
  }

  export type KnowledgeIntegrationUncheckedCreateWithoutProjectInput = {
    id?: string
    sourceDisciplineId: string
    targetDisciplineId: string
    integrationType: $Enums.KnowledgeIntegrationType
    title: string
    description?: string | null
    sourceKnowledge?: string | null
    targetApplication?: string | null
    integrationMethod?: string | null
    validationStatus?: string
    validationNotes?: string | null
    noveltyScore?: Decimal | DecimalJsLike | number | string | null
    impactPotential?: string | null
    implementationFeasibility?: string | null
    references?: KnowledgeIntegrationCreatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeIntegrationCreateOrConnectWithoutProjectInput = {
    where: KnowledgeIntegrationWhereUniqueInput
    create: XOR<KnowledgeIntegrationCreateWithoutProjectInput, KnowledgeIntegrationUncheckedCreateWithoutProjectInput>
  }

  export type KnowledgeIntegrationCreateManyProjectInputEnvelope = {
    data: KnowledgeIntegrationCreateManyProjectInput | KnowledgeIntegrationCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCollaboratorCreateWithoutProjectInput = {
    id?: string
    role: string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: string | null
    joinedAt?: Date | string
    status?: string
    user: UserCreateNestedOneWithoutProjectCollaborationsInput
  }

  export type ProjectCollaboratorUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    role: string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: string | null
    joinedAt?: Date | string
    status?: string
  }

  export type ProjectCollaboratorCreateOrConnectWithoutProjectInput = {
    where: ProjectCollaboratorWhereUniqueInput
    create: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput>
  }

  export type ProjectCollaboratorCreateManyProjectInputEnvelope = {
    data: ProjectCollaboratorCreateManyProjectInput | ProjectCollaboratorCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectDisciplineCreateWithoutProjectInput = {
    id?: string
    primaryDiscipline?: boolean
    contributionLevel?: string
    createdAt?: Date | string
    discipline: AcademicDisciplineCreateNestedOneWithoutProjectDisciplinesInput
  }

  export type ProjectDisciplineUncheckedCreateWithoutProjectInput = {
    id?: string
    disciplineId: string
    primaryDiscipline?: boolean
    contributionLevel?: string
    createdAt?: Date | string
  }

  export type ProjectDisciplineCreateOrConnectWithoutProjectInput = {
    where: ProjectDisciplineWhereUniqueInput
    create: XOR<ProjectDisciplineCreateWithoutProjectInput, ProjectDisciplineUncheckedCreateWithoutProjectInput>
  }

  export type ProjectDisciplineCreateManyProjectInputEnvelope = {
    data: ProjectDisciplineCreateManyProjectInput | ProjectDisciplineCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMethodologyStepCreateWithoutProjectInput = {
    id?: string
    status?: string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    notes?: string | null
    deliverablesUploaded?: ProjectMethodologyStepCreatedeliverablesUploadedInput | string[]
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedMethodologyStepsInput
    methodologyStep: MethodologyStepCreateNestedOneWithoutProjectStepsInput
  }

  export type ProjectMethodologyStepUncheckedCreateWithoutProjectInput = {
    id?: string
    methodologyStepId: string
    assignedToId?: string | null
    status?: string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    notes?: string | null
    deliverablesUploaded?: ProjectMethodologyStepCreatedeliverablesUploadedInput | string[]
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMethodologyStepCreateOrConnectWithoutProjectInput = {
    where: ProjectMethodologyStepWhereUniqueInput
    create: XOR<ProjectMethodologyStepCreateWithoutProjectInput, ProjectMethodologyStepUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMethodologyStepCreateManyProjectInputEnvelope = {
    data: ProjectMethodologyStepCreateManyProjectInput | ProjectMethodologyStepCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectOccupationCreateWithoutProjectInput = {
    id?: string
    relevanceLevel?: string
    roleDescription?: string | null
    createdAt?: Date | string
    occupation: OnetOccupationCreateNestedOneWithoutProjectOccupationsInput
  }

  export type ProjectOccupationUncheckedCreateWithoutProjectInput = {
    id?: string
    occupationId: string
    relevanceLevel?: string
    roleDescription?: string | null
    createdAt?: Date | string
  }

  export type ProjectOccupationCreateOrConnectWithoutProjectInput = {
    where: ProjectOccupationWhereUniqueInput
    create: XOR<ProjectOccupationCreateWithoutProjectInput, ProjectOccupationUncheckedCreateWithoutProjectInput>
  }

  export type ProjectOccupationCreateManyProjectInputEnvelope = {
    data: ProjectOccupationCreateManyProjectInput | ProjectOccupationCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ResearchAnalysisCreateWithoutProjectInput = {
    id?: string
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    analyst: UserCreateNestedOneWithoutAnalysesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedAnalysesInput
    image?: UploadedImageCreateNestedOneWithoutAnalysesInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedAnalysesInput
  }

  export type ResearchAnalysisUncheckedCreateWithoutProjectInput = {
    id?: string
    imageId?: string | null
    analystId: string
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchAnalysisCreateOrConnectWithoutProjectInput = {
    where: ResearchAnalysisWhereUniqueInput
    create: XOR<ResearchAnalysisCreateWithoutProjectInput, ResearchAnalysisUncheckedCreateWithoutProjectInput>
  }

  export type ResearchAnalysisCreateManyProjectInputEnvelope = {
    data: ResearchAnalysisCreateManyProjectInput | ResearchAnalysisCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    knowledgeIntegrations?: KnowledgeIntegrationCreateNestedManyWithoutCreatedByInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    assignedMethodologySteps?: ProjectMethodologyStepCreateNestedManyWithoutAssignedToInput
    analyses?: ResearchAnalysisCreateNestedManyWithoutAnalystInput
    approvedAnalyses?: ResearchAnalysisCreateNestedManyWithoutApprovedByInput
    reviewedAnalyses?: ResearchAnalysisCreateNestedManyWithoutReviewedByInput
    uploadedImages?: UploadedImageCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutCreatedByInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    assignedMethodologySteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutAssignedToInput
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutAnalystInput
    approvedAnalyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutApprovedByInput
    reviewedAnalyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutReviewedByInput
    uploadedImages?: UploadedImageUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type UploadedImageCreateWithoutProjectInput = {
    id?: string
    fileName: string
    originalFileName?: string | null
    filePath: string
    fileSize?: bigint | number | null
    mimeType?: string | null
    imageType?: string | null
    imageConfidence?: Decimal | DecimalJsLike | number | string | null
    width?: number | null
    height?: number | null
    colorDepth?: number | null
    hasMetadata?: boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: $Enums.AnalysisStatus
    tags?: UploadedImageCreatetagsInput | string[]
    description?: string | null
    consentObtained?: boolean
    dataClassification?: string
    anonymized?: boolean
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: ResearchAnalysisCreateNestedManyWithoutImageInput
    uploadedBy: UserCreateNestedOneWithoutUploadedImagesInput
  }

  export type UploadedImageUncheckedCreateWithoutProjectInput = {
    id?: string
    uploadedById: string
    fileName: string
    originalFileName?: string | null
    filePath: string
    fileSize?: bigint | number | null
    mimeType?: string | null
    imageType?: string | null
    imageConfidence?: Decimal | DecimalJsLike | number | string | null
    width?: number | null
    height?: number | null
    colorDepth?: number | null
    hasMetadata?: boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: $Enums.AnalysisStatus
    tags?: UploadedImageCreatetagsInput | string[]
    description?: string | null
    consentObtained?: boolean
    dataClassification?: string
    anonymized?: boolean
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutImageInput
  }

  export type UploadedImageCreateOrConnectWithoutProjectInput = {
    where: UploadedImageWhereUniqueInput
    create: XOR<UploadedImageCreateWithoutProjectInput, UploadedImageUncheckedCreateWithoutProjectInput>
  }

  export type UploadedImageCreateManyProjectInputEnvelope = {
    data: UploadedImageCreateManyProjectInput | UploadedImageCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeIntegrationUpsertWithWhereUniqueWithoutProjectInput = {
    where: KnowledgeIntegrationWhereUniqueInput
    update: XOR<KnowledgeIntegrationUpdateWithoutProjectInput, KnowledgeIntegrationUncheckedUpdateWithoutProjectInput>
    create: XOR<KnowledgeIntegrationCreateWithoutProjectInput, KnowledgeIntegrationUncheckedCreateWithoutProjectInput>
  }

  export type KnowledgeIntegrationUpdateWithWhereUniqueWithoutProjectInput = {
    where: KnowledgeIntegrationWhereUniqueInput
    data: XOR<KnowledgeIntegrationUpdateWithoutProjectInput, KnowledgeIntegrationUncheckedUpdateWithoutProjectInput>
  }

  export type KnowledgeIntegrationUpdateManyWithWhereWithoutProjectInput = {
    where: KnowledgeIntegrationScalarWhereInput
    data: XOR<KnowledgeIntegrationUpdateManyMutationInput, KnowledgeIntegrationUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCollaboratorUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectCollaboratorWhereUniqueInput
    update: XOR<ProjectCollaboratorUpdateWithoutProjectInput, ProjectCollaboratorUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectCollaboratorCreateWithoutProjectInput, ProjectCollaboratorUncheckedCreateWithoutProjectInput>
  }

  export type ProjectCollaboratorUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectCollaboratorWhereUniqueInput
    data: XOR<ProjectCollaboratorUpdateWithoutProjectInput, ProjectCollaboratorUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectCollaboratorUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectCollaboratorScalarWhereInput
    data: XOR<ProjectCollaboratorUpdateManyMutationInput, ProjectCollaboratorUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectDisciplineUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectDisciplineWhereUniqueInput
    update: XOR<ProjectDisciplineUpdateWithoutProjectInput, ProjectDisciplineUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectDisciplineCreateWithoutProjectInput, ProjectDisciplineUncheckedCreateWithoutProjectInput>
  }

  export type ProjectDisciplineUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectDisciplineWhereUniqueInput
    data: XOR<ProjectDisciplineUpdateWithoutProjectInput, ProjectDisciplineUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectDisciplineUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectDisciplineScalarWhereInput
    data: XOR<ProjectDisciplineUpdateManyMutationInput, ProjectDisciplineUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectMethodologyStepUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMethodologyStepWhereUniqueInput
    update: XOR<ProjectMethodologyStepUpdateWithoutProjectInput, ProjectMethodologyStepUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMethodologyStepCreateWithoutProjectInput, ProjectMethodologyStepUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMethodologyStepUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMethodologyStepWhereUniqueInput
    data: XOR<ProjectMethodologyStepUpdateWithoutProjectInput, ProjectMethodologyStepUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMethodologyStepUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMethodologyStepScalarWhereInput
    data: XOR<ProjectMethodologyStepUpdateManyMutationInput, ProjectMethodologyStepUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectOccupationUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectOccupationWhereUniqueInput
    update: XOR<ProjectOccupationUpdateWithoutProjectInput, ProjectOccupationUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectOccupationCreateWithoutProjectInput, ProjectOccupationUncheckedCreateWithoutProjectInput>
  }

  export type ProjectOccupationUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectOccupationWhereUniqueInput
    data: XOR<ProjectOccupationUpdateWithoutProjectInput, ProjectOccupationUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectOccupationUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectOccupationScalarWhereInput
    data: XOR<ProjectOccupationUpdateManyMutationInput, ProjectOccupationUncheckedUpdateManyWithoutProjectInput>
  }

  export type ResearchAnalysisUpsertWithWhereUniqueWithoutProjectInput = {
    where: ResearchAnalysisWhereUniqueInput
    update: XOR<ResearchAnalysisUpdateWithoutProjectInput, ResearchAnalysisUncheckedUpdateWithoutProjectInput>
    create: XOR<ResearchAnalysisCreateWithoutProjectInput, ResearchAnalysisUncheckedCreateWithoutProjectInput>
  }

  export type ResearchAnalysisUpdateWithWhereUniqueWithoutProjectInput = {
    where: ResearchAnalysisWhereUniqueInput
    data: XOR<ResearchAnalysisUpdateWithoutProjectInput, ResearchAnalysisUncheckedUpdateWithoutProjectInput>
  }

  export type ResearchAnalysisUpdateManyWithWhereWithoutProjectInput = {
    where: ResearchAnalysisScalarWhereInput
    data: XOR<ResearchAnalysisUpdateManyMutationInput, ResearchAnalysisUncheckedUpdateManyWithoutProjectInput>
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    knowledgeIntegrations?: KnowledgeIntegrationUpdateManyWithoutCreatedByNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    assignedMethodologySteps?: ProjectMethodologyStepUpdateManyWithoutAssignedToNestedInput
    analyses?: ResearchAnalysisUpdateManyWithoutAnalystNestedInput
    approvedAnalyses?: ResearchAnalysisUpdateManyWithoutApprovedByNestedInput
    reviewedAnalyses?: ResearchAnalysisUpdateManyWithoutReviewedByNestedInput
    uploadedImages?: UploadedImageUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedUpdateManyWithoutCreatedByNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    assignedMethodologySteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutAssignedToNestedInput
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutAnalystNestedInput
    approvedAnalyses?: ResearchAnalysisUncheckedUpdateManyWithoutApprovedByNestedInput
    reviewedAnalyses?: ResearchAnalysisUncheckedUpdateManyWithoutReviewedByNestedInput
    uploadedImages?: UploadedImageUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UploadedImageUpsertWithWhereUniqueWithoutProjectInput = {
    where: UploadedImageWhereUniqueInput
    update: XOR<UploadedImageUpdateWithoutProjectInput, UploadedImageUncheckedUpdateWithoutProjectInput>
    create: XOR<UploadedImageCreateWithoutProjectInput, UploadedImageUncheckedCreateWithoutProjectInput>
  }

  export type UploadedImageUpdateWithWhereUniqueWithoutProjectInput = {
    where: UploadedImageWhereUniqueInput
    data: XOR<UploadedImageUpdateWithoutProjectInput, UploadedImageUncheckedUpdateWithoutProjectInput>
  }

  export type UploadedImageUpdateManyWithWhereWithoutProjectInput = {
    where: UploadedImageScalarWhereInput
    data: XOR<UploadedImageUpdateManyMutationInput, UploadedImageUncheckedUpdateManyWithoutProjectInput>
  }

  export type AcademicDisciplineCreateWithoutProjectDisciplinesInput = {
    id?: string
    code: string
    name: string
    level?: number
    description?: string | null
    keywords?: AcademicDisciplineCreatekeywordsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    parentDiscipline?: AcademicDisciplineCreateNestedOneWithoutChildDisciplinesInput
    childDisciplines?: AcademicDisciplineCreateNestedManyWithoutParentDisciplineInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationCreateNestedManyWithoutSourceDisciplineInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationCreateNestedManyWithoutTargetDisciplineInput
  }

  export type AcademicDisciplineUncheckedCreateWithoutProjectDisciplinesInput = {
    id?: string
    code: string
    name: string
    parentDisciplineId?: string | null
    level?: number
    description?: string | null
    keywords?: AcademicDisciplineCreatekeywordsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    childDisciplines?: AcademicDisciplineUncheckedCreateNestedManyWithoutParentDisciplineInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutSourceDisciplineInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutTargetDisciplineInput
  }

  export type AcademicDisciplineCreateOrConnectWithoutProjectDisciplinesInput = {
    where: AcademicDisciplineWhereUniqueInput
    create: XOR<AcademicDisciplineCreateWithoutProjectDisciplinesInput, AcademicDisciplineUncheckedCreateWithoutProjectDisciplinesInput>
  }

  export type ResearchProjectCreateWithoutDisciplinesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeIntegrations?: KnowledgeIntegrationCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    methodologySteps?: ProjectMethodologyStepCreateNestedManyWithoutProjectInput
    occupations?: ProjectOccupationCreateNestedManyWithoutProjectInput
    analyses?: ResearchAnalysisCreateNestedManyWithoutProjectInput
    principalInvestigator: UserCreateNestedOneWithoutProjectsInput
    images?: UploadedImageCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectUncheckedCreateWithoutDisciplinesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    principalInvestigatorId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    methodologySteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutProjectInput
    occupations?: ProjectOccupationUncheckedCreateNestedManyWithoutProjectInput
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutProjectInput
    images?: UploadedImageUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectCreateOrConnectWithoutDisciplinesInput = {
    where: ResearchProjectWhereUniqueInput
    create: XOR<ResearchProjectCreateWithoutDisciplinesInput, ResearchProjectUncheckedCreateWithoutDisciplinesInput>
  }

  export type AcademicDisciplineUpsertWithoutProjectDisciplinesInput = {
    update: XOR<AcademicDisciplineUpdateWithoutProjectDisciplinesInput, AcademicDisciplineUncheckedUpdateWithoutProjectDisciplinesInput>
    create: XOR<AcademicDisciplineCreateWithoutProjectDisciplinesInput, AcademicDisciplineUncheckedCreateWithoutProjectDisciplinesInput>
    where?: AcademicDisciplineWhereInput
  }

  export type AcademicDisciplineUpdateToOneWithWhereWithoutProjectDisciplinesInput = {
    where?: AcademicDisciplineWhereInput
    data: XOR<AcademicDisciplineUpdateWithoutProjectDisciplinesInput, AcademicDisciplineUncheckedUpdateWithoutProjectDisciplinesInput>
  }

  export type AcademicDisciplineUpdateWithoutProjectDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: AcademicDisciplineUpdatekeywordsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentDiscipline?: AcademicDisciplineUpdateOneWithoutChildDisciplinesNestedInput
    childDisciplines?: AcademicDisciplineUpdateManyWithoutParentDisciplineNestedInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationUpdateManyWithoutSourceDisciplineNestedInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationUpdateManyWithoutTargetDisciplineNestedInput
  }

  export type AcademicDisciplineUncheckedUpdateWithoutProjectDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentDisciplineId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: AcademicDisciplineUpdatekeywordsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childDisciplines?: AcademicDisciplineUncheckedUpdateManyWithoutParentDisciplineNestedInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationUncheckedUpdateManyWithoutSourceDisciplineNestedInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationUncheckedUpdateManyWithoutTargetDisciplineNestedInput
  }

  export type ResearchProjectUpsertWithoutDisciplinesInput = {
    update: XOR<ResearchProjectUpdateWithoutDisciplinesInput, ResearchProjectUncheckedUpdateWithoutDisciplinesInput>
    create: XOR<ResearchProjectCreateWithoutDisciplinesInput, ResearchProjectUncheckedCreateWithoutDisciplinesInput>
    where?: ResearchProjectWhereInput
  }

  export type ResearchProjectUpdateToOneWithWhereWithoutDisciplinesInput = {
    where?: ResearchProjectWhereInput
    data: XOR<ResearchProjectUpdateWithoutDisciplinesInput, ResearchProjectUncheckedUpdateWithoutDisciplinesInput>
  }

  export type ResearchProjectUpdateWithoutDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    methodologySteps?: ProjectMethodologyStepUpdateManyWithoutProjectNestedInput
    occupations?: ProjectOccupationUpdateManyWithoutProjectNestedInput
    analyses?: ResearchAnalysisUpdateManyWithoutProjectNestedInput
    principalInvestigator?: UserUpdateOneRequiredWithoutProjectsNestedInput
    images?: UploadedImageUpdateManyWithoutProjectNestedInput
  }

  export type ResearchProjectUncheckedUpdateWithoutDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    principalInvestigatorId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    methodologySteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutProjectNestedInput
    occupations?: ProjectOccupationUncheckedUpdateManyWithoutProjectNestedInput
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutProjectNestedInput
    images?: UploadedImageUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type OnetOccupationCreateWithoutProjectOccupationsInput = {
    id?: string
    onetCode: string
    title: string
    description?: string | null
    category?: string | null
    subdomain?: string | null
    tasks?: OnetOccupationCreatetasksInput | string[]
    skills?: OnetOccupationCreateskillsInput | string[]
    knowledgeAreas?: OnetOccupationCreateknowledgeAreasInput | string[]
    abilities?: OnetOccupationCreateabilitiesInput | string[]
    educationLevel?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type OnetOccupationUncheckedCreateWithoutProjectOccupationsInput = {
    id?: string
    onetCode: string
    title: string
    description?: string | null
    category?: string | null
    subdomain?: string | null
    tasks?: OnetOccupationCreatetasksInput | string[]
    skills?: OnetOccupationCreateskillsInput | string[]
    knowledgeAreas?: OnetOccupationCreateknowledgeAreasInput | string[]
    abilities?: OnetOccupationCreateabilitiesInput | string[]
    educationLevel?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type OnetOccupationCreateOrConnectWithoutProjectOccupationsInput = {
    where: OnetOccupationWhereUniqueInput
    create: XOR<OnetOccupationCreateWithoutProjectOccupationsInput, OnetOccupationUncheckedCreateWithoutProjectOccupationsInput>
  }

  export type ResearchProjectCreateWithoutOccupationsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeIntegrations?: KnowledgeIntegrationCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    disciplines?: ProjectDisciplineCreateNestedManyWithoutProjectInput
    methodologySteps?: ProjectMethodologyStepCreateNestedManyWithoutProjectInput
    analyses?: ResearchAnalysisCreateNestedManyWithoutProjectInput
    principalInvestigator: UserCreateNestedOneWithoutProjectsInput
    images?: UploadedImageCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectUncheckedCreateWithoutOccupationsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    principalInvestigatorId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    disciplines?: ProjectDisciplineUncheckedCreateNestedManyWithoutProjectInput
    methodologySteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutProjectInput
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutProjectInput
    images?: UploadedImageUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectCreateOrConnectWithoutOccupationsInput = {
    where: ResearchProjectWhereUniqueInput
    create: XOR<ResearchProjectCreateWithoutOccupationsInput, ResearchProjectUncheckedCreateWithoutOccupationsInput>
  }

  export type OnetOccupationUpsertWithoutProjectOccupationsInput = {
    update: XOR<OnetOccupationUpdateWithoutProjectOccupationsInput, OnetOccupationUncheckedUpdateWithoutProjectOccupationsInput>
    create: XOR<OnetOccupationCreateWithoutProjectOccupationsInput, OnetOccupationUncheckedCreateWithoutProjectOccupationsInput>
    where?: OnetOccupationWhereInput
  }

  export type OnetOccupationUpdateToOneWithWhereWithoutProjectOccupationsInput = {
    where?: OnetOccupationWhereInput
    data: XOR<OnetOccupationUpdateWithoutProjectOccupationsInput, OnetOccupationUncheckedUpdateWithoutProjectOccupationsInput>
  }

  export type OnetOccupationUpdateWithoutProjectOccupationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    onetCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: OnetOccupationUpdatetasksInput | string[]
    skills?: OnetOccupationUpdateskillsInput | string[]
    knowledgeAreas?: OnetOccupationUpdateknowledgeAreasInput | string[]
    abilities?: OnetOccupationUpdateabilitiesInput | string[]
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnetOccupationUncheckedUpdateWithoutProjectOccupationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    onetCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: OnetOccupationUpdatetasksInput | string[]
    skills?: OnetOccupationUpdateskillsInput | string[]
    knowledgeAreas?: OnetOccupationUpdateknowledgeAreasInput | string[]
    abilities?: OnetOccupationUpdateabilitiesInput | string[]
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchProjectUpsertWithoutOccupationsInput = {
    update: XOR<ResearchProjectUpdateWithoutOccupationsInput, ResearchProjectUncheckedUpdateWithoutOccupationsInput>
    create: XOR<ResearchProjectCreateWithoutOccupationsInput, ResearchProjectUncheckedCreateWithoutOccupationsInput>
    where?: ResearchProjectWhereInput
  }

  export type ResearchProjectUpdateToOneWithWhereWithoutOccupationsInput = {
    where?: ResearchProjectWhereInput
    data: XOR<ResearchProjectUpdateWithoutOccupationsInput, ResearchProjectUncheckedUpdateWithoutOccupationsInput>
  }

  export type ResearchProjectUpdateWithoutOccupationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    disciplines?: ProjectDisciplineUpdateManyWithoutProjectNestedInput
    methodologySteps?: ProjectMethodologyStepUpdateManyWithoutProjectNestedInput
    analyses?: ResearchAnalysisUpdateManyWithoutProjectNestedInput
    principalInvestigator?: UserUpdateOneRequiredWithoutProjectsNestedInput
    images?: UploadedImageUpdateManyWithoutProjectNestedInput
  }

  export type ResearchProjectUncheckedUpdateWithoutOccupationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    principalInvestigatorId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    disciplines?: ProjectDisciplineUncheckedUpdateManyWithoutProjectNestedInput
    methodologySteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutProjectNestedInput
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutProjectNestedInput
    images?: UploadedImageUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectMethodologyStepCreateWithoutMethodologyStepInput = {
    id?: string
    status?: string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    notes?: string | null
    deliverablesUploaded?: ProjectMethodologyStepCreatedeliverablesUploadedInput | string[]
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedMethodologyStepsInput
    project: ResearchProjectCreateNestedOneWithoutMethodologyStepsInput
  }

  export type ProjectMethodologyStepUncheckedCreateWithoutMethodologyStepInput = {
    id?: string
    projectId: string
    assignedToId?: string | null
    status?: string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    notes?: string | null
    deliverablesUploaded?: ProjectMethodologyStepCreatedeliverablesUploadedInput | string[]
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMethodologyStepCreateOrConnectWithoutMethodologyStepInput = {
    where: ProjectMethodologyStepWhereUniqueInput
    create: XOR<ProjectMethodologyStepCreateWithoutMethodologyStepInput, ProjectMethodologyStepUncheckedCreateWithoutMethodologyStepInput>
  }

  export type ProjectMethodologyStepCreateManyMethodologyStepInputEnvelope = {
    data: ProjectMethodologyStepCreateManyMethodologyStepInput | ProjectMethodologyStepCreateManyMethodologyStepInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMethodologyStepUpsertWithWhereUniqueWithoutMethodologyStepInput = {
    where: ProjectMethodologyStepWhereUniqueInput
    update: XOR<ProjectMethodologyStepUpdateWithoutMethodologyStepInput, ProjectMethodologyStepUncheckedUpdateWithoutMethodologyStepInput>
    create: XOR<ProjectMethodologyStepCreateWithoutMethodologyStepInput, ProjectMethodologyStepUncheckedCreateWithoutMethodologyStepInput>
  }

  export type ProjectMethodologyStepUpdateWithWhereUniqueWithoutMethodologyStepInput = {
    where: ProjectMethodologyStepWhereUniqueInput
    data: XOR<ProjectMethodologyStepUpdateWithoutMethodologyStepInput, ProjectMethodologyStepUncheckedUpdateWithoutMethodologyStepInput>
  }

  export type ProjectMethodologyStepUpdateManyWithWhereWithoutMethodologyStepInput = {
    where: ProjectMethodologyStepScalarWhereInput
    data: XOR<ProjectMethodologyStepUpdateManyMutationInput, ProjectMethodologyStepUncheckedUpdateManyWithoutMethodologyStepInput>
  }

  export type UserCreateWithoutAssignedMethodologyStepsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    knowledgeIntegrations?: KnowledgeIntegrationCreateNestedManyWithoutCreatedByInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    analyses?: ResearchAnalysisCreateNestedManyWithoutAnalystInput
    approvedAnalyses?: ResearchAnalysisCreateNestedManyWithoutApprovedByInput
    reviewedAnalyses?: ResearchAnalysisCreateNestedManyWithoutReviewedByInput
    projects?: ResearchProjectCreateNestedManyWithoutPrincipalInvestigatorInput
    uploadedImages?: UploadedImageCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAssignedMethodologyStepsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutCreatedByInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutAnalystInput
    approvedAnalyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutApprovedByInput
    reviewedAnalyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutReviewedByInput
    projects?: ResearchProjectUncheckedCreateNestedManyWithoutPrincipalInvestigatorInput
    uploadedImages?: UploadedImageUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAssignedMethodologyStepsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedMethodologyStepsInput, UserUncheckedCreateWithoutAssignedMethodologyStepsInput>
  }

  export type MethodologyStepCreateWithoutProjectStepsInput = {
    id?: string
    name: string
    description?: string | null
    methodologyType: $Enums.MethodologyType
    stepOrder: number
    estimatedDurationHours?: number | null
    requiredResources?: MethodologyStepCreaterequiredResourcesInput | string[]
    deliverables?: MethodologyStepCreatedeliverablesInput | string[]
    successCriteria?: MethodologyStepCreatesuccessCriteriaInput | string[]
    dependencies?: MethodologyStepCreatedependenciesInput | string[]
    templateData?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
  }

  export type MethodologyStepUncheckedCreateWithoutProjectStepsInput = {
    id?: string
    name: string
    description?: string | null
    methodologyType: $Enums.MethodologyType
    stepOrder: number
    estimatedDurationHours?: number | null
    requiredResources?: MethodologyStepCreaterequiredResourcesInput | string[]
    deliverables?: MethodologyStepCreatedeliverablesInput | string[]
    successCriteria?: MethodologyStepCreatesuccessCriteriaInput | string[]
    dependencies?: MethodologyStepCreatedependenciesInput | string[]
    templateData?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
  }

  export type MethodologyStepCreateOrConnectWithoutProjectStepsInput = {
    where: MethodologyStepWhereUniqueInput
    create: XOR<MethodologyStepCreateWithoutProjectStepsInput, MethodologyStepUncheckedCreateWithoutProjectStepsInput>
  }

  export type ResearchProjectCreateWithoutMethodologyStepsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeIntegrations?: KnowledgeIntegrationCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    disciplines?: ProjectDisciplineCreateNestedManyWithoutProjectInput
    occupations?: ProjectOccupationCreateNestedManyWithoutProjectInput
    analyses?: ResearchAnalysisCreateNestedManyWithoutProjectInput
    principalInvestigator: UserCreateNestedOneWithoutProjectsInput
    images?: UploadedImageCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectUncheckedCreateWithoutMethodologyStepsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    principalInvestigatorId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    disciplines?: ProjectDisciplineUncheckedCreateNestedManyWithoutProjectInput
    occupations?: ProjectOccupationUncheckedCreateNestedManyWithoutProjectInput
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutProjectInput
    images?: UploadedImageUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectCreateOrConnectWithoutMethodologyStepsInput = {
    where: ResearchProjectWhereUniqueInput
    create: XOR<ResearchProjectCreateWithoutMethodologyStepsInput, ResearchProjectUncheckedCreateWithoutMethodologyStepsInput>
  }

  export type UserUpsertWithoutAssignedMethodologyStepsInput = {
    update: XOR<UserUpdateWithoutAssignedMethodologyStepsInput, UserUncheckedUpdateWithoutAssignedMethodologyStepsInput>
    create: XOR<UserCreateWithoutAssignedMethodologyStepsInput, UserUncheckedCreateWithoutAssignedMethodologyStepsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedMethodologyStepsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedMethodologyStepsInput, UserUncheckedUpdateWithoutAssignedMethodologyStepsInput>
  }

  export type UserUpdateWithoutAssignedMethodologyStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    knowledgeIntegrations?: KnowledgeIntegrationUpdateManyWithoutCreatedByNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    analyses?: ResearchAnalysisUpdateManyWithoutAnalystNestedInput
    approvedAnalyses?: ResearchAnalysisUpdateManyWithoutApprovedByNestedInput
    reviewedAnalyses?: ResearchAnalysisUpdateManyWithoutReviewedByNestedInput
    projects?: ResearchProjectUpdateManyWithoutPrincipalInvestigatorNestedInput
    uploadedImages?: UploadedImageUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedMethodologyStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedUpdateManyWithoutCreatedByNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutAnalystNestedInput
    approvedAnalyses?: ResearchAnalysisUncheckedUpdateManyWithoutApprovedByNestedInput
    reviewedAnalyses?: ResearchAnalysisUncheckedUpdateManyWithoutReviewedByNestedInput
    projects?: ResearchProjectUncheckedUpdateManyWithoutPrincipalInvestigatorNestedInput
    uploadedImages?: UploadedImageUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type MethodologyStepUpsertWithoutProjectStepsInput = {
    update: XOR<MethodologyStepUpdateWithoutProjectStepsInput, MethodologyStepUncheckedUpdateWithoutProjectStepsInput>
    create: XOR<MethodologyStepCreateWithoutProjectStepsInput, MethodologyStepUncheckedCreateWithoutProjectStepsInput>
    where?: MethodologyStepWhereInput
  }

  export type MethodologyStepUpdateToOneWithWhereWithoutProjectStepsInput = {
    where?: MethodologyStepWhereInput
    data: XOR<MethodologyStepUpdateWithoutProjectStepsInput, MethodologyStepUncheckedUpdateWithoutProjectStepsInput>
  }

  export type MethodologyStepUpdateWithoutProjectStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    stepOrder?: IntFieldUpdateOperationsInput | number
    estimatedDurationHours?: NullableIntFieldUpdateOperationsInput | number | null
    requiredResources?: MethodologyStepUpdaterequiredResourcesInput | string[]
    deliverables?: MethodologyStepUpdatedeliverablesInput | string[]
    successCriteria?: MethodologyStepUpdatesuccessCriteriaInput | string[]
    dependencies?: MethodologyStepUpdatedependenciesInput | string[]
    templateData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MethodologyStepUncheckedUpdateWithoutProjectStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    stepOrder?: IntFieldUpdateOperationsInput | number
    estimatedDurationHours?: NullableIntFieldUpdateOperationsInput | number | null
    requiredResources?: MethodologyStepUpdaterequiredResourcesInput | string[]
    deliverables?: MethodologyStepUpdatedeliverablesInput | string[]
    successCriteria?: MethodologyStepUpdatesuccessCriteriaInput | string[]
    dependencies?: MethodologyStepUpdatedependenciesInput | string[]
    templateData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchProjectUpsertWithoutMethodologyStepsInput = {
    update: XOR<ResearchProjectUpdateWithoutMethodologyStepsInput, ResearchProjectUncheckedUpdateWithoutMethodologyStepsInput>
    create: XOR<ResearchProjectCreateWithoutMethodologyStepsInput, ResearchProjectUncheckedCreateWithoutMethodologyStepsInput>
    where?: ResearchProjectWhereInput
  }

  export type ResearchProjectUpdateToOneWithWhereWithoutMethodologyStepsInput = {
    where?: ResearchProjectWhereInput
    data: XOR<ResearchProjectUpdateWithoutMethodologyStepsInput, ResearchProjectUncheckedUpdateWithoutMethodologyStepsInput>
  }

  export type ResearchProjectUpdateWithoutMethodologyStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    disciplines?: ProjectDisciplineUpdateManyWithoutProjectNestedInput
    occupations?: ProjectOccupationUpdateManyWithoutProjectNestedInput
    analyses?: ResearchAnalysisUpdateManyWithoutProjectNestedInput
    principalInvestigator?: UserUpdateOneRequiredWithoutProjectsNestedInput
    images?: UploadedImageUpdateManyWithoutProjectNestedInput
  }

  export type ResearchProjectUncheckedUpdateWithoutMethodologyStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    principalInvestigatorId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    disciplines?: ProjectDisciplineUncheckedUpdateManyWithoutProjectNestedInput
    occupations?: ProjectOccupationUncheckedUpdateManyWithoutProjectNestedInput
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutProjectNestedInput
    images?: UploadedImageUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ResearchAnalysisCreateWithoutImageInput = {
    id?: string
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    analyst: UserCreateNestedOneWithoutAnalysesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedAnalysesInput
    project?: ResearchProjectCreateNestedOneWithoutAnalysesInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedAnalysesInput
  }

  export type ResearchAnalysisUncheckedCreateWithoutImageInput = {
    id?: string
    projectId?: string | null
    analystId: string
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchAnalysisCreateOrConnectWithoutImageInput = {
    where: ResearchAnalysisWhereUniqueInput
    create: XOR<ResearchAnalysisCreateWithoutImageInput, ResearchAnalysisUncheckedCreateWithoutImageInput>
  }

  export type ResearchAnalysisCreateManyImageInputEnvelope = {
    data: ResearchAnalysisCreateManyImageInput | ResearchAnalysisCreateManyImageInput[]
    skipDuplicates?: boolean
  }

  export type ResearchProjectCreateWithoutImagesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeIntegrations?: KnowledgeIntegrationCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    disciplines?: ProjectDisciplineCreateNestedManyWithoutProjectInput
    methodologySteps?: ProjectMethodologyStepCreateNestedManyWithoutProjectInput
    occupations?: ProjectOccupationCreateNestedManyWithoutProjectInput
    analyses?: ResearchAnalysisCreateNestedManyWithoutProjectInput
    principalInvestigator: UserCreateNestedOneWithoutProjectsInput
  }

  export type ResearchProjectUncheckedCreateWithoutImagesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    principalInvestigatorId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    disciplines?: ProjectDisciplineUncheckedCreateNestedManyWithoutProjectInput
    methodologySteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutProjectInput
    occupations?: ProjectOccupationUncheckedCreateNestedManyWithoutProjectInput
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectCreateOrConnectWithoutImagesInput = {
    where: ResearchProjectWhereUniqueInput
    create: XOR<ResearchProjectCreateWithoutImagesInput, ResearchProjectUncheckedCreateWithoutImagesInput>
  }

  export type UserCreateWithoutUploadedImagesInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    knowledgeIntegrations?: KnowledgeIntegrationCreateNestedManyWithoutCreatedByInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    assignedMethodologySteps?: ProjectMethodologyStepCreateNestedManyWithoutAssignedToInput
    analyses?: ResearchAnalysisCreateNestedManyWithoutAnalystInput
    approvedAnalyses?: ResearchAnalysisCreateNestedManyWithoutApprovedByInput
    reviewedAnalyses?: ResearchAnalysisCreateNestedManyWithoutReviewedByInput
    projects?: ResearchProjectCreateNestedManyWithoutPrincipalInvestigatorInput
  }

  export type UserUncheckedCreateWithoutUploadedImagesInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutCreatedByInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    assignedMethodologySteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutAssignedToInput
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutAnalystInput
    approvedAnalyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutApprovedByInput
    reviewedAnalyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutReviewedByInput
    projects?: ResearchProjectUncheckedCreateNestedManyWithoutPrincipalInvestigatorInput
  }

  export type UserCreateOrConnectWithoutUploadedImagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedImagesInput, UserUncheckedCreateWithoutUploadedImagesInput>
  }

  export type ResearchAnalysisUpsertWithWhereUniqueWithoutImageInput = {
    where: ResearchAnalysisWhereUniqueInput
    update: XOR<ResearchAnalysisUpdateWithoutImageInput, ResearchAnalysisUncheckedUpdateWithoutImageInput>
    create: XOR<ResearchAnalysisCreateWithoutImageInput, ResearchAnalysisUncheckedCreateWithoutImageInput>
  }

  export type ResearchAnalysisUpdateWithWhereUniqueWithoutImageInput = {
    where: ResearchAnalysisWhereUniqueInput
    data: XOR<ResearchAnalysisUpdateWithoutImageInput, ResearchAnalysisUncheckedUpdateWithoutImageInput>
  }

  export type ResearchAnalysisUpdateManyWithWhereWithoutImageInput = {
    where: ResearchAnalysisScalarWhereInput
    data: XOR<ResearchAnalysisUpdateManyMutationInput, ResearchAnalysisUncheckedUpdateManyWithoutImageInput>
  }

  export type ResearchProjectUpsertWithoutImagesInput = {
    update: XOR<ResearchProjectUpdateWithoutImagesInput, ResearchProjectUncheckedUpdateWithoutImagesInput>
    create: XOR<ResearchProjectCreateWithoutImagesInput, ResearchProjectUncheckedCreateWithoutImagesInput>
    where?: ResearchProjectWhereInput
  }

  export type ResearchProjectUpdateToOneWithWhereWithoutImagesInput = {
    where?: ResearchProjectWhereInput
    data: XOR<ResearchProjectUpdateWithoutImagesInput, ResearchProjectUncheckedUpdateWithoutImagesInput>
  }

  export type ResearchProjectUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    disciplines?: ProjectDisciplineUpdateManyWithoutProjectNestedInput
    methodologySteps?: ProjectMethodologyStepUpdateManyWithoutProjectNestedInput
    occupations?: ProjectOccupationUpdateManyWithoutProjectNestedInput
    analyses?: ResearchAnalysisUpdateManyWithoutProjectNestedInput
    principalInvestigator?: UserUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ResearchProjectUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    principalInvestigatorId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    disciplines?: ProjectDisciplineUncheckedUpdateManyWithoutProjectNestedInput
    methodologySteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutProjectNestedInput
    occupations?: ProjectOccupationUncheckedUpdateManyWithoutProjectNestedInput
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutUploadedImagesInput = {
    update: XOR<UserUpdateWithoutUploadedImagesInput, UserUncheckedUpdateWithoutUploadedImagesInput>
    create: XOR<UserCreateWithoutUploadedImagesInput, UserUncheckedCreateWithoutUploadedImagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedImagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedImagesInput, UserUncheckedUpdateWithoutUploadedImagesInput>
  }

  export type UserUpdateWithoutUploadedImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    knowledgeIntegrations?: KnowledgeIntegrationUpdateManyWithoutCreatedByNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    assignedMethodologySteps?: ProjectMethodologyStepUpdateManyWithoutAssignedToNestedInput
    analyses?: ResearchAnalysisUpdateManyWithoutAnalystNestedInput
    approvedAnalyses?: ResearchAnalysisUpdateManyWithoutApprovedByNestedInput
    reviewedAnalyses?: ResearchAnalysisUpdateManyWithoutReviewedByNestedInput
    projects?: ResearchProjectUpdateManyWithoutPrincipalInvestigatorNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedUpdateManyWithoutCreatedByNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    assignedMethodologySteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutAssignedToNestedInput
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutAnalystNestedInput
    approvedAnalyses?: ResearchAnalysisUncheckedUpdateManyWithoutApprovedByNestedInput
    reviewedAnalyses?: ResearchAnalysisUncheckedUpdateManyWithoutReviewedByNestedInput
    projects?: ResearchProjectUncheckedUpdateManyWithoutPrincipalInvestigatorNestedInput
  }

  export type UserCreateWithoutAnalysesInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    knowledgeIntegrations?: KnowledgeIntegrationCreateNestedManyWithoutCreatedByInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    assignedMethodologySteps?: ProjectMethodologyStepCreateNestedManyWithoutAssignedToInput
    approvedAnalyses?: ResearchAnalysisCreateNestedManyWithoutApprovedByInput
    reviewedAnalyses?: ResearchAnalysisCreateNestedManyWithoutReviewedByInput
    projects?: ResearchProjectCreateNestedManyWithoutPrincipalInvestigatorInput
    uploadedImages?: UploadedImageCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAnalysesInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutCreatedByInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    assignedMethodologySteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutAssignedToInput
    approvedAnalyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutApprovedByInput
    reviewedAnalyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutReviewedByInput
    projects?: ResearchProjectUncheckedCreateNestedManyWithoutPrincipalInvestigatorInput
    uploadedImages?: UploadedImageUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAnalysesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnalysesInput, UserUncheckedCreateWithoutAnalysesInput>
  }

  export type UserCreateWithoutApprovedAnalysesInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    knowledgeIntegrations?: KnowledgeIntegrationCreateNestedManyWithoutCreatedByInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    assignedMethodologySteps?: ProjectMethodologyStepCreateNestedManyWithoutAssignedToInput
    analyses?: ResearchAnalysisCreateNestedManyWithoutAnalystInput
    reviewedAnalyses?: ResearchAnalysisCreateNestedManyWithoutReviewedByInput
    projects?: ResearchProjectCreateNestedManyWithoutPrincipalInvestigatorInput
    uploadedImages?: UploadedImageCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutApprovedAnalysesInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutCreatedByInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    assignedMethodologySteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutAssignedToInput
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutAnalystInput
    reviewedAnalyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutReviewedByInput
    projects?: ResearchProjectUncheckedCreateNestedManyWithoutPrincipalInvestigatorInput
    uploadedImages?: UploadedImageUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutApprovedAnalysesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedAnalysesInput, UserUncheckedCreateWithoutApprovedAnalysesInput>
  }

  export type UploadedImageCreateWithoutAnalysesInput = {
    id?: string
    fileName: string
    originalFileName?: string | null
    filePath: string
    fileSize?: bigint | number | null
    mimeType?: string | null
    imageType?: string | null
    imageConfidence?: Decimal | DecimalJsLike | number | string | null
    width?: number | null
    height?: number | null
    colorDepth?: number | null
    hasMetadata?: boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: $Enums.AnalysisStatus
    tags?: UploadedImageCreatetagsInput | string[]
    description?: string | null
    consentObtained?: boolean
    dataClassification?: string
    anonymized?: boolean
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ResearchProjectCreateNestedOneWithoutImagesInput
    uploadedBy: UserCreateNestedOneWithoutUploadedImagesInput
  }

  export type UploadedImageUncheckedCreateWithoutAnalysesInput = {
    id?: string
    projectId?: string | null
    uploadedById: string
    fileName: string
    originalFileName?: string | null
    filePath: string
    fileSize?: bigint | number | null
    mimeType?: string | null
    imageType?: string | null
    imageConfidence?: Decimal | DecimalJsLike | number | string | null
    width?: number | null
    height?: number | null
    colorDepth?: number | null
    hasMetadata?: boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: $Enums.AnalysisStatus
    tags?: UploadedImageCreatetagsInput | string[]
    description?: string | null
    consentObtained?: boolean
    dataClassification?: string
    anonymized?: boolean
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadedImageCreateOrConnectWithoutAnalysesInput = {
    where: UploadedImageWhereUniqueInput
    create: XOR<UploadedImageCreateWithoutAnalysesInput, UploadedImageUncheckedCreateWithoutAnalysesInput>
  }

  export type ResearchProjectCreateWithoutAnalysesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeIntegrations?: KnowledgeIntegrationCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    disciplines?: ProjectDisciplineCreateNestedManyWithoutProjectInput
    methodologySteps?: ProjectMethodologyStepCreateNestedManyWithoutProjectInput
    occupations?: ProjectOccupationCreateNestedManyWithoutProjectInput
    principalInvestigator: UserCreateNestedOneWithoutProjectsInput
    images?: UploadedImageCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectUncheckedCreateWithoutAnalysesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    principalInvestigatorId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutProjectInput
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    disciplines?: ProjectDisciplineUncheckedCreateNestedManyWithoutProjectInput
    methodologySteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutProjectInput
    occupations?: ProjectOccupationUncheckedCreateNestedManyWithoutProjectInput
    images?: UploadedImageUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectCreateOrConnectWithoutAnalysesInput = {
    where: ResearchProjectWhereUniqueInput
    create: XOR<ResearchProjectCreateWithoutAnalysesInput, ResearchProjectUncheckedCreateWithoutAnalysesInput>
  }

  export type UserCreateWithoutReviewedAnalysesInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    knowledgeIntegrations?: KnowledgeIntegrationCreateNestedManyWithoutCreatedByInput
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    assignedMethodologySteps?: ProjectMethodologyStepCreateNestedManyWithoutAssignedToInput
    analyses?: ResearchAnalysisCreateNestedManyWithoutAnalystInput
    approvedAnalyses?: ResearchAnalysisCreateNestedManyWithoutApprovedByInput
    projects?: ResearchProjectCreateNestedManyWithoutPrincipalInvestigatorInput
    uploadedImages?: UploadedImageCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutReviewedAnalysesInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutCreatedByInput
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    assignedMethodologySteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutAssignedToInput
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutAnalystInput
    approvedAnalyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutApprovedByInput
    projects?: ResearchProjectUncheckedCreateNestedManyWithoutPrincipalInvestigatorInput
    uploadedImages?: UploadedImageUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutReviewedAnalysesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewedAnalysesInput, UserUncheckedCreateWithoutReviewedAnalysesInput>
  }

  export type UserUpsertWithoutAnalysesInput = {
    update: XOR<UserUpdateWithoutAnalysesInput, UserUncheckedUpdateWithoutAnalysesInput>
    create: XOR<UserCreateWithoutAnalysesInput, UserUncheckedCreateWithoutAnalysesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnalysesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnalysesInput, UserUncheckedUpdateWithoutAnalysesInput>
  }

  export type UserUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    knowledgeIntegrations?: KnowledgeIntegrationUpdateManyWithoutCreatedByNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    assignedMethodologySteps?: ProjectMethodologyStepUpdateManyWithoutAssignedToNestedInput
    approvedAnalyses?: ResearchAnalysisUpdateManyWithoutApprovedByNestedInput
    reviewedAnalyses?: ResearchAnalysisUpdateManyWithoutReviewedByNestedInput
    projects?: ResearchProjectUpdateManyWithoutPrincipalInvestigatorNestedInput
    uploadedImages?: UploadedImageUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedUpdateManyWithoutCreatedByNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    assignedMethodologySteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutAssignedToNestedInput
    approvedAnalyses?: ResearchAnalysisUncheckedUpdateManyWithoutApprovedByNestedInput
    reviewedAnalyses?: ResearchAnalysisUncheckedUpdateManyWithoutReviewedByNestedInput
    projects?: ResearchProjectUncheckedUpdateManyWithoutPrincipalInvestigatorNestedInput
    uploadedImages?: UploadedImageUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUpsertWithoutApprovedAnalysesInput = {
    update: XOR<UserUpdateWithoutApprovedAnalysesInput, UserUncheckedUpdateWithoutApprovedAnalysesInput>
    create: XOR<UserCreateWithoutApprovedAnalysesInput, UserUncheckedCreateWithoutApprovedAnalysesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedAnalysesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedAnalysesInput, UserUncheckedUpdateWithoutApprovedAnalysesInput>
  }

  export type UserUpdateWithoutApprovedAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    knowledgeIntegrations?: KnowledgeIntegrationUpdateManyWithoutCreatedByNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    assignedMethodologySteps?: ProjectMethodologyStepUpdateManyWithoutAssignedToNestedInput
    analyses?: ResearchAnalysisUpdateManyWithoutAnalystNestedInput
    reviewedAnalyses?: ResearchAnalysisUpdateManyWithoutReviewedByNestedInput
    projects?: ResearchProjectUpdateManyWithoutPrincipalInvestigatorNestedInput
    uploadedImages?: UploadedImageUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedUpdateManyWithoutCreatedByNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    assignedMethodologySteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutAssignedToNestedInput
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutAnalystNestedInput
    reviewedAnalyses?: ResearchAnalysisUncheckedUpdateManyWithoutReviewedByNestedInput
    projects?: ResearchProjectUncheckedUpdateManyWithoutPrincipalInvestigatorNestedInput
    uploadedImages?: UploadedImageUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UploadedImageUpsertWithoutAnalysesInput = {
    update: XOR<UploadedImageUpdateWithoutAnalysesInput, UploadedImageUncheckedUpdateWithoutAnalysesInput>
    create: XOR<UploadedImageCreateWithoutAnalysesInput, UploadedImageUncheckedCreateWithoutAnalysesInput>
    where?: UploadedImageWhereInput
  }

  export type UploadedImageUpdateToOneWithWhereWithoutAnalysesInput = {
    where?: UploadedImageWhereInput
    data: XOR<UploadedImageUpdateWithoutAnalysesInput, UploadedImageUncheckedUpdateWithoutAnalysesInput>
  }

  export type UploadedImageUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    colorDepth?: NullableIntFieldUpdateOperationsInput | number | null
    hasMetadata?: BoolFieldUpdateOperationsInput | boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    tags?: UploadedImageUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    consentObtained?: BoolFieldUpdateOperationsInput | boolean
    dataClassification?: StringFieldUpdateOperationsInput | string
    anonymized?: BoolFieldUpdateOperationsInput | boolean
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ResearchProjectUpdateOneWithoutImagesNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedImagesNestedInput
  }

  export type UploadedImageUncheckedUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    colorDepth?: NullableIntFieldUpdateOperationsInput | number | null
    hasMetadata?: BoolFieldUpdateOperationsInput | boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    tags?: UploadedImageUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    consentObtained?: BoolFieldUpdateOperationsInput | boolean
    dataClassification?: StringFieldUpdateOperationsInput | string
    anonymized?: BoolFieldUpdateOperationsInput | boolean
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchProjectUpsertWithoutAnalysesInput = {
    update: XOR<ResearchProjectUpdateWithoutAnalysesInput, ResearchProjectUncheckedUpdateWithoutAnalysesInput>
    create: XOR<ResearchProjectCreateWithoutAnalysesInput, ResearchProjectUncheckedCreateWithoutAnalysesInput>
    where?: ResearchProjectWhereInput
  }

  export type ResearchProjectUpdateToOneWithWhereWithoutAnalysesInput = {
    where?: ResearchProjectWhereInput
    data: XOR<ResearchProjectUpdateWithoutAnalysesInput, ResearchProjectUncheckedUpdateWithoutAnalysesInput>
  }

  export type ResearchProjectUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    disciplines?: ProjectDisciplineUpdateManyWithoutProjectNestedInput
    methodologySteps?: ProjectMethodologyStepUpdateManyWithoutProjectNestedInput
    occupations?: ProjectOccupationUpdateManyWithoutProjectNestedInput
    principalInvestigator?: UserUpdateOneRequiredWithoutProjectsNestedInput
    images?: UploadedImageUpdateManyWithoutProjectNestedInput
  }

  export type ResearchProjectUncheckedUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    principalInvestigatorId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    disciplines?: ProjectDisciplineUncheckedUpdateManyWithoutProjectNestedInput
    methodologySteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutProjectNestedInput
    occupations?: ProjectOccupationUncheckedUpdateManyWithoutProjectNestedInput
    images?: UploadedImageUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutReviewedAnalysesInput = {
    update: XOR<UserUpdateWithoutReviewedAnalysesInput, UserUncheckedUpdateWithoutReviewedAnalysesInput>
    create: XOR<UserCreateWithoutReviewedAnalysesInput, UserUncheckedCreateWithoutReviewedAnalysesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewedAnalysesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewedAnalysesInput, UserUncheckedUpdateWithoutReviewedAnalysesInput>
  }

  export type UserUpdateWithoutReviewedAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    knowledgeIntegrations?: KnowledgeIntegrationUpdateManyWithoutCreatedByNestedInput
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    assignedMethodologySteps?: ProjectMethodologyStepUpdateManyWithoutAssignedToNestedInput
    analyses?: ResearchAnalysisUpdateManyWithoutAnalystNestedInput
    approvedAnalyses?: ResearchAnalysisUpdateManyWithoutApprovedByNestedInput
    projects?: ResearchProjectUpdateManyWithoutPrincipalInvestigatorNestedInput
    uploadedImages?: UploadedImageUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewedAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedUpdateManyWithoutCreatedByNestedInput
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    assignedMethodologySteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutAssignedToNestedInput
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutAnalystNestedInput
    approvedAnalyses?: ResearchAnalysisUncheckedUpdateManyWithoutApprovedByNestedInput
    projects?: ResearchProjectUncheckedUpdateManyWithoutPrincipalInvestigatorNestedInput
    uploadedImages?: UploadedImageUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateWithoutKnowledgeIntegrationsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    projectCollaborations?: ProjectCollaboratorCreateNestedManyWithoutUserInput
    assignedMethodologySteps?: ProjectMethodologyStepCreateNestedManyWithoutAssignedToInput
    analyses?: ResearchAnalysisCreateNestedManyWithoutAnalystInput
    approvedAnalyses?: ResearchAnalysisCreateNestedManyWithoutApprovedByInput
    reviewedAnalyses?: ResearchAnalysisCreateNestedManyWithoutReviewedByInput
    projects?: ResearchProjectCreateNestedManyWithoutPrincipalInvestigatorInput
    uploadedImages?: UploadedImageCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutKnowledgeIntegrationsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    projectCollaborations?: ProjectCollaboratorUncheckedCreateNestedManyWithoutUserInput
    assignedMethodologySteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutAssignedToInput
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutAnalystInput
    approvedAnalyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutApprovedByInput
    reviewedAnalyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutReviewedByInput
    projects?: ResearchProjectUncheckedCreateNestedManyWithoutPrincipalInvestigatorInput
    uploadedImages?: UploadedImageUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutKnowledgeIntegrationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKnowledgeIntegrationsInput, UserUncheckedCreateWithoutKnowledgeIntegrationsInput>
  }

  export type ResearchProjectCreateWithoutKnowledgeIntegrationsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    collaborators?: ProjectCollaboratorCreateNestedManyWithoutProjectInput
    disciplines?: ProjectDisciplineCreateNestedManyWithoutProjectInput
    methodologySteps?: ProjectMethodologyStepCreateNestedManyWithoutProjectInput
    occupations?: ProjectOccupationCreateNestedManyWithoutProjectInput
    analyses?: ResearchAnalysisCreateNestedManyWithoutProjectInput
    principalInvestigator: UserCreateNestedOneWithoutProjectsInput
    images?: UploadedImageCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectUncheckedCreateWithoutKnowledgeIntegrationsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    principalInvestigatorId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    collaborators?: ProjectCollaboratorUncheckedCreateNestedManyWithoutProjectInput
    disciplines?: ProjectDisciplineUncheckedCreateNestedManyWithoutProjectInput
    methodologySteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutProjectInput
    occupations?: ProjectOccupationUncheckedCreateNestedManyWithoutProjectInput
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutProjectInput
    images?: UploadedImageUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectCreateOrConnectWithoutKnowledgeIntegrationsInput = {
    where: ResearchProjectWhereUniqueInput
    create: XOR<ResearchProjectCreateWithoutKnowledgeIntegrationsInput, ResearchProjectUncheckedCreateWithoutKnowledgeIntegrationsInput>
  }

  export type AcademicDisciplineCreateWithoutKnowledgeIntegrationsSourceInput = {
    id?: string
    code: string
    name: string
    level?: number
    description?: string | null
    keywords?: AcademicDisciplineCreatekeywordsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    parentDiscipline?: AcademicDisciplineCreateNestedOneWithoutChildDisciplinesInput
    childDisciplines?: AcademicDisciplineCreateNestedManyWithoutParentDisciplineInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationCreateNestedManyWithoutTargetDisciplineInput
    projectDisciplines?: ProjectDisciplineCreateNestedManyWithoutDisciplineInput
  }

  export type AcademicDisciplineUncheckedCreateWithoutKnowledgeIntegrationsSourceInput = {
    id?: string
    code: string
    name: string
    parentDisciplineId?: string | null
    level?: number
    description?: string | null
    keywords?: AcademicDisciplineCreatekeywordsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    childDisciplines?: AcademicDisciplineUncheckedCreateNestedManyWithoutParentDisciplineInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutTargetDisciplineInput
    projectDisciplines?: ProjectDisciplineUncheckedCreateNestedManyWithoutDisciplineInput
  }

  export type AcademicDisciplineCreateOrConnectWithoutKnowledgeIntegrationsSourceInput = {
    where: AcademicDisciplineWhereUniqueInput
    create: XOR<AcademicDisciplineCreateWithoutKnowledgeIntegrationsSourceInput, AcademicDisciplineUncheckedCreateWithoutKnowledgeIntegrationsSourceInput>
  }

  export type AcademicDisciplineCreateWithoutKnowledgeIntegrationsTargetInput = {
    id?: string
    code: string
    name: string
    level?: number
    description?: string | null
    keywords?: AcademicDisciplineCreatekeywordsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    parentDiscipline?: AcademicDisciplineCreateNestedOneWithoutChildDisciplinesInput
    childDisciplines?: AcademicDisciplineCreateNestedManyWithoutParentDisciplineInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationCreateNestedManyWithoutSourceDisciplineInput
    projectDisciplines?: ProjectDisciplineCreateNestedManyWithoutDisciplineInput
  }

  export type AcademicDisciplineUncheckedCreateWithoutKnowledgeIntegrationsTargetInput = {
    id?: string
    code: string
    name: string
    parentDisciplineId?: string | null
    level?: number
    description?: string | null
    keywords?: AcademicDisciplineCreatekeywordsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    childDisciplines?: AcademicDisciplineUncheckedCreateNestedManyWithoutParentDisciplineInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutSourceDisciplineInput
    projectDisciplines?: ProjectDisciplineUncheckedCreateNestedManyWithoutDisciplineInput
  }

  export type AcademicDisciplineCreateOrConnectWithoutKnowledgeIntegrationsTargetInput = {
    where: AcademicDisciplineWhereUniqueInput
    create: XOR<AcademicDisciplineCreateWithoutKnowledgeIntegrationsTargetInput, AcademicDisciplineUncheckedCreateWithoutKnowledgeIntegrationsTargetInput>
  }

  export type UserUpsertWithoutKnowledgeIntegrationsInput = {
    update: XOR<UserUpdateWithoutKnowledgeIntegrationsInput, UserUncheckedUpdateWithoutKnowledgeIntegrationsInput>
    create: XOR<UserCreateWithoutKnowledgeIntegrationsInput, UserUncheckedCreateWithoutKnowledgeIntegrationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKnowledgeIntegrationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKnowledgeIntegrationsInput, UserUncheckedUpdateWithoutKnowledgeIntegrationsInput>
  }

  export type UserUpdateWithoutKnowledgeIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    projectCollaborations?: ProjectCollaboratorUpdateManyWithoutUserNestedInput
    assignedMethodologySteps?: ProjectMethodologyStepUpdateManyWithoutAssignedToNestedInput
    analyses?: ResearchAnalysisUpdateManyWithoutAnalystNestedInput
    approvedAnalyses?: ResearchAnalysisUpdateManyWithoutApprovedByNestedInput
    reviewedAnalyses?: ResearchAnalysisUpdateManyWithoutReviewedByNestedInput
    projects?: ResearchProjectUpdateManyWithoutPrincipalInvestigatorNestedInput
    uploadedImages?: UploadedImageUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutKnowledgeIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    projectCollaborations?: ProjectCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    assignedMethodologySteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutAssignedToNestedInput
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutAnalystNestedInput
    approvedAnalyses?: ResearchAnalysisUncheckedUpdateManyWithoutApprovedByNestedInput
    reviewedAnalyses?: ResearchAnalysisUncheckedUpdateManyWithoutReviewedByNestedInput
    projects?: ResearchProjectUncheckedUpdateManyWithoutPrincipalInvestigatorNestedInput
    uploadedImages?: UploadedImageUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type ResearchProjectUpsertWithoutKnowledgeIntegrationsInput = {
    update: XOR<ResearchProjectUpdateWithoutKnowledgeIntegrationsInput, ResearchProjectUncheckedUpdateWithoutKnowledgeIntegrationsInput>
    create: XOR<ResearchProjectCreateWithoutKnowledgeIntegrationsInput, ResearchProjectUncheckedCreateWithoutKnowledgeIntegrationsInput>
    where?: ResearchProjectWhereInput
  }

  export type ResearchProjectUpdateToOneWithWhereWithoutKnowledgeIntegrationsInput = {
    where?: ResearchProjectWhereInput
    data: XOR<ResearchProjectUpdateWithoutKnowledgeIntegrationsInput, ResearchProjectUncheckedUpdateWithoutKnowledgeIntegrationsInput>
  }

  export type ResearchProjectUpdateWithoutKnowledgeIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    disciplines?: ProjectDisciplineUpdateManyWithoutProjectNestedInput
    methodologySteps?: ProjectMethodologyStepUpdateManyWithoutProjectNestedInput
    occupations?: ProjectOccupationUpdateManyWithoutProjectNestedInput
    analyses?: ResearchAnalysisUpdateManyWithoutProjectNestedInput
    principalInvestigator?: UserUpdateOneRequiredWithoutProjectsNestedInput
    images?: UploadedImageUpdateManyWithoutProjectNestedInput
  }

  export type ResearchProjectUncheckedUpdateWithoutKnowledgeIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    principalInvestigatorId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    disciplines?: ProjectDisciplineUncheckedUpdateManyWithoutProjectNestedInput
    methodologySteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutProjectNestedInput
    occupations?: ProjectOccupationUncheckedUpdateManyWithoutProjectNestedInput
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutProjectNestedInput
    images?: UploadedImageUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AcademicDisciplineUpsertWithoutKnowledgeIntegrationsSourceInput = {
    update: XOR<AcademicDisciplineUpdateWithoutKnowledgeIntegrationsSourceInput, AcademicDisciplineUncheckedUpdateWithoutKnowledgeIntegrationsSourceInput>
    create: XOR<AcademicDisciplineCreateWithoutKnowledgeIntegrationsSourceInput, AcademicDisciplineUncheckedCreateWithoutKnowledgeIntegrationsSourceInput>
    where?: AcademicDisciplineWhereInput
  }

  export type AcademicDisciplineUpdateToOneWithWhereWithoutKnowledgeIntegrationsSourceInput = {
    where?: AcademicDisciplineWhereInput
    data: XOR<AcademicDisciplineUpdateWithoutKnowledgeIntegrationsSourceInput, AcademicDisciplineUncheckedUpdateWithoutKnowledgeIntegrationsSourceInput>
  }

  export type AcademicDisciplineUpdateWithoutKnowledgeIntegrationsSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: AcademicDisciplineUpdatekeywordsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentDiscipline?: AcademicDisciplineUpdateOneWithoutChildDisciplinesNestedInput
    childDisciplines?: AcademicDisciplineUpdateManyWithoutParentDisciplineNestedInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationUpdateManyWithoutTargetDisciplineNestedInput
    projectDisciplines?: ProjectDisciplineUpdateManyWithoutDisciplineNestedInput
  }

  export type AcademicDisciplineUncheckedUpdateWithoutKnowledgeIntegrationsSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentDisciplineId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: AcademicDisciplineUpdatekeywordsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childDisciplines?: AcademicDisciplineUncheckedUpdateManyWithoutParentDisciplineNestedInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationUncheckedUpdateManyWithoutTargetDisciplineNestedInput
    projectDisciplines?: ProjectDisciplineUncheckedUpdateManyWithoutDisciplineNestedInput
  }

  export type AcademicDisciplineUpsertWithoutKnowledgeIntegrationsTargetInput = {
    update: XOR<AcademicDisciplineUpdateWithoutKnowledgeIntegrationsTargetInput, AcademicDisciplineUncheckedUpdateWithoutKnowledgeIntegrationsTargetInput>
    create: XOR<AcademicDisciplineCreateWithoutKnowledgeIntegrationsTargetInput, AcademicDisciplineUncheckedCreateWithoutKnowledgeIntegrationsTargetInput>
    where?: AcademicDisciplineWhereInput
  }

  export type AcademicDisciplineUpdateToOneWithWhereWithoutKnowledgeIntegrationsTargetInput = {
    where?: AcademicDisciplineWhereInput
    data: XOR<AcademicDisciplineUpdateWithoutKnowledgeIntegrationsTargetInput, AcademicDisciplineUncheckedUpdateWithoutKnowledgeIntegrationsTargetInput>
  }

  export type AcademicDisciplineUpdateWithoutKnowledgeIntegrationsTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: AcademicDisciplineUpdatekeywordsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentDiscipline?: AcademicDisciplineUpdateOneWithoutChildDisciplinesNestedInput
    childDisciplines?: AcademicDisciplineUpdateManyWithoutParentDisciplineNestedInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationUpdateManyWithoutSourceDisciplineNestedInput
    projectDisciplines?: ProjectDisciplineUpdateManyWithoutDisciplineNestedInput
  }

  export type AcademicDisciplineUncheckedUpdateWithoutKnowledgeIntegrationsTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentDisciplineId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: AcademicDisciplineUpdatekeywordsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childDisciplines?: AcademicDisciplineUncheckedUpdateManyWithoutParentDisciplineNestedInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationUncheckedUpdateManyWithoutSourceDisciplineNestedInput
    projectDisciplines?: ProjectDisciplineUncheckedUpdateManyWithoutDisciplineNestedInput
  }

  export type ResearchProjectCreateWithoutCollaboratorsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeIntegrations?: KnowledgeIntegrationCreateNestedManyWithoutProjectInput
    disciplines?: ProjectDisciplineCreateNestedManyWithoutProjectInput
    methodologySteps?: ProjectMethodologyStepCreateNestedManyWithoutProjectInput
    occupations?: ProjectOccupationCreateNestedManyWithoutProjectInput
    analyses?: ResearchAnalysisCreateNestedManyWithoutProjectInput
    principalInvestigator: UserCreateNestedOneWithoutProjectsInput
    images?: UploadedImageCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectUncheckedCreateWithoutCollaboratorsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    principalInvestigatorId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutProjectInput
    disciplines?: ProjectDisciplineUncheckedCreateNestedManyWithoutProjectInput
    methodologySteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutProjectInput
    occupations?: ProjectOccupationUncheckedCreateNestedManyWithoutProjectInput
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutProjectInput
    images?: UploadedImageUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ResearchProjectCreateOrConnectWithoutCollaboratorsInput = {
    where: ResearchProjectWhereUniqueInput
    create: XOR<ResearchProjectCreateWithoutCollaboratorsInput, ResearchProjectUncheckedCreateWithoutCollaboratorsInput>
  }

  export type UserCreateWithoutProjectCollaborationsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    knowledgeIntegrations?: KnowledgeIntegrationCreateNestedManyWithoutCreatedByInput
    assignedMethodologySteps?: ProjectMethodologyStepCreateNestedManyWithoutAssignedToInput
    analyses?: ResearchAnalysisCreateNestedManyWithoutAnalystInput
    approvedAnalyses?: ResearchAnalysisCreateNestedManyWithoutApprovedByInput
    reviewedAnalyses?: ResearchAnalysisCreateNestedManyWithoutReviewedByInput
    projects?: ResearchProjectCreateNestedManyWithoutPrincipalInvestigatorInput
    uploadedImages?: UploadedImageCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutProjectCollaborationsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    department?: string | null
    specialization?: UserCreatespecializationInput | string[]
    orcidId?: string | null
    googleScholarId?: string | null
    linkedinUrl?: string | null
    isVerified?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: Date | string
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensTotal?: number
    tokensUsedToday?: number
    tokenLastResetDate?: Date | string
    isPro?: boolean
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedCreateNestedManyWithoutCreatedByInput
    assignedMethodologySteps?: ProjectMethodologyStepUncheckedCreateNestedManyWithoutAssignedToInput
    analyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutAnalystInput
    approvedAnalyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutApprovedByInput
    reviewedAnalyses?: ResearchAnalysisUncheckedCreateNestedManyWithoutReviewedByInput
    projects?: ResearchProjectUncheckedCreateNestedManyWithoutPrincipalInvestigatorInput
    uploadedImages?: UploadedImageUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutProjectCollaborationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectCollaborationsInput, UserUncheckedCreateWithoutProjectCollaborationsInput>
  }

  export type ResearchProjectUpsertWithoutCollaboratorsInput = {
    update: XOR<ResearchProjectUpdateWithoutCollaboratorsInput, ResearchProjectUncheckedUpdateWithoutCollaboratorsInput>
    create: XOR<ResearchProjectCreateWithoutCollaboratorsInput, ResearchProjectUncheckedCreateWithoutCollaboratorsInput>
    where?: ResearchProjectWhereInput
  }

  export type ResearchProjectUpdateToOneWithWhereWithoutCollaboratorsInput = {
    where?: ResearchProjectWhereInput
    data: XOR<ResearchProjectUpdateWithoutCollaboratorsInput, ResearchProjectUncheckedUpdateWithoutCollaboratorsInput>
  }

  export type ResearchProjectUpdateWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUpdateManyWithoutProjectNestedInput
    disciplines?: ProjectDisciplineUpdateManyWithoutProjectNestedInput
    methodologySteps?: ProjectMethodologyStepUpdateManyWithoutProjectNestedInput
    occupations?: ProjectOccupationUpdateManyWithoutProjectNestedInput
    analyses?: ResearchAnalysisUpdateManyWithoutProjectNestedInput
    principalInvestigator?: UserUpdateOneRequiredWithoutProjectsNestedInput
    images?: UploadedImageUpdateManyWithoutProjectNestedInput
  }

  export type ResearchProjectUncheckedUpdateWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    principalInvestigatorId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    disciplines?: ProjectDisciplineUncheckedUpdateManyWithoutProjectNestedInput
    methodologySteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutProjectNestedInput
    occupations?: ProjectOccupationUncheckedUpdateManyWithoutProjectNestedInput
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutProjectNestedInput
    images?: UploadedImageUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectCollaborationsInput = {
    update: XOR<UserUpdateWithoutProjectCollaborationsInput, UserUncheckedUpdateWithoutProjectCollaborationsInput>
    create: XOR<UserCreateWithoutProjectCollaborationsInput, UserUncheckedCreateWithoutProjectCollaborationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectCollaborationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectCollaborationsInput, UserUncheckedUpdateWithoutProjectCollaborationsInput>
  }

  export type UserUpdateWithoutProjectCollaborationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    knowledgeIntegrations?: KnowledgeIntegrationUpdateManyWithoutCreatedByNestedInput
    assignedMethodologySteps?: ProjectMethodologyStepUpdateManyWithoutAssignedToNestedInput
    analyses?: ResearchAnalysisUpdateManyWithoutAnalystNestedInput
    approvedAnalyses?: ResearchAnalysisUpdateManyWithoutApprovedByNestedInput
    reviewedAnalyses?: ResearchAnalysisUpdateManyWithoutReviewedByNestedInput
    projects?: ResearchProjectUpdateManyWithoutPrincipalInvestigatorNestedInput
    uploadedImages?: UploadedImageUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectCollaborationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: UserUpdatespecializationInput | string[]
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    googleScholarId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensTotal?: IntFieldUpdateOperationsInput | number
    tokensUsedToday?: IntFieldUpdateOperationsInput | number
    tokenLastResetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPro?: BoolFieldUpdateOperationsInput | boolean
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedMethodologySteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutAssignedToNestedInput
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutAnalystNestedInput
    approvedAnalyses?: ResearchAnalysisUncheckedUpdateManyWithoutApprovedByNestedInput
    reviewedAnalyses?: ResearchAnalysisUncheckedUpdateManyWithoutReviewedByNestedInput
    projects?: ResearchProjectUncheckedUpdateManyWithoutPrincipalInvestigatorNestedInput
    uploadedImages?: UploadedImageUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type KnowledgeIntegrationCreateManyCreatedByInput = {
    id?: string
    projectId: string
    sourceDisciplineId: string
    targetDisciplineId: string
    integrationType: $Enums.KnowledgeIntegrationType
    title: string
    description?: string | null
    sourceKnowledge?: string | null
    targetApplication?: string | null
    integrationMethod?: string | null
    validationStatus?: string
    validationNotes?: string | null
    noveltyScore?: Decimal | DecimalJsLike | number | string | null
    impactPotential?: string | null
    implementationFeasibility?: string | null
    references?: KnowledgeIntegrationCreatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCollaboratorCreateManyUserInput = {
    id?: string
    projectId: string
    role: string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: string | null
    joinedAt?: Date | string
    status?: string
  }

  export type ProjectMethodologyStepCreateManyAssignedToInput = {
    id?: string
    projectId: string
    methodologyStepId: string
    status?: string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    notes?: string | null
    deliverablesUploaded?: ProjectMethodologyStepCreatedeliverablesUploadedInput | string[]
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchAnalysisCreateManyAnalystInput = {
    id?: string
    projectId?: string | null
    imageId?: string | null
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchAnalysisCreateManyApprovedByInput = {
    id?: string
    projectId?: string | null
    imageId?: string | null
    analystId: string
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchAnalysisCreateManyReviewedByInput = {
    id?: string
    projectId?: string | null
    imageId?: string | null
    analystId: string
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchProjectCreateManyPrincipalInvestigatorInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    fundingSource?: string | null
    fundingAmount?: Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectCreateinstitutionsInput | string[]
    methodologyType: $Enums.MethodologyType
    researchQuestions?: ResearchProjectCreateresearchQuestionsInput | string[]
    objectives?: ResearchProjectCreateobjectivesInput | string[]
    hypotheses?: ResearchProjectCreatehypothesesInput | string[]
    ethicalApprovalRequired?: boolean
    ethicalApprovalStatus?: string | null
    dataClassification?: string
    collaborationLevel?: string
    isPublic?: boolean
    tags?: ResearchProjectCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadedImageCreateManyUploadedByInput = {
    id?: string
    projectId?: string | null
    fileName: string
    originalFileName?: string | null
    filePath: string
    fileSize?: bigint | number | null
    mimeType?: string | null
    imageType?: string | null
    imageConfidence?: Decimal | DecimalJsLike | number | string | null
    width?: number | null
    height?: number | null
    colorDepth?: number | null
    hasMetadata?: boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: $Enums.AnalysisStatus
    tags?: UploadedImageCreatetagsInput | string[]
    description?: string | null
    consentObtained?: boolean
    dataClassification?: string
    anonymized?: boolean
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeIntegrationUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationType?: EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput | $Enums.KnowledgeIntegrationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceKnowledge?: NullableStringFieldUpdateOperationsInput | string | null
    targetApplication?: NullableStringFieldUpdateOperationsInput | string | null
    integrationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    noveltyScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    impactPotential?: NullableStringFieldUpdateOperationsInput | string | null
    implementationFeasibility?: NullableStringFieldUpdateOperationsInput | string | null
    references?: KnowledgeIntegrationUpdatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ResearchProjectUpdateOneRequiredWithoutKnowledgeIntegrationsNestedInput
    sourceDiscipline?: AcademicDisciplineUpdateOneRequiredWithoutKnowledgeIntegrationsSourceNestedInput
    targetDiscipline?: AcademicDisciplineUpdateOneRequiredWithoutKnowledgeIntegrationsTargetNestedInput
  }

  export type KnowledgeIntegrationUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sourceDisciplineId?: StringFieldUpdateOperationsInput | string
    targetDisciplineId?: StringFieldUpdateOperationsInput | string
    integrationType?: EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput | $Enums.KnowledgeIntegrationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceKnowledge?: NullableStringFieldUpdateOperationsInput | string | null
    targetApplication?: NullableStringFieldUpdateOperationsInput | string | null
    integrationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    noveltyScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    impactPotential?: NullableStringFieldUpdateOperationsInput | string | null
    implementationFeasibility?: NullableStringFieldUpdateOperationsInput | string | null
    references?: KnowledgeIntegrationUpdatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeIntegrationUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sourceDisciplineId?: StringFieldUpdateOperationsInput | string
    targetDisciplineId?: StringFieldUpdateOperationsInput | string
    integrationType?: EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput | $Enums.KnowledgeIntegrationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceKnowledge?: NullableStringFieldUpdateOperationsInput | string | null
    targetApplication?: NullableStringFieldUpdateOperationsInput | string | null
    integrationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    noveltyScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    impactPotential?: NullableStringFieldUpdateOperationsInput | string | null
    implementationFeasibility?: NullableStringFieldUpdateOperationsInput | string | null
    references?: KnowledgeIntegrationUpdatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCollaboratorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    project?: ResearchProjectUpdateOneRequiredWithoutCollaboratorsNestedInput
  }

  export type ProjectCollaboratorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCollaboratorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectMethodologyStepUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliverablesUploaded?: ProjectMethodologyStepUpdatedeliverablesUploadedInput | string[]
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    methodologyStep?: MethodologyStepUpdateOneRequiredWithoutProjectStepsNestedInput
    project?: ResearchProjectUpdateOneRequiredWithoutMethodologyStepsNestedInput
  }

  export type ProjectMethodologyStepUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    methodologyStepId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliverablesUploaded?: ProjectMethodologyStepUpdatedeliverablesUploadedInput | string[]
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMethodologyStepUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    methodologyStepId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliverablesUploaded?: ProjectMethodologyStepUpdatedeliverablesUploadedInput | string[]
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchAnalysisUpdateWithoutAnalystInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: UserUpdateOneWithoutApprovedAnalysesNestedInput
    image?: UploadedImageUpdateOneWithoutAnalysesNestedInput
    project?: ResearchProjectUpdateOneWithoutAnalysesNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedAnalysesNestedInput
  }

  export type ResearchAnalysisUncheckedUpdateWithoutAnalystInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchAnalysisUncheckedUpdateManyWithoutAnalystInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchAnalysisUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyst?: UserUpdateOneRequiredWithoutAnalysesNestedInput
    image?: UploadedImageUpdateOneWithoutAnalysesNestedInput
    project?: ResearchProjectUpdateOneWithoutAnalysesNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedAnalysesNestedInput
  }

  export type ResearchAnalysisUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    analystId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchAnalysisUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    analystId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchAnalysisUpdateWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyst?: UserUpdateOneRequiredWithoutAnalysesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedAnalysesNestedInput
    image?: UploadedImageUpdateOneWithoutAnalysesNestedInput
    project?: ResearchProjectUpdateOneWithoutAnalysesNestedInput
  }

  export type ResearchAnalysisUncheckedUpdateWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    analystId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchAnalysisUncheckedUpdateManyWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    analystId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchProjectUpdateWithoutPrincipalInvestigatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUpdateManyWithoutProjectNestedInput
    disciplines?: ProjectDisciplineUpdateManyWithoutProjectNestedInput
    methodologySteps?: ProjectMethodologyStepUpdateManyWithoutProjectNestedInput
    occupations?: ProjectOccupationUpdateManyWithoutProjectNestedInput
    analyses?: ResearchAnalysisUpdateManyWithoutProjectNestedInput
    images?: UploadedImageUpdateManyWithoutProjectNestedInput
  }

  export type ResearchProjectUncheckedUpdateWithoutPrincipalInvestigatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeIntegrations?: KnowledgeIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    collaborators?: ProjectCollaboratorUncheckedUpdateManyWithoutProjectNestedInput
    disciplines?: ProjectDisciplineUncheckedUpdateManyWithoutProjectNestedInput
    methodologySteps?: ProjectMethodologyStepUncheckedUpdateManyWithoutProjectNestedInput
    occupations?: ProjectOccupationUncheckedUpdateManyWithoutProjectNestedInput
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutProjectNestedInput
    images?: UploadedImageUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ResearchProjectUncheckedUpdateManyWithoutPrincipalInvestigatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingSource?: NullableStringFieldUpdateOperationsInput | string | null
    fundingAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    institutions?: ResearchProjectUpdateinstitutionsInput | string[]
    methodologyType?: EnumMethodologyTypeFieldUpdateOperationsInput | $Enums.MethodologyType
    researchQuestions?: ResearchProjectUpdateresearchQuestionsInput | string[]
    objectives?: ResearchProjectUpdateobjectivesInput | string[]
    hypotheses?: ResearchProjectUpdatehypothesesInput | string[]
    ethicalApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    ethicalApprovalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataClassification?: StringFieldUpdateOperationsInput | string
    collaborationLevel?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: ResearchProjectUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedImageUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    colorDepth?: NullableIntFieldUpdateOperationsInput | number | null
    hasMetadata?: BoolFieldUpdateOperationsInput | boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    tags?: UploadedImageUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    consentObtained?: BoolFieldUpdateOperationsInput | boolean
    dataClassification?: StringFieldUpdateOperationsInput | string
    anonymized?: BoolFieldUpdateOperationsInput | boolean
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: ResearchAnalysisUpdateManyWithoutImageNestedInput
    project?: ResearchProjectUpdateOneWithoutImagesNestedInput
  }

  export type UploadedImageUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    colorDepth?: NullableIntFieldUpdateOperationsInput | number | null
    hasMetadata?: BoolFieldUpdateOperationsInput | boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    tags?: UploadedImageUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    consentObtained?: BoolFieldUpdateOperationsInput | boolean
    dataClassification?: StringFieldUpdateOperationsInput | string
    anonymized?: BoolFieldUpdateOperationsInput | boolean
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutImageNestedInput
  }

  export type UploadedImageUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    colorDepth?: NullableIntFieldUpdateOperationsInput | number | null
    hasMetadata?: BoolFieldUpdateOperationsInput | boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    tags?: UploadedImageUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    consentObtained?: BoolFieldUpdateOperationsInput | boolean
    dataClassification?: StringFieldUpdateOperationsInput | string
    anonymized?: BoolFieldUpdateOperationsInput | boolean
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicDisciplineCreateManyParentDisciplineInput = {
    id?: string
    code: string
    name: string
    level?: number
    description?: string | null
    keywords?: AcademicDisciplineCreatekeywordsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
  }

  export type KnowledgeIntegrationCreateManySourceDisciplineInput = {
    id?: string
    projectId: string
    targetDisciplineId: string
    integrationType: $Enums.KnowledgeIntegrationType
    title: string
    description?: string | null
    sourceKnowledge?: string | null
    targetApplication?: string | null
    integrationMethod?: string | null
    validationStatus?: string
    validationNotes?: string | null
    noveltyScore?: Decimal | DecimalJsLike | number | string | null
    impactPotential?: string | null
    implementationFeasibility?: string | null
    references?: KnowledgeIntegrationCreatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeIntegrationCreateManyTargetDisciplineInput = {
    id?: string
    projectId: string
    sourceDisciplineId: string
    integrationType: $Enums.KnowledgeIntegrationType
    title: string
    description?: string | null
    sourceKnowledge?: string | null
    targetApplication?: string | null
    integrationMethod?: string | null
    validationStatus?: string
    validationNotes?: string | null
    noveltyScore?: Decimal | DecimalJsLike | number | string | null
    impactPotential?: string | null
    implementationFeasibility?: string | null
    references?: KnowledgeIntegrationCreatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectDisciplineCreateManyDisciplineInput = {
    id?: string
    projectId: string
    primaryDiscipline?: boolean
    contributionLevel?: string
    createdAt?: Date | string
  }

  export type AcademicDisciplineUpdateWithoutParentDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: AcademicDisciplineUpdatekeywordsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childDisciplines?: AcademicDisciplineUpdateManyWithoutParentDisciplineNestedInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationUpdateManyWithoutSourceDisciplineNestedInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationUpdateManyWithoutTargetDisciplineNestedInput
    projectDisciplines?: ProjectDisciplineUpdateManyWithoutDisciplineNestedInput
  }

  export type AcademicDisciplineUncheckedUpdateWithoutParentDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: AcademicDisciplineUpdatekeywordsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childDisciplines?: AcademicDisciplineUncheckedUpdateManyWithoutParentDisciplineNestedInput
    knowledgeIntegrationsSource?: KnowledgeIntegrationUncheckedUpdateManyWithoutSourceDisciplineNestedInput
    knowledgeIntegrationsTarget?: KnowledgeIntegrationUncheckedUpdateManyWithoutTargetDisciplineNestedInput
    projectDisciplines?: ProjectDisciplineUncheckedUpdateManyWithoutDisciplineNestedInput
  }

  export type AcademicDisciplineUncheckedUpdateManyWithoutParentDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: AcademicDisciplineUpdatekeywordsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeIntegrationUpdateWithoutSourceDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationType?: EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput | $Enums.KnowledgeIntegrationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceKnowledge?: NullableStringFieldUpdateOperationsInput | string | null
    targetApplication?: NullableStringFieldUpdateOperationsInput | string | null
    integrationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    noveltyScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    impactPotential?: NullableStringFieldUpdateOperationsInput | string | null
    implementationFeasibility?: NullableStringFieldUpdateOperationsInput | string | null
    references?: KnowledgeIntegrationUpdatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutKnowledgeIntegrationsNestedInput
    project?: ResearchProjectUpdateOneRequiredWithoutKnowledgeIntegrationsNestedInput
    targetDiscipline?: AcademicDisciplineUpdateOneRequiredWithoutKnowledgeIntegrationsTargetNestedInput
  }

  export type KnowledgeIntegrationUncheckedUpdateWithoutSourceDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    targetDisciplineId?: StringFieldUpdateOperationsInput | string
    integrationType?: EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput | $Enums.KnowledgeIntegrationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceKnowledge?: NullableStringFieldUpdateOperationsInput | string | null
    targetApplication?: NullableStringFieldUpdateOperationsInput | string | null
    integrationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    noveltyScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    impactPotential?: NullableStringFieldUpdateOperationsInput | string | null
    implementationFeasibility?: NullableStringFieldUpdateOperationsInput | string | null
    references?: KnowledgeIntegrationUpdatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeIntegrationUncheckedUpdateManyWithoutSourceDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    targetDisciplineId?: StringFieldUpdateOperationsInput | string
    integrationType?: EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput | $Enums.KnowledgeIntegrationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceKnowledge?: NullableStringFieldUpdateOperationsInput | string | null
    targetApplication?: NullableStringFieldUpdateOperationsInput | string | null
    integrationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    noveltyScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    impactPotential?: NullableStringFieldUpdateOperationsInput | string | null
    implementationFeasibility?: NullableStringFieldUpdateOperationsInput | string | null
    references?: KnowledgeIntegrationUpdatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeIntegrationUpdateWithoutTargetDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationType?: EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput | $Enums.KnowledgeIntegrationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceKnowledge?: NullableStringFieldUpdateOperationsInput | string | null
    targetApplication?: NullableStringFieldUpdateOperationsInput | string | null
    integrationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    noveltyScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    impactPotential?: NullableStringFieldUpdateOperationsInput | string | null
    implementationFeasibility?: NullableStringFieldUpdateOperationsInput | string | null
    references?: KnowledgeIntegrationUpdatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutKnowledgeIntegrationsNestedInput
    project?: ResearchProjectUpdateOneRequiredWithoutKnowledgeIntegrationsNestedInput
    sourceDiscipline?: AcademicDisciplineUpdateOneRequiredWithoutKnowledgeIntegrationsSourceNestedInput
  }

  export type KnowledgeIntegrationUncheckedUpdateWithoutTargetDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sourceDisciplineId?: StringFieldUpdateOperationsInput | string
    integrationType?: EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput | $Enums.KnowledgeIntegrationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceKnowledge?: NullableStringFieldUpdateOperationsInput | string | null
    targetApplication?: NullableStringFieldUpdateOperationsInput | string | null
    integrationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    noveltyScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    impactPotential?: NullableStringFieldUpdateOperationsInput | string | null
    implementationFeasibility?: NullableStringFieldUpdateOperationsInput | string | null
    references?: KnowledgeIntegrationUpdatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeIntegrationUncheckedUpdateManyWithoutTargetDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sourceDisciplineId?: StringFieldUpdateOperationsInput | string
    integrationType?: EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput | $Enums.KnowledgeIntegrationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceKnowledge?: NullableStringFieldUpdateOperationsInput | string | null
    targetApplication?: NullableStringFieldUpdateOperationsInput | string | null
    integrationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    noveltyScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    impactPotential?: NullableStringFieldUpdateOperationsInput | string | null
    implementationFeasibility?: NullableStringFieldUpdateOperationsInput | string | null
    references?: KnowledgeIntegrationUpdatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDisciplineUpdateWithoutDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryDiscipline?: BoolFieldUpdateOperationsInput | boolean
    contributionLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ResearchProjectUpdateOneRequiredWithoutDisciplinesNestedInput
  }

  export type ProjectDisciplineUncheckedUpdateWithoutDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    primaryDiscipline?: BoolFieldUpdateOperationsInput | boolean
    contributionLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDisciplineUncheckedUpdateManyWithoutDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    primaryDiscipline?: BoolFieldUpdateOperationsInput | boolean
    contributionLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectOccupationCreateManyOccupationInput = {
    id?: string
    projectId: string
    relevanceLevel?: string
    roleDescription?: string | null
    createdAt?: Date | string
  }

  export type ProjectOccupationUpdateWithoutOccupationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevanceLevel?: StringFieldUpdateOperationsInput | string
    roleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ResearchProjectUpdateOneRequiredWithoutOccupationsNestedInput
  }

  export type ProjectOccupationUncheckedUpdateWithoutOccupationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    relevanceLevel?: StringFieldUpdateOperationsInput | string
    roleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectOccupationUncheckedUpdateManyWithoutOccupationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    relevanceLevel?: StringFieldUpdateOperationsInput | string
    roleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeIntegrationCreateManyProjectInput = {
    id?: string
    sourceDisciplineId: string
    targetDisciplineId: string
    integrationType: $Enums.KnowledgeIntegrationType
    title: string
    description?: string | null
    sourceKnowledge?: string | null
    targetApplication?: string | null
    integrationMethod?: string | null
    validationStatus?: string
    validationNotes?: string | null
    noveltyScore?: Decimal | DecimalJsLike | number | string | null
    impactPotential?: string | null
    implementationFeasibility?: string | null
    references?: KnowledgeIntegrationCreatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCollaboratorCreateManyProjectInput = {
    id?: string
    userId: string
    role: string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: string | null
    joinedAt?: Date | string
    status?: string
  }

  export type ProjectDisciplineCreateManyProjectInput = {
    id?: string
    disciplineId: string
    primaryDiscipline?: boolean
    contributionLevel?: string
    createdAt?: Date | string
  }

  export type ProjectMethodologyStepCreateManyProjectInput = {
    id?: string
    methodologyStepId: string
    assignedToId?: string | null
    status?: string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    notes?: string | null
    deliverablesUploaded?: ProjectMethodologyStepCreatedeliverablesUploadedInput | string[]
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectOccupationCreateManyProjectInput = {
    id?: string
    occupationId: string
    relevanceLevel?: string
    roleDescription?: string | null
    createdAt?: Date | string
  }

  export type ResearchAnalysisCreateManyProjectInput = {
    id?: string
    imageId?: string | null
    analystId: string
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadedImageCreateManyProjectInput = {
    id?: string
    uploadedById: string
    fileName: string
    originalFileName?: string | null
    filePath: string
    fileSize?: bigint | number | null
    mimeType?: string | null
    imageType?: string | null
    imageConfidence?: Decimal | DecimalJsLike | number | string | null
    width?: number | null
    height?: number | null
    colorDepth?: number | null
    hasMetadata?: boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: $Enums.AnalysisStatus
    tags?: UploadedImageCreatetagsInput | string[]
    description?: string | null
    consentObtained?: boolean
    dataClassification?: string
    anonymized?: boolean
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeIntegrationUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationType?: EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput | $Enums.KnowledgeIntegrationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceKnowledge?: NullableStringFieldUpdateOperationsInput | string | null
    targetApplication?: NullableStringFieldUpdateOperationsInput | string | null
    integrationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    noveltyScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    impactPotential?: NullableStringFieldUpdateOperationsInput | string | null
    implementationFeasibility?: NullableStringFieldUpdateOperationsInput | string | null
    references?: KnowledgeIntegrationUpdatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutKnowledgeIntegrationsNestedInput
    sourceDiscipline?: AcademicDisciplineUpdateOneRequiredWithoutKnowledgeIntegrationsSourceNestedInput
    targetDiscipline?: AcademicDisciplineUpdateOneRequiredWithoutKnowledgeIntegrationsTargetNestedInput
  }

  export type KnowledgeIntegrationUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDisciplineId?: StringFieldUpdateOperationsInput | string
    targetDisciplineId?: StringFieldUpdateOperationsInput | string
    integrationType?: EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput | $Enums.KnowledgeIntegrationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceKnowledge?: NullableStringFieldUpdateOperationsInput | string | null
    targetApplication?: NullableStringFieldUpdateOperationsInput | string | null
    integrationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    noveltyScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    impactPotential?: NullableStringFieldUpdateOperationsInput | string | null
    implementationFeasibility?: NullableStringFieldUpdateOperationsInput | string | null
    references?: KnowledgeIntegrationUpdatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeIntegrationUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDisciplineId?: StringFieldUpdateOperationsInput | string
    targetDisciplineId?: StringFieldUpdateOperationsInput | string
    integrationType?: EnumKnowledgeIntegrationTypeFieldUpdateOperationsInput | $Enums.KnowledgeIntegrationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceKnowledge?: NullableStringFieldUpdateOperationsInput | string | null
    targetApplication?: NullableStringFieldUpdateOperationsInput | string | null
    integrationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    noveltyScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    impactPotential?: NullableStringFieldUpdateOperationsInput | string | null
    implementationFeasibility?: NullableStringFieldUpdateOperationsInput | string | null
    references?: KnowledgeIntegrationUpdatereferencesInput | string[]
    supportingEvidence?: NullableJsonNullValueInput | InputJsonValue
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCollaboratorUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutProjectCollaborationsNestedInput
  }

  export type ProjectCollaboratorUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCollaboratorUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    contributionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectDisciplineUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryDiscipline?: BoolFieldUpdateOperationsInput | boolean
    contributionLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discipline?: AcademicDisciplineUpdateOneRequiredWithoutProjectDisciplinesNestedInput
  }

  export type ProjectDisciplineUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    disciplineId?: StringFieldUpdateOperationsInput | string
    primaryDiscipline?: BoolFieldUpdateOperationsInput | boolean
    contributionLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDisciplineUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    disciplineId?: StringFieldUpdateOperationsInput | string
    primaryDiscipline?: BoolFieldUpdateOperationsInput | boolean
    contributionLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMethodologyStepUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliverablesUploaded?: ProjectMethodologyStepUpdatedeliverablesUploadedInput | string[]
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedMethodologyStepsNestedInput
    methodologyStep?: MethodologyStepUpdateOneRequiredWithoutProjectStepsNestedInput
  }

  export type ProjectMethodologyStepUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    methodologyStepId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliverablesUploaded?: ProjectMethodologyStepUpdatedeliverablesUploadedInput | string[]
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMethodologyStepUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    methodologyStepId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliverablesUploaded?: ProjectMethodologyStepUpdatedeliverablesUploadedInput | string[]
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectOccupationUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevanceLevel?: StringFieldUpdateOperationsInput | string
    roleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    occupation?: OnetOccupationUpdateOneRequiredWithoutProjectOccupationsNestedInput
  }

  export type ProjectOccupationUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupationId?: StringFieldUpdateOperationsInput | string
    relevanceLevel?: StringFieldUpdateOperationsInput | string
    roleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectOccupationUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupationId?: StringFieldUpdateOperationsInput | string
    relevanceLevel?: StringFieldUpdateOperationsInput | string
    roleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchAnalysisUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyst?: UserUpdateOneRequiredWithoutAnalysesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedAnalysesNestedInput
    image?: UploadedImageUpdateOneWithoutAnalysesNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedAnalysesNestedInput
  }

  export type ResearchAnalysisUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    analystId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchAnalysisUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    analystId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedImageUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    colorDepth?: NullableIntFieldUpdateOperationsInput | number | null
    hasMetadata?: BoolFieldUpdateOperationsInput | boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    tags?: UploadedImageUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    consentObtained?: BoolFieldUpdateOperationsInput | boolean
    dataClassification?: StringFieldUpdateOperationsInput | string
    anonymized?: BoolFieldUpdateOperationsInput | boolean
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: ResearchAnalysisUpdateManyWithoutImageNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedImagesNestedInput
  }

  export type UploadedImageUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    colorDepth?: NullableIntFieldUpdateOperationsInput | number | null
    hasMetadata?: BoolFieldUpdateOperationsInput | boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    tags?: UploadedImageUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    consentObtained?: BoolFieldUpdateOperationsInput | boolean
    dataClassification?: StringFieldUpdateOperationsInput | string
    anonymized?: BoolFieldUpdateOperationsInput | boolean
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: ResearchAnalysisUncheckedUpdateManyWithoutImageNestedInput
  }

  export type UploadedImageUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalFileName?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    colorDepth?: NullableIntFieldUpdateOperationsInput | number | null
    hasMetadata?: BoolFieldUpdateOperationsInput | boolean
    dicomMetadata?: NullableJsonNullValueInput | InputJsonValue
    analysisStatus?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    tags?: UploadedImageUpdatetagsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    consentObtained?: BoolFieldUpdateOperationsInput | boolean
    dataClassification?: StringFieldUpdateOperationsInput | string
    anonymized?: BoolFieldUpdateOperationsInput | boolean
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMethodologyStepCreateManyMethodologyStepInput = {
    id?: string
    projectId: string
    assignedToId?: string | null
    status?: string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    notes?: string | null
    deliverablesUploaded?: ProjectMethodologyStepCreatedeliverablesUploadedInput | string[]
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMethodologyStepUpdateWithoutMethodologyStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliverablesUploaded?: ProjectMethodologyStepUpdatedeliverablesUploadedInput | string[]
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedMethodologyStepsNestedInput
    project?: ResearchProjectUpdateOneRequiredWithoutMethodologyStepsNestedInput
  }

  export type ProjectMethodologyStepUncheckedUpdateWithoutMethodologyStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliverablesUploaded?: ProjectMethodologyStepUpdatedeliverablesUploadedInput | string[]
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMethodologyStepUncheckedUpdateManyWithoutMethodologyStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliverablesUploaded?: ProjectMethodologyStepUpdatedeliverablesUploadedInput | string[]
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchAnalysisCreateManyImageInput = {
    id?: string
    projectId?: string | null
    analystId: string
    analysisType: string
    status?: $Enums.AnalysisStatus
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: number | null
    algorithmVersion?: string | null
    modelUsed?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    reviewRequired?: boolean
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchAnalysisUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyst?: UserUpdateOneRequiredWithoutAnalysesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedAnalysesNestedInput
    project?: ResearchProjectUpdateOneWithoutAnalysesNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedAnalysesNestedInput
  }

  export type ResearchAnalysisUncheckedUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    analystId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchAnalysisUncheckedUpdateManyWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    analystId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    status?: EnumAnalysisStatusFieldUpdateOperationsInput | $Enums.AnalysisStatus
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    algorithmVersion?: NullableStringFieldUpdateOperationsInput | string | null
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    differentialDiagnosis?: NullableJsonNullValueInput | InputJsonValue
    severityAssessment?: NullableJsonNullValueInput | InputJsonValue
    regionsOfInterest?: NullableJsonNullValueInput | InputJsonValue
    qualityMetrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcademicDisciplineCountOutputTypeDefaultArgs instead
     */
    export type AcademicDisciplineCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcademicDisciplineCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OnetOccupationCountOutputTypeDefaultArgs instead
     */
    export type OnetOccupationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OnetOccupationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResearchProjectCountOutputTypeDefaultArgs instead
     */
    export type ResearchProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResearchProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MethodologyStepCountOutputTypeDefaultArgs instead
     */
    export type MethodologyStepCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MethodologyStepCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UploadedImageCountOutputTypeDefaultArgs instead
     */
    export type UploadedImageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UploadedImageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcademicDisciplineDefaultArgs instead
     */
    export type AcademicDisciplineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcademicDisciplineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OnetOccupationDefaultArgs instead
     */
    export type OnetOccupationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OnetOccupationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResearchProjectDefaultArgs instead
     */
    export type ResearchProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResearchProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDisciplineDefaultArgs instead
     */
    export type ProjectDisciplineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDisciplineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectOccupationDefaultArgs instead
     */
    export type ProjectOccupationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectOccupationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MethodologyStepDefaultArgs instead
     */
    export type MethodologyStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MethodologyStepDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectMethodologyStepDefaultArgs instead
     */
    export type ProjectMethodologyStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectMethodologyStepDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UploadedImageDefaultArgs instead
     */
    export type UploadedImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UploadedImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResearchAnalysisDefaultArgs instead
     */
    export type ResearchAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResearchAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KnowledgeIntegrationDefaultArgs instead
     */
    export type KnowledgeIntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KnowledgeIntegrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCollaboratorDefaultArgs instead
     */
    export type ProjectCollaboratorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCollaboratorDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}